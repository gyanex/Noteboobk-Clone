import { HarmBlockThreshold, HarmCategory, createPartFromUri, Modality, GoogleGenAI } from '@google/genai';
export { Modality } from '@google/genai';
import { wrapLLMEvent } from '@llamaindex/core/decorator';
import { LiveLLM, LiveLLMSession, ToolCallLLM } from '@llamaindex/core/llms';
import { base64ToBlob, streamConverter, extractDataUrlComponents } from '@llamaindex/core/utils';
import { getEnv, randomUUID } from '@llamaindex/env';
import { ModalityType } from '@llamaindex/core/schema';
import { BaseEmbedding, batchEmbeddings } from '@llamaindex/core/embeddings';

var GEMINI_MODEL = /*#__PURE__*/ function(GEMINI_MODEL) {
    GEMINI_MODEL["GEMINI_PRO"] = "gemini-pro";
    GEMINI_MODEL["GEMINI_PRO_VISION"] = "gemini-pro-vision";
    GEMINI_MODEL["GEMINI_PRO_LATEST"] = "gemini-1.5-pro-latest";
    GEMINI_MODEL["GEMINI_PRO_FLASH_LATEST"] = "gemini-1.5-flash-latest";
    GEMINI_MODEL["GEMINI_PRO_1_5_PRO_PREVIEW"] = "gemini-1.5-pro-preview-0514";
    GEMINI_MODEL["GEMINI_PRO_1_5_FLASH_PREVIEW"] = "gemini-1.5-flash-preview-0514";
    GEMINI_MODEL["GEMINI_PRO_1_5"] = "gemini-1.5-pro-001";
    GEMINI_MODEL["GEMINI_PRO_1_5_FLASH"] = "gemini-1.5-flash-001";
    // Note: should be switched to -latest suffix when google supports it
    GEMINI_MODEL["GEMINI_PRO_1_5_LATEST"] = "gemini-1.5-pro-002";
    GEMINI_MODEL["GEMINI_PRO_1_5_FLASH_LATEST"] = "gemini-1.5-flash-002";
    GEMINI_MODEL["GEMINI_2_0_FLASH_EXPERIMENTAL"] = "gemini-2.0-flash-exp";
    GEMINI_MODEL["GEMINI_2_0_FLASH"] = "gemini-2.0-flash-001";
    GEMINI_MODEL["GEMINI_2_0_FLASH_LITE"] = "gemini-2.0-flash-lite-001";
    GEMINI_MODEL["GEMINI_2_0_FLASH_LITE_PREVIEW"] = "gemini-2.0-flash-lite-preview-02-05";
    GEMINI_MODEL["GEMINI_2_0_FLASH_THINKING_EXP"] = "gemini-2.0-flash-thinking-exp-01-21";
    GEMINI_MODEL["GEMINI_2_0_PRO_EXPERIMENTAL"] = "gemini-2.0-pro-exp-02-05";
    GEMINI_MODEL["GEMINI_2_0_FLASH_LIVE"] = "gemini-2.0-flash-live-001";
    GEMINI_MODEL["GEMINI_2_5_PRO_PREVIEW"] = "gemini-2.5-pro-preview-03-25";
    GEMINI_MODEL["GEMINI_2_5_PRO_PREVIEW_LATEST"] = "gemini-2.5-pro-preview-06-05";
    GEMINI_MODEL["GEMINI_2_5_FLASH_PREVIEW"] = "gemini-2.5-flash-preview-05-20";
    GEMINI_MODEL["GEMINI_2_5_PRO_LATEST"] = "gemini-2.5-pro";
    GEMINI_MODEL["GEMINI_2_5_FLASH_LATEST"] = "gemini-2.5-flash";
    GEMINI_MODEL["GEMINI_2_5_FLASH_LITE"] = "gemini-2.5-flash-lite";
    return GEMINI_MODEL;
}({});
const GEMINI_MODEL_INFO_MAP = {
    ["gemini-pro"]: {
        contextWindow: 30720
    },
    ["gemini-pro-vision"]: {
        contextWindow: 12288
    },
    // multi-modal/multi turn
    ["gemini-1.5-pro-latest"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-1.5-flash-latest"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-1.5-pro-preview-0514"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-1.5-flash-preview-0514"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-1.5-pro-001"]: {
        contextWindow: 2 * 10 ** 6
    },
    ["gemini-1.5-flash-001"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-1.5-pro-002"]: {
        contextWindow: 2 * 10 ** 6
    },
    ["gemini-1.5-flash-002"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.0-flash-exp"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.0-flash-001"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.0-flash-lite-preview-02-05"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.0-flash-lite-001"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.0-flash-live-001"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.0-flash-thinking-exp-01-21"]: {
        contextWindow: 32768
    },
    ["gemini-2.0-pro-exp-02-05"]: {
        contextWindow: 2 * 10 ** 6
    },
    ["gemini-2.5-pro-preview-03-25"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.5-pro-preview-06-05"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.5-flash-preview-05-20"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.5-pro"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.5-flash"]: {
        contextWindow: 10 ** 6
    },
    ["gemini-2.5-flash-lite"]: {
        contextWindow: 10 ** 6
    }
};
const SUPPORT_TOOL_CALL_MODELS = [
    "gemini-pro",
    "gemini-pro-vision",
    "gemini-1.5-pro-preview-0514",
    "gemini-1.5-flash-preview-0514",
    "gemini-1.5-pro-001",
    "gemini-1.5-flash-001",
    "gemini-1.5-pro-latest",
    "gemini-1.5-flash-latest",
    "gemini-1.5-pro-002",
    "gemini-1.5-flash-002",
    "gemini-2.0-flash-exp",
    "gemini-2.0-flash-001",
    "gemini-2.0-pro-exp-02-05",
    "gemini-2.5-pro-preview-03-25",
    "gemini-2.5-pro-preview-06-05",
    "gemini-2.5-flash-preview-05-20",
    "gemini-2.5-pro",
    "gemini-2.5-flash",
    "gemini-2.5-flash-lite"
];
const DEFAULT_GEMINI_PARAMS = {
    model: "gemini-pro",
    temperature: 0.1,
    topP: 1,
    maxTokens: undefined
};
/**
 * Safety settings to disable external filters
 * Documentation: https://ai.google.dev/gemini-api/docs/safety-settings
 */ const DEFAULT_SAFETY_SETTINGS = [
    {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_NONE
    },
    {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_NONE
    },
    {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_NONE
    },
    {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_NONE
    }
];
var GEMINI_MESSAGE_ROLE = /*#__PURE__*/ function(GEMINI_MESSAGE_ROLE) {
    GEMINI_MESSAGE_ROLE["USER"] = "user";
    GEMINI_MESSAGE_ROLE["MODEL"] = "model";
    return GEMINI_MESSAGE_ROLE;
}({});
// Gemini only has user and model roles. Put the rest in user role.
const ROLES_TO_GEMINI = {
    assistant: "model",
    user: "user",
    system: "user",
    memory: "user",
    developer: "user"
};
const ROLES_FROM_GEMINI = {
    ["model"]: "assistant",
    ["user"]: "user"
};

class GeminiMessageSender {
    constructor(session){
        this.geminiSession = session;
    }
    sendTextMessage(message, role) {
        this.geminiSession.session?.sendClientContent({
            turns: [
                {
                    parts: [
                        {
                            text: message
                        }
                    ],
                    ...role ? {
                        role
                    } : {}
                }
            ]
        });
    }
    sendAudioMessage(content, role) {
        this.geminiSession.session?.sendRealtimeInput({
            audio: {
                data: content.data,
                mimeType: content.mimeType
            }
        });
    }
    sendImageMessage(content, role) {
        this.geminiSession.session?.sendRealtimeInput({
            media: {
                data: content.data,
                mimeType: content.mimeType
            }
        });
    }
    sendVideoMessage(content, role) {
        this.geminiSession.session?.sendRealtimeInput({
            video: {
                data: content.data,
                mimeType: content.mimeType
            }
        });
    }
}

const mapBaseToolToGeminiFunctionDeclaration = (tool)=>{
    const { name, description, parameters } = tool.metadata;
    return {
        name,
        description,
        parameters: {
            type: parameters?.type.toLowerCase(),
            properties: parameters?.properties,
            description: parameters?.description,
            required: parameters?.required
        }
    };
};
/**
 * Maps a BaseTool to a Gemini Live Function Declaration format
 * Used for converting LlamaIndex tools to be compatible with Gemini's live API function calling
 *
 * @param tool - The BaseTool to convert
 * @returns A LiveFunctionDeclaration object that can be used with Gemini's live API
 */ function mapBaseToolToGeminiLiveFunctionDeclaration(tool) {
    const parameters = {
        type: tool.metadata.parameters?.type.toLowerCase(),
        properties: tool.metadata.parameters?.properties,
        description: tool.metadata.parameters?.description,
        required: tool.metadata.parameters?.required
    };
    return {
        name: tool.metadata.name,
        description: tool.metadata.description,
        parameters
    };
}
function mapResponseModalityToGeminiLiveResponseModality(responseModality) {
    return responseModality === ModalityType.TEXT ? Modality.TEXT : responseModality === ModalityType.AUDIO ? Modality.AUDIO : Modality.IMAGE;
}
// Gemini doesn't allow consecutive messages from the same role, so we need to merge them
function mergeNeighboringSameRoleMessages(messages) {
    return messages.map(cleanParts).filter((message)=>message.parts?.length).reduce((result, current, index, original)=>{
        if (index > 0 && original[index - 1].role === current.role) {
            result[result.length - 1].parts = [
                ...result[result.length - 1]?.parts || [],
                ...current.parts || []
            ];
        } else {
            result.push(current);
        }
        return result;
    }, []);
}
/**
 * Converts a MessageContentDetail object into a Google Gemini Part object.
 *
 * This function handles different content types appropriately for the Gemini API:
 * - Text content: Directly converts to Gemini text part
 * - Image URLs: Extracts MIME type and creates part from URI
 * - File/media content: Uploads to Google servers first, then creates part from uploaded URI
 *
 * @param content - The content to be converted (text, image URL, or base64 file data)
 * @param client - Google GenAI client
 *
 * @returns Promise that resolves to a Gemini-compatible Part object
 *
 * @throws {Error} When MIME type cannot be extracted from image URL
 * @throws {Error} When file upload fails
 * @throws {Error} When upload succeeds but URI or MIME type is missing from result
 */ async function messageContentDetailToGeminiPart(content, client) {
    // for text, just return the gemini text part
    if (content.type === "text") {
        return {
            text: content.text
        };
    }
    // for image has url already, extract mime type and create part from uri
    if (content.type === "image_url") {
        throw new Error("URL-based images are not supported in Gemini, please use type='image' for base64-encoded images instead");
    }
    // for the rest content types: image(base64), audio, video, file
    // upload it first and then create part from uri
    const result = await client.files.upload({
        file: base64ToBlob(content.data, content.mimeType),
        config: {
            mimeType: content.mimeType
        }
    });
    if (result.error) {
        throw new Error(`Failed to upload file`);
    }
    if (!result.uri || !result.mimeType) {
        throw new Error(`File is uploaded successfully, but missing uri or mimeType. URI: ${result.uri}, MIME Type: ${result.mimeType}`);
    }
    return createPartFromUri(result.uri, result.mimeType);
}
// Gemini doesn't allow parts that have empty text, so we need to clean them
function cleanParts(message) {
    return {
        ...message,
        parts: message.parts?.filter((part)=>part.text?.trim() || part.inlineData || part.fileData || part.functionCall || part.functionResponse) || []
    };
}

class GeminiLiveSession extends LiveLLMSession {
    constructor(){
        super(), this.closed = false;
    }
    get messageSender() {
        return new GeminiMessageSender(this);
    }
    isInterruptedEvent(event) {
        return event.serverContent?.interrupted === true;
    }
    isGenerationCompleteEvent(event) {
        return event.serverContent?.generationComplete === true;
    }
    isTurnCompleteEvent(event) {
        return event.serverContent?.turnComplete === true;
    }
    isTextEvent(event) {
        return event.serverContent?.modelTurn?.parts?.[0]?.text !== undefined;
    }
    isAudioEvent(event) {
        return event.serverContent?.modelTurn?.parts?.[0]?.inlineData?.data !== undefined;
    }
    isToolCallEvent(event) {
        return event.toolCall !== undefined;
    }
    isSetupCompleteEvent(event) {
        return event.setupComplete !== undefined;
    }
    //for the tool call event, we need to return the response with function responses
    async handleToolCallEvent(event, toolCalls) {
        const eventToolCalls = event.toolCall?.functionCalls;
        if (eventToolCalls) {
            await this.sendToolCallResponses(eventToolCalls, toolCalls);
        }
    }
    handleLiveEvents(event, toolCalls) {
        if (this.isTextEvent(event)) {
            this.pushEventToQueue({
                type: "text",
                text: event.serverContent?.modelTurn?.parts?.[0]?.text || ""
            });
        }
        if (this.isSetupCompleteEvent(event)) {
            this.pushEventToQueue({
                type: "setupComplete"
            });
        }
        if (this.isAudioEvent(event)) {
            this.pushEventToQueue({
                type: "audio",
                data: event.serverContent?.modelTurn?.parts?.[0]?.inlineData?.data || "",
                mimeType: event.serverContent?.modelTurn?.parts?.[0]?.inlineData?.mimeType || "audio/wav"
            });
        }
        if (this.isToolCallEvent(event)) {
            this.handleToolCallEvent(event, toolCalls);
        }
        if (this.isInterruptedEvent(event)) {
            this.pushEventToQueue({
                type: "interrupted"
            });
        }
        if (this.isGenerationCompleteEvent(event)) {
            this.pushEventToQueue({
                type: "generationComplete"
            });
        }
        if (this.isTurnCompleteEvent(event)) {
            this.pushEventToQueue({
                type: "turnComplete"
            });
        }
    }
    executeToolCall(toolCall, tool) {
        return tool.call(toolCall.args);
    }
    storeToolCallResponse(toolCall, response, functionResponses) {
        functionResponses.push({
            id: toolCall.id || "",
            name: toolCall.name || "",
            response: typeof response === "string" ? {
                result: response
            } : response
        });
    }
    async executeToolCallsAndStoreResponses(eventToolCalls, toolCalls) {
        const functionResponses = [];
        for (const toolCall of eventToolCalls){
            const tool = toolCalls.find((t)=>t.metadata.name === toolCall.name);
            if (tool && tool.call) {
                const response = await this.executeToolCall(toolCall, tool);
                this.storeToolCallResponse(toolCall, response, functionResponses);
            }
        }
        return functionResponses;
    }
    //execute the tool call and send the response to the server
    async sendToolCallResponses(eventToolCalls, toolCalls) {
        let functionResponses = [];
        if (eventToolCalls) {
            functionResponses = await this.executeToolCallsAndStoreResponses(eventToolCalls, toolCalls);
            //send the function responses to the gemini
            this.session?.sendToolResponse({
                functionResponses
            });
        }
    }
    async disconnect() {
        if (!this.session) {
            throw new Error("Session not connected");
        }
        this.session.close();
    }
}
class GeminiLive extends LiveLLM {
    constructor(init){
        super();
        this.apiKey = init?.apiKey ?? getEnv("GOOGLE_API_KEY");
        this.httpOptions = init?.httpOptions;
        if (!this.apiKey) {
            throw new Error("GOOGLE_API_KEY is not set");
        }
        this.client = new GoogleGenAI({
            apiKey: this.apiKey,
            ...this.httpOptions ? {
                httpOptions: this.httpOptions
            } : {}
        });
        this.voiceName = init?.voiceName;
        this.model = init?.model ?? GEMINI_MODEL.GEMINI_2_0_FLASH_LIVE;
        /* Only 2.0 flash live is supported for live mode */ if (this.model !== GEMINI_MODEL.GEMINI_2_0_FLASH_LIVE) {
            throw new Error("Only GEMINI_2_0_FLASH_LIVE is supported for live mode");
        }
    }
    async getEphemeralKey() {
        if (this.httpOptions?.apiVersion !== "v1alpha") {
            // see: https://github.com/googleapis/js-genai/issues/691#issuecomment-3002302279
            throw new Error("Ephemeral key generation is only supported in v1alpha");
        }
        const token = await this.client.authTokens.create({
            config: {
                liveConnectConstraints: {
                    model: this.model,
                    config: {
                        responseModalities: [
                            Modality.AUDIO
                        ]
                    }
                },
                httpOptions: this.httpOptions
            }
        });
        if (!token.name) {
            throw new Error("Failed to generate ephemeral key");
        }
        return token.name;
    }
    async connect(config) {
        const liveConfig = {
            responseModalities: config?.responseModality ? config.responseModality.map(mapResponseModalityToGeminiLiveResponseModality) : [
                Modality.AUDIO
            ]
        };
        if (config?.tools) {
            const tools = config.tools.map(mapBaseToolToGeminiLiveFunctionDeclaration);
            liveConfig.tools = [
                {
                    functionDeclarations: tools
                }
            ];
        }
        if (config?.systemInstruction) {
            liveConfig.systemInstruction = config.systemInstruction;
        }
        if (this.voiceName) {
            liveConfig.speechConfig = {
                voiceConfig: {
                    prebuiltVoiceConfig: {
                        voiceName: this.voiceName
                    }
                }
            };
        }
        if (config?.audioConfig) {
            throw new Error("Audio config is not supported for Gemini Live, directly send and recieve audio events instead");
        }
        const geminiLiveSession = new GeminiLiveSession();
        geminiLiveSession.session = await this.client.live.connect({
            model: this.model,
            config: {
                ...liveConfig
            },
            callbacks: {
                onmessage: (event)=>{
                    geminiLiveSession.handleLiveEvents(event, config?.tools || []);
                },
                onerror: (error)=>{
                    geminiLiveSession.pushEventToQueue({
                        type: "error",
                        error: error.error
                    });
                },
                onopen: ()=>{
                    geminiLiveSession.pushEventToQueue({
                        type: "open"
                    });
                },
                onclose: ()=>{
                    geminiLiveSession.pushEventToQueue({
                        type: "close"
                    });
                }
            }
        });
        return geminiLiveSession;
    }
}

function applyDecs2203RFactory$1() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r$1(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r$1 = applyDecs2203RFactory$1())(targetClass, memberDecs, classDecs, parentClass);
}
var _initProto$1;
/**
 * ToolCallLLM for Gemini
 */ class Gemini extends ToolCallLLM {
    static{
        ({ e: [_initProto$1] } = _apply_decs_2203_r$1(this, [
            [
                wrapLLMEvent,
                2,
                "chat"
            ]
        ], []));
    }
    constructor(init){
        super(), _initProto$1(this);
        this.model = init?.model ?? GEMINI_MODEL.GEMINI_PRO;
        this.temperature = init?.temperature ?? 0.1;
        this.topP = init?.topP ?? 1;
        this.maxTokens = init?.maxTokens ?? undefined;
        this.safetySettings = init?.safetySettings ?? DEFAULT_SAFETY_SETTINGS;
        this.voiceName = init?.voiceName;
        this.httpOptions = init?.httpOptions;
        this.apiKey = init?.apiKey ?? getEnv("GOOGLE_API_KEY");
        if (!this.apiKey) {
            throw new Error("Set Google API Key in GOOGLE_API_KEY env variable");
        }
        if (init?.vertex) {
            // Project/location and API key are mutually exclusive in the client initializer for Vertex AI
            // So that we either need to provide project/location or apiKey
            // See: https://github.com/googleapis/js-genai/blob/58a369ed36cd05be652c2279dcc9634fffc9fc10/src/node/node_client.ts#L89-L93
            if (init?.vertex.project && init?.vertex.location) {
                // when using Vertex AI, if project and location are provided, use them to create the client
                this.client = new GoogleGenAI({
                    vertexai: true,
                    project: init.vertex.project,
                    location: init.vertex.location
                });
            } else {
                // when using Vertex AI, if project and location are not provided, use apiKey to create the client
                this.client = new GoogleGenAI({
                    vertexai: true,
                    apiKey: this.apiKey
                });
            }
        } else {
            this.client = new GoogleGenAI({
                ...init,
                apiKey: this.apiKey
            });
        }
    }
    get supportToolCall() {
        return SUPPORT_TOOL_CALL_MODELS.includes(this.model);
    }
    get live() {
        if (!this._live) {
            this._live = new GeminiLive({
                apiKey: this.apiKey,
                voiceName: this.voiceName,
                model: this.model,
                httpOptions: this.httpOptions
            });
        }
        return this._live;
    }
    get metadata() {
        return {
            model: this.model,
            temperature: this.temperature,
            topP: this.topP,
            maxTokens: this.maxTokens,
            contextWindow: GEMINI_MODEL_INFO_MAP[this.model].contextWindow,
            tokenizer: undefined,
            structuredOutput: false,
            safetySettings: this.safetySettings
        };
    }
    get generationConfig() {
        return {
            temperature: this.temperature,
            topP: this.topP,
            safetySettings: this.safetySettings,
            ...this.maxTokens ? {
                maxOutputTokens: this.maxTokens
            } : {}
        };
    }
    async chat(params) {
        if (params.stream) return this.streamChat(params);
        return this.nonStreamChat(params);
    }
    async complete(params) {
        if (params.stream) return this.streamGenerate(params);
        return this.nonStreamGenerate(params);
    }
    async nonStreamChat(params) {
        const config = this.prepareChatConfig(params);
        const { message, history } = await this.prepareChatContext(params.messages);
        const chat = this.client.chats.create({
            model: this.model,
            config,
            history
        });
        const response = await chat.sendMessage({
            message
        });
        const topCandidate = response.candidates?.[0];
        const geminiRole = topCandidate?.content?.role ?? GEMINI_MESSAGE_ROLE.MODEL;
        const toolCall = response.functionCalls?.map((call)=>({
                id: call.id ?? randomUUID(),
                name: call.name,
                input: call.args
            }));
        return {
            message: {
                content: response.text ?? "",
                role: ROLES_FROM_GEMINI[geminiRole],
                options: toolCall?.length ? {
                    toolCall
                } : undefined
            },
            raw: response
        };
    }
    async streamChat(params) {
        const config = this.prepareChatConfig(params);
        const { message, history } = await this.prepareChatContext(params.messages);
        const chat = this.client.chats.create({
            model: this.model,
            config,
            history
        });
        const generator = await chat.sendMessageStream({
            message
        });
        return streamConverter(generator, (response)=>{
            const toolCall = response.functionCalls?.map((call)=>({
                    id: call.id ?? randomUUID(),
                    name: call.name,
                    input: call.args
                }));
            return {
                delta: response.text ?? "",
                options: toolCall?.length ? {
                    toolCall
                } : undefined,
                raw: response
            };
        });
    }
    async streamGenerate(params) {
        const { prompt: content } = params;
        const contents = await this.messageContentToGeminiParts(content);
        const generator = await this.client.models.generateContentStream({
            model: this.model,
            contents,
            config: this.generationConfig
        });
        return streamConverter(generator, (response)=>({
                text: response.text ?? "",
                raw: response
            }));
    }
    async nonStreamGenerate(params) {
        const { prompt: content } = params;
        const contents = await this.messageContentToGeminiParts(content);
        const result = await this.client.models.generateContent({
            model: this.model,
            config: this.generationConfig,
            contents
        });
        return {
            text: result.text ?? "",
            raw: result
        };
    }
    prepareChatConfig(params) {
        const config = {
            ...this.generationConfig
        };
        const functionDeclarations = params.tools?.map(mapBaseToolToGeminiFunctionDeclaration) ?? [];
        if (functionDeclarations.length) {
            config.tools = [
                {
                    functionDeclarations
                }
            ];
        }
        return config;
    }
    /**
   * Prepare chat history and last message for chatting
   * @param messages - array of LlamaIndex ChatMessage
   * @returns chat history and last message
   */ async prepareChatContext(messages) {
        // map tool call id to tool name
        const toolMap = messages.reduce((result, message)=>{
            const { options } = message;
            if (options && "toolCall" in options) {
                options.toolCall.forEach((call)=>{
                    result[call.id] = call.name;
                });
            }
            return result;
        }, {});
        const geminiMessages = await Promise.all(messages.map(async (m)=>({
                role: ROLES_TO_GEMINI[m.role],
                parts: await this.messageToGeminiParts(m, toolMap)
            })));
        const mergedMessages = mergeNeighboringSameRoleMessages(geminiMessages);
        return {
            history: mergedMessages.slice(0, -1),
            message: mergedMessages[mergedMessages.length - 1]?.parts || []
        };
    }
    async messageToGeminiParts(message, toolMap) {
        const { options, content } = message;
        // if message has toolResult, return a gemini function response part
        if (options && "toolResult" in options) {
            const { id, result } = options.toolResult;
            const name = toolMap[id];
            if (!name) {
                throw Error(`Could not find the tool name with id ${id}`);
            }
            return [
                {
                    functionResponse: {
                        id,
                        name,
                        response: {
                            result
                        }
                    }
                }
            ];
        }
        // if message has toolCall, return a list of gemini function call parts
        if (options && "toolCall" in options) {
            return options.toolCall.map((call)=>({
                    functionCall: {
                        id: call.id,
                        name: call.name,
                        args: call.input
                    }
                }));
        }
        // otherwise, extract parts from message content
        return await this.messageContentToGeminiParts(content);
    }
    async messageContentToGeminiParts(content) {
        // if message content is a string, just return a gemini text part
        if (typeof content === "string") return [
            {
                text: content
            }
        ];
        // if message content is an array of content details, convert each to a gemini part
        // also upload files if needed
        return await Promise.all(content.map((item)=>messageContentDetailToGeminiPart(item, this.client)));
    }
}
/**
 * Convenience function to create a new Gemini instance.
 * @param init - Optional initialization parameters for the Gemini instance.
 * @returns A new Gemini instance.
 */ const gemini = (init)=>new Gemini(init);

const mapMessageContentToMessageContentDetails = (content)=>{
    return Array.isArray(content) ? content : [
        {
            type: "text",
            text: content
        }
    ];
};
const ACCEPTED_IMAGE_MIME_TYPES = [
    "image/jpeg",
    "image/png"
];
const mapTextPart = (text)=>{
    return {
        text
    };
};
const mapImagePart = (imageUrl)=>{
    if (!imageUrl.startsWith("data:")) throw new Error("For Google please only use base64 data url, e.g.: data:image/jpeg;base64,SGVsbG8sIFdvcmxkIQ==");
    const { mimeType, base64: data } = extractDataUrlComponents(imageUrl);
    if (!ACCEPTED_IMAGE_MIME_TYPES.includes(mimeType)) throw new Error(`Anthropic only accepts the following mimeTypes: ${ACCEPTED_IMAGE_MIME_TYPES.join("\n")}`);
    return {
        inlineData: {
            mimeType,
            data
        }
    };
};
const mapMessageContentDetailToGooglePart = (detail)=>{
    let part;
    if (detail.type === "text") {
        part = mapTextPart(detail.text);
    } else if (detail.type === "image_url") {
        part = mapImagePart(detail.image_url.url);
    } else {
        throw new Error("Unsupported content detail type");
    }
    return part;
};
const mapChatMessagesToGoogleFunctions = (tools)=>{
    return [
        {
            functionDeclarations: tools.map((tool)=>({
                    response: tool.metadata.parameters,
                    description: tool.metadata.description,
                    name: tool.metadata.name
                }))
        }
    ];
};
const mapChatMessagesToGoogleMessages = (messages)=>{
    const functionNames = {};
    messages.forEach((msg)=>{
        if (msg.options && "toolCall" in msg.options) {
            const mapped = msg.options.toolCall.reduce((result, item)=>{
                result[item.id] = item.name;
                return result;
            }, {});
            Object.assign(functionNames, mapped);
        }
    });
    // Transform messages to Google API format
    const contents = messages.flatMap((msg)=>{
        if (msg.options && "toolResult" in msg.options) {
            return [
                {
                    role: "user",
                    parts: [
                        {
                            functionResponse: {
                                name: functionNames[msg.options.toolResult.id] ?? "",
                                response: msg.options.toolResult
                            }
                        }
                    ]
                }
            ];
        }
        if (msg.options && "toolCall" in msg.options) {
            return [
                {
                    role: "model",
                    parts: msg.options.toolCall.map((call)=>({
                            functionCall: {
                                name: call.name,
                                args: call.input
                            }
                        }))
                }
            ];
        }
        const mapped = mapMessageContentToMessageContentDetails(msg.content).map((detail)=>{
            const part = mapMessageContentDetailToGooglePart(detail);
            if (!part.text && !part.inlineData) return null;
            return {
                role: msg.role === "assistant" ? "model" : "user",
                parts: [
                    part
                ]
            };
        }).filter((content)=>content !== null);
        return mapped;
    });
    return contents;
};

function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _initProto;
const getGoogleStudioInlineData = (response)=>{
    return response.candidates?.flatMap((candidate)=>candidate.content?.parts).map((part)=>part?.inlineData).filter((data)=>data);
};
class GoogleStudio extends ToolCallLLM {
    static{
        ({ e: [_initProto] } = _apply_decs_2203_r(this, [
            [
                wrapLLMEvent,
                2,
                "chat"
            ]
        ], []));
    }
    constructor({ temperature, topP, maxTokens, model, ...params }){
        super(), _initProto(this);
        this.model = model;
        this.maxTokens = maxTokens ?? DEFAULT_GEMINI_PARAMS.maxTokens;
        this.temperature = temperature ?? DEFAULT_GEMINI_PARAMS.temperature;
        this.topP = topP ?? DEFAULT_GEMINI_PARAMS.topP;
        this.client = new GoogleGenAI(params);
    }
    get supportToolCall() {
        return SUPPORT_TOOL_CALL_MODELS.includes(this.model);
    }
    get metadata() {
        return {
            model: this.model,
            temperature: this.temperature,
            topP: this.topP,
            maxTokens: this.maxTokens,
            contextWindow: 128000,
            tokenizer: undefined,
            structuredOutput: false
        };
    }
    getToolCallsFromResponse(response) {
        if (!response.functionCalls) return [];
        return response.functionCalls.map((call)=>({
                id: call.id ?? randomUUID(),
                name: call.name ?? "",
                input: call.args
            }));
    }
    async nonStreamChat(params) {
        if (!this.supportToolCall && params.tools?.length) {
            console.warn(`The model "${this.model}" doesn't support ToolCall`);
        }
        const config = params.additionalChatOptions?.config ?? {};
        if (params.tools?.length) {
            if (config.responseModalities?.includes(Modality.IMAGE)) {
                console.warn("Tools are currently not supported with Modality.IMAGE");
            } else {
                config.tools = mapChatMessagesToGoogleFunctions(params.tools);
            }
        }
        const response = await this.client.models.generateContent({
            model: this.model,
            contents: mapChatMessagesToGoogleMessages(params.messages),
            config
        });
        if (this.supportToolCall) {
            const tools = this.getToolCallsFromResponse(response);
            if (tools.length) {
                return {
                    raw: response,
                    message: {
                        role: "assistant",
                        content: "",
                        options: {
                            toolCall: tools
                        }
                    }
                };
            }
        }
        return {
            raw: response,
            message: {
                role: "assistant",
                content: response.text ?? "",
                options: {
                    inlineData: getGoogleStudioInlineData(response)
                }
            }
        };
    }
    async *reduceStream(stream) {
        for await (const response of stream){
            if (response.functionCalls?.length) {
                const toolCalls = this.getToolCallsFromResponse(response);
                yield {
                    delta: "",
                    raw: response,
                    options: {
                        toolCall: toolCalls
                    }
                };
            }
            const text = response.candidates?.flatMap((candidate)=>candidate.content?.parts).map((part)=>part?.text ?? "").filter((text)=>text).join("");
            if (!text) continue;
            yield {
                delta: text,
                raw: response,
                options: {
                    inlineData: getGoogleStudioInlineData(response)
                }
            };
        }
    }
    async *streamChat(params) {
        if (!this.supportToolCall && params.tools?.length) {
            console.warn(`The model "${this.model}" doesn't support ToolCall`);
        }
        const config = params.additionalChatOptions?.config ?? {};
        if (params.tools?.length) {
            if (config.responseModalities?.includes(Modality.IMAGE)) {
                console.warn("Tools are currently not supported with Modality.IMAGE");
            } else {
                config.tools = mapChatMessagesToGoogleFunctions(params.tools);
            }
        }
        const response = await this.client.models.generateContentStream({
            model: this.model,
            contents: mapChatMessagesToGoogleMessages(params.messages),
            config
        });
        yield* this.reduceStream(response);
    }
    async chat(params) {
        if (params.stream) {
            return this.streamChat(params);
        }
        return this.nonStreamChat(params);
    }
    async complete(params) {
        const contents = mapMessageContentToMessageContentDetails(params.prompt).map(mapMessageContentDetailToGooglePart);
        if (params.stream) {
            const response = await this.client.models.generateContentStream({
                model: this.model,
                contents
            });
            return streamConverter(response, (response)=>{
                return {
                    text: response.text ?? "",
                    raw: response
                };
            });
        }
        const response = await this.client.models.generateContent({
            model: this.model,
            contents
        });
        return {
            text: response.text || "",
            raw: response
        };
    }
}

var GEMINI_EMBEDDING_MODEL = /*#__PURE__*/ function(GEMINI_EMBEDDING_MODEL) {
    GEMINI_EMBEDDING_MODEL["EMBEDDING_001"] = "embedding-001";
    GEMINI_EMBEDDING_MODEL["TEXT_EMBEDDING_004"] = "text-embedding-004";
    return GEMINI_EMBEDDING_MODEL;
}({});
// 100 is max batch size, see https://github.com/run-llama/LlamaIndexTS/pull/2099
const DEFAULT_EMBED_BATCH_SIZE = 100;
/**
 * GeminiEmbedding is an alias for Gemini that implements the BaseEmbedding interface.
 */ class GeminiEmbedding extends BaseEmbedding {
    constructor(opts){
        super(), this.embedBatchSize = DEFAULT_EMBED_BATCH_SIZE, this.getTextEmbeddings = async (texts)=>{
            const result = await this.ai.models.embedContent({
                model: this.model,
                contents: texts
            });
            return result.embeddings?.map((embedding)=>embedding.values ?? []) ?? [];
        };
        const apiKey = opts?.apiKey ?? getEnv("GOOGLE_API_KEY");
        if (!apiKey) {
            throw new Error("Set Google API Key in GOOGLE_API_KEY env variable");
        }
        this.ai = new GoogleGenAI({
            ...opts,
            apiKey
        });
        this.model = opts?.model ?? "embedding-001";
        this.embedBatchSize = opts?.embedBatchSize ?? DEFAULT_EMBED_BATCH_SIZE;
    }
    async getTextEmbeddingsBatch(texts, options) {
        return await batchEmbeddings(texts, this.getTextEmbeddings.bind(this), this.embedBatchSize, options);
    }
    async getTextEmbedding(text) {
        const result = await this.ai.models.embedContent({
            model: this.model,
            contents: text
        });
        return result.embeddings?.[0]?.values ?? [];
    }
}

export { DEFAULT_EMBED_BATCH_SIZE, DEFAULT_GEMINI_PARAMS, DEFAULT_SAFETY_SETTINGS, GEMINI_EMBEDDING_MODEL, GEMINI_MESSAGE_ROLE, GEMINI_MODEL, GEMINI_MODEL_INFO_MAP, Gemini, GeminiEmbedding, GeminiLive, GeminiLiveSession, GoogleStudio, ROLES_FROM_GEMINI, ROLES_TO_GEMINI, SUPPORT_TOOL_CALL_MODELS, gemini, getGoogleStudioInlineData, mapBaseToolToGeminiFunctionDeclaration, mapBaseToolToGeminiLiveFunctionDeclaration, mapResponseModalityToGeminiLiveResponseModality, mergeNeighboringSameRoleMessages, messageContentDetailToGeminiPart };
