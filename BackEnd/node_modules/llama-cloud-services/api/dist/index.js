var j = async (t, r)=>{
    let e = typeof r == "function" ? await r(t) : r;
    if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
}, z = (t, r, e)=>{
    typeof e == "string" || e instanceof Blob ? t.append(r, e) : t.append(r, JSON.stringify(e));
}, k = {
    bodySerializer: (t)=>{
        let r = new FormData;
        return Object.entries(t).forEach(([e, i])=>{
            i != null && (Array.isArray(i) ? i.forEach((a)=>z(r, e, a)) : z(r, e, i));
        }), r;
    }
}, R = {
    bodySerializer: (t)=>JSON.stringify(t, (r, e)=>typeof e == "bigint" ? e.toString() : e)
}, U = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, _ = (t)=>{
    switch(t){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
}, D = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, O = ({ allowReserved: t, explode: r, name: e, style: i, value: a })=>{
    if (!r) {
        let n = (t ? a : a.map((l)=>encodeURIComponent(l))).join(_(i));
        switch(i){
            case "label":
                return `.${n}`;
            case "matrix":
                return `;${e}=${n}`;
            case "simple":
                return n;
            default:
                return `${e}=${n}`;
        }
    }
    let o = U(i), s = a.map((n)=>i === "label" || i === "simple" ? t ? n : encodeURIComponent(n) : y({
            allowReserved: t,
            name: e,
            value: n
        })).join(o);
    return i === "label" || i === "matrix" ? o + s : s;
}, y = ({ allowReserved: t, name: r, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${r}=${t ? e : encodeURIComponent(e)}`;
}, q = ({ allowReserved: t, explode: r, name: e, style: i, value: a })=>{
    if (a instanceof Date) return `${e}=${a.toISOString()}`;
    if (i !== "deepObject" && !r) {
        let n = [];
        Object.entries(a).forEach(([f, p])=>{
            n = [
                ...n,
                f,
                t ? p : encodeURIComponent(p)
            ];
        });
        let l = n.join(",");
        switch(i){
            case "form":
                return `${e}=${l}`;
            case "label":
                return `.${l}`;
            case "matrix":
                return `;${e}=${l}`;
            default:
                return l;
        }
    }
    let o = D(i), s = Object.entries(a).map(([n, l])=>y({
            allowReserved: t,
            name: i === "deepObject" ? `${e}[${n}]` : n,
            value: l
        })).join(o);
    return i === "label" || i === "matrix" ? o + s : s;
};
var H = /\{[^{}]+\}/g, B = ({ path: t, url: r })=>{
    let e = r, i = r.match(H);
    if (i) for (let a of i){
        let o = false, s = a.substring(1, a.length - 1), n = "simple";
        s.endsWith("*") && (o = true, s = s.substring(0, s.length - 1)), s.startsWith(".") ? (s = s.substring(1), n = "label") : s.startsWith(";") && (s = s.substring(1), n = "matrix");
        let l = t[s];
        if (l == null) continue;
        if (Array.isArray(l)) {
            e = e.replace(a, O({
                explode: o,
                name: s,
                style: n,
                value: l
            }));
            continue;
        }
        if (typeof l == "object") {
            e = e.replace(a, q({
                explode: o,
                name: s,
                style: n,
                value: l
            }));
            continue;
        }
        if (n === "matrix") {
            e = e.replace(a, `;${y({
                name: s,
                value: l
            })}`);
            continue;
        }
        let f = encodeURIComponent(n === "label" ? `.${l}` : l);
        e = e.replace(a, f);
    }
    return e;
}, A = ({ allowReserved: t, array: r, object: e } = {})=>(a)=>{
        let o = [];
        if (a && typeof a == "object") for(let s in a){
            let n = a[s];
            if (n != null) if (Array.isArray(n)) {
                let l = O({
                    allowReserved: t,
                    explode: true,
                    name: s,
                    style: "form",
                    value: n,
                    ...r
                });
                l && o.push(l);
            } else if (typeof n == "object") {
                let l = q({
                    allowReserved: t,
                    explode: true,
                    name: s,
                    style: "deepObject",
                    value: n,
                    ...e
                });
                l && o.push(l);
            } else {
                let l = y({
                    allowReserved: t,
                    name: s,
                    value: n
                });
                l && o.push(l);
            }
        }
        return o.join("&");
    }, P = (t)=>{
    if (!t) return "stream";
    let r = t.split(";")[0]?.trim();
    if (r) {
        if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
        if (r === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((e)=>r.startsWith(e))) return "blob";
        if (r.startsWith("text/")) return "text";
    }
}, E = async ({ security: t, ...r })=>{
    for (let e of t){
        let i = await j(e, r.auth);
        if (!i) continue;
        let a = e.name ?? "Authorization";
        switch(e.in){
            case "query":
                r.query || (r.query = {}), r.query[a] = i;
                break;
            case "cookie":
                r.headers.append("Cookie", `${a}=${i}`);
                break;
            case "header":
            default:
                r.headers.set(a, i);
                break;
        }
        return;
    }
}, S = (t)=>W({
        baseUrl: t.baseUrl,
        path: t.path,
        query: t.query,
        querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : A(t.querySerializer),
        url: t.url
    }), W = ({ baseUrl: t, path: r, query: e, querySerializer: i, url: a })=>{
    let o = a.startsWith("/") ? a : `/${a}`, s = (t ?? "") + o;
    r && (s = B({
        path: r,
        url: s
    }));
    let n = e ? i(e) : "";
    return n.startsWith("?") && (n = n.substring(1)), n && (s += `?${n}`), s;
}, x = (t, r)=>{
    let e = {
        ...t,
        ...r
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = C(t.headers, r.headers), e;
}, C = (...t)=>{
    let r = new Headers;
    for (let e of t){
        if (!e || typeof e != "object") continue;
        let i = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [a, o] of i)if (o === null) r.delete(a);
        else if (Array.isArray(o)) for (let s of o)r.append(a, s);
        else o !== void 0 && r.set(a, typeof o == "object" ? JSON.stringify(o) : o);
    }
    return r;
}, h = class {
    constructor(){
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    getInterceptorIndex(r) {
        return typeof r == "number" ? this._fns[r] ? r : -1 : this._fns.indexOf(r);
    }
    exists(r) {
        let e = this.getInterceptorIndex(r);
        return !!this._fns[e];
    }
    eject(r) {
        let e = this.getInterceptorIndex(r);
        this._fns[e] && (this._fns[e] = null);
    }
    update(r, e) {
        let i = this.getInterceptorIndex(r);
        return this._fns[i] ? (this._fns[i] = e, r) : false;
    }
    use(r) {
        return this._fns = [
            ...this._fns,
            r
        ], this._fns.length - 1;
    }
}, v = ()=>({
        error: new h,
        request: new h,
        response: new h
    }), N = A({
    allowReserved: false,
    array: {
        explode: true,
        style: "form"
    },
    object: {
        explode: true,
        style: "deepObject"
    }
}), Q = {
    "Content-Type": "application/json"
}, w = (t = {})=>({
        ...R,
        headers: Q,
        parseAs: "auto",
        querySerializer: N,
        ...t
    });
var J = (t = {})=>{
    let r = x(w(), t), e = ()=>({
            ...r
        }), i = (s)=>(r = x(r, s), e()), a = v(), o = async (s)=>{
        let n = {
            ...r,
            ...s,
            fetch: s.fetch ?? r.fetch ?? globalThis.fetch,
            headers: C(r.headers, s.headers)
        };
        n.security && await E({
            ...n,
            security: n.security
        }), n.body && n.bodySerializer && (n.body = n.bodySerializer(n.body)), (n.body === void 0 || n.body === "") && n.headers.delete("Content-Type");
        let l = S(n), f = {
            redirect: "follow",
            ...n
        }, p = new Request(l, f);
        for (let c of a.request._fns)c && (p = await c(p, n));
        let T = n.fetch, u = await T(p);
        for (let c of a.response._fns)c && (u = await c(u, p, n));
        let m = {
            request: p,
            response: u
        };
        if (u.ok) {
            if (u.status === 204 || u.headers.get("Content-Length") === "0") return {
                data: {},
                ...m
            };
            let c = (n.parseAs === "auto" ? P(u.headers.get("Content-Type")) : n.parseAs) ?? "json";
            if (c === "stream") return {
                data: u.body,
                ...m
            };
            let b = await u[c]();
            return c === "json" && (n.responseValidator && await n.responseValidator(b), n.responseTransformer && (b = await n.responseTransformer(b))), {
                data: b,
                ...m
            };
        }
        let g = await u.text();
        try {
            g = JSON.parse(g);
        } catch  {}
        let d = g;
        for (let c of a.error._fns)c && (d = await c(g, u, p, n));
        if (d = d || {}, n.throwOnError) throw d;
        return {
            error: d,
            ...m
        };
    };
    return {
        buildUrl: S,
        connect: (s)=>o({
                ...s,
                method: "CONNECT"
            }),
        delete: (s)=>o({
                ...s,
                method: "DELETE"
            }),
        get: (s)=>o({
                ...s,
                method: "GET"
            }),
        getConfig: e,
        head: (s)=>o({
                ...s,
                method: "HEAD"
            }),
        interceptors: a,
        options: (s)=>o({
                ...s,
                method: "OPTIONS"
            }),
        patch: (s)=>o({
                ...s,
                method: "PATCH"
            }),
        post: (s)=>o({
                ...s,
                method: "POST"
            }),
        put: (s)=>o({
                ...s,
                method: "PUT"
            }),
        request: o,
        setConfig: i,
        trace: (s)=>o({
                ...s,
                method: "TRACE"
            })
    };
};

// This file is auto-generated by @hey-api/openapi-ts
const client = J(w());

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Schema for an API Key.
 */ const ApiKeyType = {
    USER: "user",
    AGENT: "agent"
};
const BoxAuthMechanism = {
    DEVELOPER_TOKEN: "developer_token",
    CCG: "ccg"
};
/**
 * Enum for the mode of composite retrieval.
 */ const CompositeRetrievalMode = {
    ROUTING: "routing",
    FULL: "full"
};
const ConfigurableDataSinkNames = {
    PINECONE: "PINECONE",
    POSTGRES: "POSTGRES",
    QDRANT: "QDRANT",
    AZUREAI_SEARCH: "AZUREAI_SEARCH",
    MONGODB_ATLAS: "MONGODB_ATLAS",
    MILVUS: "MILVUS",
    ASTRA_DB: "ASTRA_DB"
};
const ConfigurableDataSourceNames = {
    S3: "S3",
    AZURE_STORAGE_BLOB: "AZURE_STORAGE_BLOB",
    GOOGLE_DRIVE: "GOOGLE_DRIVE",
    MICROSOFT_ONEDRIVE: "MICROSOFT_ONEDRIVE",
    MICROSOFT_SHAREPOINT: "MICROSOFT_SHAREPOINT",
    SLACK: "SLACK",
    NOTION_PAGE: "NOTION_PAGE",
    CONFLUENCE: "CONFLUENCE",
    JIRA: "JIRA",
    JIRA_V2: "JIRA_V2",
    BOX: "BOX"
};
const DocumentChunkMode = {
    PAGE: "PAGE",
    SECTION: "SECTION"
};
const ExtractMode = {
    FAST: "FAST",
    BALANCED: "BALANCED",
    PREMIUM: "PREMIUM",
    MULTIMODAL: "MULTIMODAL"
};
const ExtractModels = {
    OPENAI_GPT_4_1: "openai-gpt-4-1",
    OPENAI_GPT_4_1_MINI: "openai-gpt-4-1-mini",
    OPENAI_GPT_4_1_NANO: "openai-gpt-4-1-nano",
    OPENAI_GPT_5: "openai-gpt-5",
    OPENAI_GPT_5_MINI: "openai-gpt-5-mini",
    GEMINI_2_0_FLASH: "gemini-2.0-flash",
    GEMINI_2_5_FLASH: "gemini-2.5-flash",
    GEMINI_2_5_FLASH_LITE: "gemini-2.5-flash-lite",
    GEMINI_2_5_PRO: "gemini-2.5-pro",
    OPENAI_GPT_4O: "openai-gpt-4o",
    OPENAI_GPT_4O_MINI: "openai-gpt-4o-mini"
};
const ExtractState = {
    CREATED: "CREATED",
    PENDING: "PENDING",
    SUCCESS: "SUCCESS",
    ERROR: "ERROR"
};
const ExtractTarget = {
    PER_DOC: "PER_DOC",
    PER_PAGE: "PER_PAGE"
};
/**
 * Enum for representing the different available page error handling modes
 */ const FailPageMode = {
    RAW_TEXT: "raw_text",
    BLANK_PAGE: "blank_page",
    ERROR_MESSAGE: "error_message"
};
/**
 * Vector store filter conditions to combine different filters.
 */ const FilterCondition = {
    AND: "and",
    OR: "or",
    NOT: "not"
};
/**
 * Vector store filter operator.
 */ const FilterOperator = {
    "==": "==",
    ">": ">",
    "<": "<",
    "!=": "!=",
    ">=": ">=",
    "<=": "<=",
    IN: "in",
    NIN: "nin",
    ANY: "any",
    ALL: "all",
    TEXT_MATCH: "text_match",
    TEXT_MATCH_INSENSITIVE: "text_match_insensitive",
    CONTAINS: "contains",
    IS_EMPTY: "is_empty"
};
/**
 * Enum for mapping original job names to readable names.
 */ const JobNameMapping = {
    MANAGED_INGESTION: "MANAGED_INGESTION",
    DATA_SOURCE: "DATA_SOURCE",
    FILES_UPDATE: "FILES_UPDATE",
    FILE_UPDATER: "FILE_UPDATER",
    PARSE: "PARSE",
    TRANSFORM: "TRANSFORM",
    INGESTION: "INGESTION",
    METADATA_UPDATE: "METADATA_UPDATE"
};
/**
 * Enum for executable pipeline job names.
 */ const JobNames = {
    LOAD_DOCUMENTS_JOB: "load_documents_job",
    LOAD_FILES_JOB: "load_files_job",
    PLAYGROUND_JOB: "playground_job",
    PIPELINE_MANAGED_INGESTION_JOB: "pipeline_managed_ingestion_job",
    DATA_SOURCE_UPDATE_DISPATCHER_JOB: "data_source_update_dispatcher_job",
    PIPELINE_FILE_UPDATE_DISPATCHER_JOB: "pipeline_file_update_dispatcher_job",
    PIPELINE_FILE_UPDATER_JOB: "pipeline_file_updater_job",
    FILE_MANAGED_INGESTION_JOB: "file_managed_ingestion_job",
    DOCUMENT_INGESTION_JOB: "document_ingestion_job",
    METADATA_UPDATE_JOB: "metadata_update_job",
    PARSE_RAW_FILE_JOB_CACHED: "parse_raw_file_job_cached",
    EXTRACTION_JOB: "extraction_job",
    EXTRACT_JOB: "extract_job",
    ASYNCIO_TEST_JOB: "asyncio_test_job",
    PARSE_RAW_FILE_JOB: "parse_raw_file_job",
    LLAMA_PARSE_TRANSFORM_JOB: "llama_parse_transform_job"
};
const LlamaParseSupportedFileExtensions = {
    ".PDF": ".pdf",
    ".DOC": ".doc",
    ".DOCX": ".docx",
    ".DOCM": ".docm",
    ".DOT": ".dot",
    ".DOTX": ".dotx",
    ".DOTM": ".dotm",
    ".RTF": ".rtf",
    ".WPS": ".wps",
    ".WPD": ".wpd",
    ".SXW": ".sxw",
    ".STW": ".stw",
    ".SXG": ".sxg",
    ".PAGES": ".pages",
    ".MW": ".mw",
    ".MCW": ".mcw",
    ".UOT": ".uot",
    ".UOF": ".uof",
    ".UOS": ".uos",
    ".UOP": ".uop",
    ".PPT": ".ppt",
    ".PPTX": ".pptx",
    ".POT": ".pot",
    ".PPTM": ".pptm",
    ".POTX": ".potx",
    ".POTM": ".potm",
    ".KEY": ".key",
    ".ODP": ".odp",
    ".ODG": ".odg",
    ".OTP": ".otp",
    ".FOPD": ".fopd",
    ".SXI": ".sxi",
    ".STI": ".sti",
    ".EPUB": ".epub",
    ".JPG": ".jpg",
    ".JPEG": ".jpeg",
    ".PNG": ".png",
    ".GIF": ".gif",
    ".BMP": ".bmp",
    ".SVG": ".svg",
    ".TIFF": ".tiff",
    ".WEBP": ".webp",
    ".HTML": ".html",
    ".HTM": ".htm",
    ".XLS": ".xls",
    ".XLSX": ".xlsx",
    ".XLSM": ".xlsm",
    ".XLSB": ".xlsb",
    ".XLW": ".xlw",
    ".CSV": ".csv",
    ".DIF": ".dif",
    ".SYLK": ".sylk",
    ".SLK": ".slk",
    ".PRN": ".prn",
    ".NUMBERS": ".numbers",
    ".ET": ".et",
    ".ODS": ".ods",
    ".FODS": ".fods",
    ".UOS1": ".uos1",
    ".UOS2": ".uos2",
    ".DBF": ".dbf",
    ".WK1": ".wk1",
    ".WK2": ".wk2",
    ".WK3": ".wk3",
    ".WK4": ".wk4",
    ".WKS": ".wks",
    ".WQ1": ".wq1",
    ".WQ2": ".wq2",
    ".WB1": ".wb1",
    ".WB2": ".wb2",
    ".WB3": ".wb3",
    ".QPW": ".qpw",
    ".XLR": ".xlr",
    ".ETH": ".eth",
    ".TSV": ".tsv"
};
/**
 * Status of managed ingestion with partial Updates.
 */ const ManagedIngestionStatus = {
    NOT_STARTED: "NOT_STARTED",
    IN_PROGRESS: "IN_PROGRESS",
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    PARTIAL_SUCCESS: "PARTIAL_SUCCESS",
    CANCELLED: "CANCELLED"
};
/**
 * Message role.
 */ const MessageRole = {
    SYSTEM: "system",
    DEVELOPER: "developer",
    USER: "user",
    ASSISTANT: "assistant",
    FUNCTION: "function",
    TOOL: "tool",
    CHATBOT: "chatbot",
    MODEL: "model"
};
const MetronomeDashboardType = {
    INVOICES: "invoices",
    USAGE: "usage"
};
/**
 * Node relationships used in `BaseNode` class.
 *
 * Attributes:
 * SOURCE: The node is the source document.
 * PREVIOUS: The node is the previous node in the document.
 * NEXT: The node is the next node in the document.
 * PARENT: The node is the parent node in the document.
 * CHILD: The node is a child node in the document.
 */ const NodeRelationship = {
    1: "1",
    2: "2",
    3: "3",
    4: "4",
    5: "5"
};
const ObjectType = {
    1: "1",
    2: "2",
    3: "3",
    4: "4",
    5: "5"
};
/**
 * Distance methods for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */ const PgVectorDistanceMethod = {
    L2: "l2",
    IP: "ip",
    COSINE: "cosine",
    L1: "l1",
    HAMMING: "hamming",
    JACCARD: "jaccard"
};
/**
 * Vector storage formats for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */ const PgVectorVectorType = {
    VECTOR: "vector",
    HALF_VEC: "half_vec",
    BIT: "bit",
    SPARSE_VEC: "sparse_vec"
};
/**
 * Enum for the Parse plan level.
 */ const ParsePlanLevel = {
    DEFAULT: "DEFAULT",
    PREMIUM: "PREMIUM"
};
/**
 * Enum for representing the languages supported by the parser
 */ const ParserLanguages = {
    AF: "af",
    AZ: "az",
    BS: "bs",
    CS: "cs",
    CY: "cy",
    DA: "da",
    DE: "de",
    EN: "en",
    ES: "es",
    ET: "et",
    FR: "fr",
    GA: "ga",
    HR: "hr",
    HU: "hu",
    ID: "id",
    IS: "is",
    IT: "it",
    KU: "ku",
    LA: "la",
    LT: "lt",
    LV: "lv",
    MI: "mi",
    MS: "ms",
    MT: "mt",
    NL: "nl",
    NO: "no",
    OC: "oc",
    PI: "pi",
    PL: "pl",
    PT: "pt",
    RO: "ro",
    RS_LATIN: "rs_latin",
    SK: "sk",
    SL: "sl",
    SQ: "sq",
    SV: "sv",
    SW: "sw",
    TL: "tl",
    TR: "tr",
    UZ: "uz",
    VI: "vi",
    AR: "ar",
    FA: "fa",
    UG: "ug",
    UR: "ur",
    BN: "bn",
    AS: "as",
    MNI: "mni",
    RU: "ru",
    RS_CYRILLIC: "rs_cyrillic",
    BE: "be",
    BG: "bg",
    UK: "uk",
    MN: "mn",
    ABQ: "abq",
    ADY: "ady",
    KBD: "kbd",
    AVA: "ava",
    DAR: "dar",
    INH: "inh",
    CHE: "che",
    LBE: "lbe",
    LEZ: "lez",
    TAB: "tab",
    TJK: "tjk",
    HI: "hi",
    MR: "mr",
    NE: "ne",
    BH: "bh",
    MAI: "mai",
    ANG: "ang",
    BHO: "bho",
    MAH: "mah",
    SCK: "sck",
    NEW: "new",
    GOM: "gom",
    SA: "sa",
    BGC: "bgc",
    TH: "th",
    CH_SIM: "ch_sim",
    CH_TRA: "ch_tra",
    JA: "ja",
    KO: "ko",
    TA: "ta",
    TE: "te",
    KN: "kn"
};
/**
 * Enum for representing the mode of parsing to be used
 */ const ParsingMode = {
    PARSE_PAGE_WITHOUT_LLM: "parse_page_without_llm",
    PARSE_PAGE_WITH_LLM: "parse_page_with_llm",
    PARSE_PAGE_WITH_LVM: "parse_page_with_lvm",
    PARSE_PAGE_WITH_AGENT: "parse_page_with_agent",
    PARSE_PAGE_WITH_LAYOUT_AGENT: "parse_page_with_layout_agent",
    PARSE_DOCUMENT_WITH_LLM: "parse_document_with_llm",
    PARSE_DOCUMENT_WITH_LVM: "parse_document_with_lvm",
    PARSE_DOCUMENT_WITH_AGENT: "parse_document_with_agent"
};
/**
 * Enum for dataset partition names.
 */ const PartitionNames = {
    DATA_SOURCE_ID_PARTITION: "data_source_id_partition",
    PIPELINE_ID_PARTITION: "pipeline_id_partition",
    EVAL_DATASET_ID_PARTITION: "eval_dataset_id_partition",
    FILE_ID_PARTITION: "file_id_partition",
    PIPELINE_FILE_ID_PARTITION: "pipeline_file_id_partition",
    FILE_PARSING_ID_PARTITION: "file_parsing_id_partition",
    EXTRACTION_SCHEMA_ID_PARTITION: "extraction_schema_id_partition"
};
/**
 * Enum for representing the type of a pipeline
 */ const PipelineType = {
    PLAYGROUND: "PLAYGROUND",
    MANAGED: "MANAGED"
};
/**
 * Enum of possible pooling choices with pooling behaviors.
 */ const Pooling = {
    CLS: "cls",
    MEAN: "mean",
    LAST: "last"
};
const PublicModelName = {
    OPENAI_GPT_4O: "openai-gpt-4o",
    OPENAI_GPT_4O_MINI: "openai-gpt-4o-mini",
    OPENAI_GPT_4_1: "openai-gpt-4-1",
    OPENAI_GPT_4_1_MINI: "openai-gpt-4-1-mini",
    OPENAI_GPT_4_1_NANO: "openai-gpt-4-1-nano",
    OPENAI_GPT_5: "openai-gpt-5",
    OPENAI_GPT_5_MINI: "openai-gpt-5-mini",
    OPENAI_GPT_5_NANO: "openai-gpt-5-nano",
    OPENAI_TEXT_EMBEDDING_3_SMALL: "openai-text-embedding-3-small",
    OPENAI_TEXT_EMBEDDING_3_LARGE: "openai-text-embedding-3-large",
    OPENAI_WHISPER_1: "openai-whisper-1",
    ANTHROPIC_SONNET_3_5: "anthropic-sonnet-3.5",
    ANTHROPIC_SONNET_3_5_V2: "anthropic-sonnet-3.5-v2",
    ANTHROPIC_SONNET_3_7: "anthropic-sonnet-3.7",
    ANTHROPIC_SONNET_4_0: "anthropic-sonnet-4.0",
    GEMINI_2_5_FLASH: "gemini-2.5-flash",
    GEMINI_2_5_PRO: "gemini-2.5-pro",
    GEMINI_2_0_FLASH: "gemini-2.0-flash",
    GEMINI_2_0_FLASH_LITE: "gemini-2.0-flash-lite",
    GEMINI_2_5_FLASH_LITE: "gemini-2.5-flash-lite",
    GEMINI_1_5_FLASH: "gemini-1.5-flash",
    GEMINI_1_5_PRO: "gemini-1.5-pro"
};
/**
 * Enum for the reranker type.
 */ const ReRankerType = {
    SYSTEM_DEFAULT: "system_default",
    LLM: "llm",
    COHERE: "cohere",
    BEDROCK: "bedrock",
    SCORE: "score",
    DISABLED: "disabled"
};
const RetrievalMode = {
    CHUNKS: "chunks",
    FILES_VIA_METADATA: "files_via_metadata",
    FILES_VIA_CONTENT: "files_via_content",
    AUTO_ROUTED: "auto_routed"
};
/**
 * Enum for sparse model types supported in LlamaCloud.
 *
 * SPLADE: Uses HuggingFace Splade model for sparse embeddings
 * BM25: Uses Qdrant's FastEmbed BM25 model for sparse embeddings
 * AUTO: Automatically selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade)
 */ const SparseModelType = {
    SPLADE: "splade",
    BM25: "bm25",
    AUTO: "auto"
};
/**
 * Enum for representing the status of a job
 */ const StatusEnum = {
    PENDING: "PENDING",
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    PARTIAL_SUCCESS: "PARTIAL_SUCCESS",
    CANCELLED: "CANCELLED"
};
const SupportedLlmModelNames = {
    GPT_4O: "GPT_4O",
    GPT_4O_MINI: "GPT_4O_MINI",
    GPT_4_1: "GPT_4_1",
    GPT_4_1_NANO: "GPT_4_1_NANO",
    GPT_4_1_MINI: "GPT_4_1_MINI",
    AZURE_OPENAI_GPT_4O: "AZURE_OPENAI_GPT_4O",
    AZURE_OPENAI_GPT_4O_MINI: "AZURE_OPENAI_GPT_4O_MINI",
    AZURE_OPENAI_GPT_4_1: "AZURE_OPENAI_GPT_4_1",
    AZURE_OPENAI_GPT_4_1_MINI: "AZURE_OPENAI_GPT_4_1_MINI",
    AZURE_OPENAI_GPT_4_1_NANO: "AZURE_OPENAI_GPT_4_1_NANO",
    CLAUDE_3_5_SONNET: "CLAUDE_3_5_SONNET",
    BEDROCK_CLAUDE_3_5_SONNET_V1: "BEDROCK_CLAUDE_3_5_SONNET_V1",
    BEDROCK_CLAUDE_3_5_SONNET_V2: "BEDROCK_CLAUDE_3_5_SONNET_V2",
    VERTEX_AI_CLAUDE_3_5_SONNET_V2: "VERTEX_AI_CLAUDE_3_5_SONNET_V2"
};
/**
 * Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
 * since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.
 */ const VertexEmbeddingMode = {
    DEFAULT: "default",
    CLASSIFICATION: "classification",
    CLUSTERING: "clustering",
    SIMILARITY: "similarity",
    RETRIEVAL: "retrieval"
};

// This file is auto-generated by @hey-api/openapi-ts
/**
 * List Deployments
 * List all deployments for a project.
 */ const listDeploymentsApiV1ProjectsProjectIdAgentsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects/{project_id}/agents",
        ...options
    });
};
/**
 * Sync Deployments
 * Sync deployments for a project.
 */ const syncDeploymentsApiV1ProjectsProjectIdAgentsSyncPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects/{project_id}/agents:sync",
        ...options
    });
};
/**
 * List Keys
 * List API Keys for a user, filtered by type.
 */ const listKeysApiV1ApiKeysGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/api-keys",
        ...options
    });
};
/**
 * Generate Key
 * Generate a new API Key.
 */ const generateKeyApiV1ApiKeysPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/api-keys",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Api Key
 * Delete an API Key by ID.
 */ const deleteApiKeyApiV1ApiKeysApiKeyIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/api-keys/{api_key_id}",
        ...options
    });
};
/**
 * Validate Embedding Connection
 * Validate an embedding connection.
 *
 * Args:
 * embedding_config: The embedding configuration to validate.
 * pipeline_id: If provided, the embedding connection will be validated for the pipeline.
 * user: The user to validate the embedding connection for.
 * db: The database session.
 *
 * Returns:
 * A BaseConnectionValidation object indicating the result of the validation.
 */ const validateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/validate-integrations/validate-embedding-connection",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Validate Data Source Connection
 * Validate a data source connection.
 */ const validateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/validate-integrations/validate-data-source-connection",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Validate Data Sink Connection
 * Validate a data sink connection.
 */ const validateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/validate-integrations/validate-data-sink-connection",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Data Sinks
 * List data sinks for a given project.
 */ const listDataSinksApiV1DataSinksGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sinks",
        ...options
    });
};
/**
 * Create Data Sink
 * Create a new data sink.
 */ const createDataSinkApiV1DataSinksPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sinks",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Data Sink
 * Upserts a data sink.
 * Updates if a data sink with the same name and project_id already exists. Otherwise, creates a new data sink.
 */ const upsertDataSinkApiV1DataSinksPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sinks",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Data Sink
 * Delete a data sink by ID.
 */ const deleteDataSinkApiV1DataSinksDataSinkIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sinks/{data_sink_id}",
        ...options
    });
};
/**
 * Get Data Sink
 * Get a data sink by ID.
 */ const getDataSinkApiV1DataSinksDataSinkIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sinks/{data_sink_id}",
        ...options
    });
};
/**
 * Update Data Sink
 * Update a data sink by ID.
 */ const updateDataSinkApiV1DataSinksDataSinkIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sinks/{data_sink_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Data Sources
 * List data sources for a given project.
 * If project_id is not provided, uses the default project.
 */ const listDataSourcesApiV1DataSourcesGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sources",
        ...options
    });
};
/**
 * Create Data Source
 * Create a new data source.
 */ const createDataSourceApiV1DataSourcesPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sources",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Data Source
 * Upserts a data source.
 * Updates if a data source with the same name and project_id already exists. Otherwise, creates a new data source.
 */ const upsertDataSourceApiV1DataSourcesPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sources",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Data Source
 * Delete a data source by ID.
 */ const deleteDataSourceApiV1DataSourcesDataSourceIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sources/{data_source_id}",
        ...options
    });
};
/**
 * Get Data Source
 * Get a data source by ID.
 */ const getDataSourceApiV1DataSourcesDataSourceIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sources/{data_source_id}",
        ...options
    });
};
/**
 * Update Data Source
 * Update a data source by ID.
 */ const updateDataSourceApiV1DataSourcesDataSourceIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/data-sources/{data_source_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Embedding Model Configs
 */ const listEmbeddingModelConfigsApiV1EmbeddingModelConfigsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/embedding-model-configs",
        ...options
    });
};
/**
 * Create a new Embedding Model Configuration
 * Create a new embedding model configuration within a specified project.
 */ const createEmbeddingModelConfigApiV1EmbeddingModelConfigsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/embedding-model-configs",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Embedding Model Config
 * Upserts an embedding model config.
 * Updates if an embedding model config with the same name and project_id already exists. Otherwise, creates a new embedding model config.
 */ const upsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/embedding-model-configs",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Embedding Model Config
 * Delete an embedding model config by ID.
 */ const deleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/embedding-model-configs/{embedding_model_config_id}",
        ...options
    });
};
/**
 * Update Embedding Model Config
 * Update an embedding model config by ID.
 */ const updateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/embedding-model-configs/{embedding_model_config_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Organizations
 * List organizations for a user.
 */ const listOrganizationsApiV1OrganizationsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations",
        ...options
    });
};
/**
 * Create Organization
 * Create a new organization.
 */ const createOrganizationApiV1OrganizationsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Organization
 * Upsert a new organization.
 */ const upsertOrganizationApiV1OrganizationsPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Default Organization
 * Get the default organization for the user.
 */ const getDefaultOrganizationApiV1OrganizationsDefaultGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/default",
        ...options
    });
};
/**
 * Set Default Organization
 * Set the default organization for the user.
 */ const setDefaultOrganizationApiV1OrganizationsDefaultPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/default",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Organization
 * Delete an organization by ID.
 */ const deleteOrganizationApiV1OrganizationsOrganizationIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}",
        ...options
    });
};
/**
 * Get Organization
 * Get an organization by ID.
 */ const getOrganizationApiV1OrganizationsOrganizationIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}",
        ...options
    });
};
/**
 * Update Organization
 * Update an existing organization.
 */ const updateOrganizationApiV1OrganizationsOrganizationIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Organization Usage
 * Get usage for a specific organization.
 */ const getOrganizationUsageApiV1OrganizationsOrganizationIdUsageGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/usage",
        ...options
    });
};
/**
 * List Organization Users
 * Get all users in an organization.
 */ const listOrganizationUsersApiV1OrganizationsOrganizationIdUsersGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users",
        ...options
    });
};
/**
 * Add Users To Organization
 * Add a user to an organization.
 */ const addUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Remove Users From Organization
 * Remove users from an organization.
 */ const removeUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users/{member_user_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * @deprecated
 * Batch Remove Users From Organization
 * Remove a batch of users from an organization.
 */ const batchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users/remove",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Roles
 * List all roles in an organization.
 */ const listRolesApiV1OrganizationsOrganizationIdRolesGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/roles",
        ...options
    });
};
/**
 * Get User Role
 * Get the role of a user in an organization.
 */ const getUserRoleApiV1OrganizationsOrganizationIdUsersRolesGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users/roles",
        ...options
    });
};
/**
 * Assign Role To User In Organization
 * Assign a role to a user in an organization.
 */ const assignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users/roles",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Projects By User
 * List all projects for a user in an organization.
 */ const listProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects",
        ...options
    });
};
/**
 * Add User To Project
 * Add a user to a project.
 */ const addUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects",
        ...options
    });
};
/**
 * Remove User From Project
 * Remove a user from a project.
 */ const removeUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects/{project_id}",
        ...options
    });
};
/**
 * List Projects
 * List projects or get one by name
 */ const listProjectsApiV1ProjectsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects",
        ...options
    });
};
/**
 * Create Project
 * Create a new project.
 */ const createProjectApiV1ProjectsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Project
 * Upsert a project.
 * Updates if a project with the same name already exists. Otherwise, creates a new project.
 */ const upsertProjectApiV1ProjectsPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Project
 * Delete a project by ID.
 */ const deleteProjectApiV1ProjectsProjectIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects/{project_id}",
        ...options
    });
};
/**
 * Get Project
 * Get a project by ID.
 */ const getProjectApiV1ProjectsProjectIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects/{project_id}",
        ...options
    });
};
/**
 * Update Existing Project
 * Update an existing project.
 */ const updateExistingProjectApiV1ProjectsProjectIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects/{project_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Current Project
 * Get the current project.
 */ const getCurrentProjectApiV1ProjectsCurrentGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects/current",
        ...options
    });
};
/**
 * Get Project Usage
 * Get usage for a project
 */ const getProjectUsageApiV1ProjectsProjectIdUsageGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/projects/{project_id}/usage",
        ...options
    });
};
/**
 * Delete File
 * Delete the file from S3.
 */ const deleteFileApiV1FilesIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}",
        ...options
    });
};
/**
 * Get File
 * Read File metadata objects.
 */ const getFileApiV1FilesIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}",
        ...options
    });
};
/**
 * List Files
 * Read File metadata objects.
 */ const listFilesApiV1FilesGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files",
        ...options
    });
};
/**
 * Upload File
 * Upload a file to S3.
 */ const uploadFileApiV1FilesPost = (options)=>{
    return (options.client ?? client).post({
        ...k,
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files",
        ...options,
        headers: {
            "Content-Type": null,
            ...options?.headers
        }
    });
};
/**
 * Generate Presigned Url
 * Create a presigned url for uploading a file.
 *
 * The presigned url is valid for a limited time period, after which it will expire.
 * Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.
 */ const generatePresignedUrlApiV1FilesPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Sync Files
 * Sync Files API against file contents uploaded via S3 presigned urls.
 */ const syncFilesApiV1FilesSyncPut = (options)=>{
    return (options?.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/sync",
        ...options
    });
};
/**
 * Upload File From Url
 * Upload a file to the project from a URL.
 *
 * If name is ommitted in the request payload, the file name will be
 * extracted from the response Content-Disposition header if available
 * or otherwise it will be derived from the URL path.
 *
 * If providing the name in the request payload, always suffix the
 * file extension in the name if available.
 */ const uploadFileFromUrlApiV1FilesUploadFromUrlPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/upload_from_url",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Read File Content
 * Returns a presigned url to read the file content.
 */ const readFileContentApiV1FilesIdContentGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}/content",
        ...options
    });
};
/**
 * List File Page Screenshots
 * List metadata for all screenshots of pages from a file.
 */ const listFilePageScreenshotsApiV1FilesIdPageScreenshotsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}/page_screenshots",
        ...options
    });
};
/**
 * Get File Page Screenshot
 * Get screenshot of a page from a file.
 */ const getFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}/page_screenshots/{page_index}",
        ...options
    });
};
/**
 * List File Pages Figures
 */ const listFilePagesFiguresApiV1FilesIdPageFiguresGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}/page-figures",
        ...options
    });
};
/**
 * List File Page Figures
 */ const listFilePageFiguresApiV1FilesIdPageFiguresPageIndexGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}/page-figures/{page_index}",
        ...options
    });
};
/**
 * Get File Page Figure
 */ const getFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}/page-figures/{page_index}/{figure_name}",
        ...options
    });
};
/**
 * Generate File Page Screenshot Presigned Url
 * Returns a presigned url to read a page screenshot.
 *
 * The presigned url is valid for a limited time period, after which it will expire.
 * Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.
 */ const generateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}/page_screenshots/{page_index}/presigned_url",
        ...options
    });
};
/**
 * Generate File Page Figure Presigned Url
 * Returns a presigned url to read a page figure.
 *
 * The presigned url is valid for a limited time period, after which it will expire.
 * Be careful on accidental exposure of the presigned url, as it may allow unauthorized access to the file before the expiration.
 */ const generateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/files/{id}/page-figures/{page_index}/{figure_name}/presigned_url",
        ...options
    });
};
/**
 * Search Pipelines
 * Search for pipelines by various parameters.
 */ const searchPipelinesApiV1PipelinesGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines",
        ...options
    });
};
/**
 * Create Pipeline
 * Create a new pipeline for a project.
 */ const createPipelineApiV1PipelinesPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Pipeline
 * Upsert a pipeline for a project.
 * Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.
 */ const upsertPipelineApiV1PipelinesPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Pipeline
 * Delete a pipeline by ID.
 */ const deletePipelineApiV1PipelinesPipelineIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}",
        ...options
    });
};
/**
 * Get Pipeline
 * Get a pipeline by ID for a given project.
 */ const getPipelineApiV1PipelinesPipelineIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}",
        ...options
    });
};
/**
 * Update Existing Pipeline
 * Update an existing pipeline for a project.
 */ const updateExistingPipelineApiV1PipelinesPipelineIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Pipeline Status
 * Get the status of a pipeline by ID.
 */ const getPipelineStatusApiV1PipelinesPipelineIdStatusGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/status",
        ...options
    });
};
/**
 * Sync Pipeline
 * Run ingestion for the pipeline by incrementally updating the data-sink with upstream changes from data-sources & files.
 */ const syncPipelineApiV1PipelinesPipelineIdSyncPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/sync",
        ...options
    });
};
/**
 * Cancel Pipeline Sync
 */ const cancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/sync/cancel",
        ...options
    });
};
/**
 * Force Delete Pipeline
 */ const forceDeletePipelineApiV1PipelinesPipelineIdForceDeletePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/force-delete",
        ...options
    });
};
/**
 * Copy Pipeline
 * Copy a pipeline by ID.
 */ const copyPipelineApiV1PipelinesPipelineIdCopyPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/copy",
        ...options
    });
};
/**
 * @deprecated
 * List Pipeline Files
 * Get files for a pipeline.
 */ const listPipelineFilesApiV1PipelinesPipelineIdFilesGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/files",
        ...options
    });
};
/**
 * Add Files To Pipeline Api
 * Add files to a pipeline.
 */ const addFilesToPipelineApiApiV1PipelinesPipelineIdFilesPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/files",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * @deprecated
 * List Pipeline Files2
 * Get files for a pipeline.
 *
 * Args:
 * pipeline_id: ID of the pipeline
 * data_source_id: Optional filter by data source ID
 * only_manually_uploaded: Filter for only manually uploaded files
 * file_name_contains: Optional filter by file name (substring match)
 * limit: Limit number of results
 * offset: Offset for pagination
 * order_by: Field to order by
 */ const listPipelineFiles2ApiV1PipelinesPipelineIdFiles2Get = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/files2",
        ...options
    });
};
/**
 * Get Pipeline File Status Counts
 * Get files for a pipeline.
 */ const getPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/files/status-counts",
        ...options
    });
};
/**
 * Get Pipeline File Status
 * Get status of a file for a pipeline.
 */ const getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}/status",
        ...options
    });
};
/**
 * Delete Pipeline File
 * Delete a file from a pipeline.
 */ const deletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}",
        ...options
    });
};
/**
 * Update Pipeline File
 * Update a file for a pipeline.
 */ const updatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Pipeline Files Metadata
 * Delete metadata for all files in a pipeline.
 */ const deletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/metadata",
        ...options
    });
};
/**
 * Import Pipeline Metadata
 * Import metadata for a pipeline.
 */ const importPipelineMetadataApiV1PipelinesPipelineIdMetadataPut = (options)=>{
    return (options.client ?? client).put({
        ...k,
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/metadata",
        ...options,
        headers: {
            "Content-Type": null,
            ...options?.headers
        }
    });
};
/**
 * List Pipeline Data Sources
 * Get data sources for a pipeline.
 */ const listPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/data-sources",
        ...options
    });
};
/**
 * Add Data Sources To Pipeline
 * Add data sources to a pipeline.
 */ const addDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/data-sources",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Pipeline Data Source
 * Delete a data source from a pipeline.
 */ const deletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}",
        ...options
    });
};
/**
 * Update Pipeline Data Source
 * Update the configuration of a data source in a pipeline.
 */ const updatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Sync Pipeline Data Source
 * Run ingestion for the pipeline data source by incrementally updating the data-sink with upstream changes from data-source.
 */ const syncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/sync",
        ...options
    });
};
/**
 * Get Pipeline Data Source Status
 * Get the status of a data source for a pipeline.
 */ const getPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/status",
        ...options
    });
};
/**
 * Run Search
 * Get retrieval results for a managed pipeline and a query
 */ const runSearchApiV1PipelinesPipelineIdRetrievePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/retrieve",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Pipeline Jobs
 * Get jobs for a pipeline.
 */ const listPipelineJobsApiV1PipelinesPipelineIdJobsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/jobs",
        ...options
    });
};
/**
 * Get Pipeline Job
 * Get a job for a pipeline.
 */ const getPipelineJobApiV1PipelinesPipelineIdJobsJobIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/jobs/{job_id}",
        ...options
    });
};
/**
 * Get Playground Session
 * Get a playground session for a user and pipeline.
 */ const getPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/playground-session",
        ...options
    });
};
/**
 * Chat
 * Make a retrieval query + chat completion for a managed pipeline.
 */ const chatApiV1PipelinesPipelineIdChatPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/chat",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Pipeline Documents
 * Return a list of documents for a pipeline.
 */ const listPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents",
        ...options
    });
};
/**
 * Create Batch Pipeline Documents
 * Batch create documents for a pipeline.
 */ const createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Batch Pipeline Documents
 * Batch create or update a document for a pipeline.
 */ const upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Paginated List Pipeline Documents
 * Return a list of documents for a pipeline.
 */ const paginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents/paginated",
        ...options
    });
};
/**
 * Delete Pipeline Document
 * Delete a document from a pipeline.
 * Initiates an async job that will:
 * 1. Delete vectors from the vector store
 * 2. Delete the document from MongoDB after vectors are successfully deleted
 */ const deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}",
        ...options
    });
};
/**
 * Get Pipeline Document
 * Return a single document for a pipeline.
 */ const getPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}",
        ...options
    });
};
/**
 * Get Pipeline Document Status
 * Return a single document for a pipeline.
 */ const getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/status",
        ...options
    });
};
/**
 * Sync Pipeline Document
 * Sync a specific document for a pipeline.
 */ const syncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/sync",
        ...options
    });
};
/**
 * List Pipeline Document Chunks
 * Return a list of chunks for a pipeline document.
 */ const listPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/chunks",
        ...options
    });
};
/**
 * Force Sync All Pipeline Documents
 * Force sync all documents in a pipeline by batching document ingestion jobs.
 *
 * - Iterates all document refs for the pipeline
 * - Enqueues document ingestion jobs in batches of `batch_size`
 */ const forceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/pipelines/{pipeline_id}/documents/force-sync-all",
        ...options
    });
};
/**
 * List Retrievers
 * List Retrievers for a project.
 */ const listRetrieversApiV1RetrieversGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/retrievers",
        ...options
    });
};
/**
 * Create Retriever
 * Create a new Retriever.
 */ const createRetrieverApiV1RetrieversPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/retrievers",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Retriever
 * Upsert a new Retriever.
 */ const upsertRetrieverApiV1RetrieversPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/retrievers",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Retriever
 * Delete a Retriever by ID.
 */ const deleteRetrieverApiV1RetrieversRetrieverIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/retrievers/{retriever_id}",
        ...options
    });
};
/**
 * Get Retriever
 * Get a Retriever by ID.
 */ const getRetrieverApiV1RetrieversRetrieverIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/retrievers/{retriever_id}",
        ...options
    });
};
/**
 * Update Retriever
 * Update an existing Retriever.
 */ const updateRetrieverApiV1RetrieversRetrieverIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/retrievers/{retriever_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Retrieve
 * Retrieve data using a Retriever.
 */ const retrieveApiV1RetrieversRetrieverIdRetrievePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/retrievers/{retriever_id}/retrieve",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Direct Retrieve
 * Retrieve data using specified pipelines without creating a persistent retriever.
 */ const directRetrieveApiV1RetrieversRetrievePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/retrievers/retrieve",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Jobs
 * Get jobs for a project.
 *
 * Note:
 * The include_usage_metrics parameter is deprecated and will be removed in a future version.
 * We've moved to usage v2 and this parameter will no longer return meaningful data.
 */ const getJobsApiV1JobsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/jobs",
        ...options
    });
};
/**
 * List Supported Models
 * List supported models.
 */ const listSupportedModelsApiV1EvalsModelsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/evals/models",
        ...options
    });
};
/**
 * Get Job Image Result
 * Get a job by id
 */ const getJobImageResultApiV1ParsingJobJobIdResultImageNameGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/image/{name}",
        ...options
    });
};
/**
 * Get Supported File Extensions
 * Get a list of supported file extensions
 */ const getSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGet = (options)=>{
    return (options?.client ?? client).get({
        url: "/api/v1/parsing/supported_file_extensions",
        ...options
    });
};
/**
 * Screenshot
 */ const screenshotApiV1ParsingScreenshotPost = (options)=>{
    return (options?.client ?? client).post({
        ...k,
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/screenshot",
        ...options,
        headers: {
            "Content-Type": null,
            ...options?.headers
        }
    });
};
/**
 * Upload File
 */ const uploadFileApiV1ParsingUploadPost = (options)=>{
    return (options?.client ?? client).post({
        ...k,
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/upload",
        ...options,
        headers: {
            "Content-Type": null,
            ...options?.headers
        }
    });
};
/**
 * Get Job
 * Get a job by id
 */ const getJobApiV1ParsingJobJobIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}",
        ...options
    });
};
/**
 * Get Job Parameters
 * Get a job by id
 */ const getJobParametersApiV1ParsingJobJobIdParametersGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/parameters",
        ...options
    });
};
/**
 * Get Parsing Job Details
 * Get a job by id
 */ const getParsingJobDetailsApiV1ParsingJobJobIdDetailsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/details",
        ...options
    });
};
/**
 * Get Job Text Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobTextResultApiV1ParsingJobJobIdResultTextGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/text",
        ...options
    });
};
/**
 * Get Job Raw Text Result Raw
 * Get a job by id
 */ const getJobRawTextResultRawApiV1ParsingJobJobIdResultRawTextGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/raw/text",
        ...options
    });
};
/**
 * Get Job Raw Text Result
 * Get a job by id
 */ const getJobRawTextResultApiV1ParsingJobJobIdResultPdfGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/pdf",
        ...options
    });
};
/**
 * Get Job Raw Text Result Raw Pdf
 * Get a job by id
 */ const getJobRawTextResultRawPdfApiV1ParsingJobJobIdResultRawPdfGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/raw/pdf",
        ...options
    });
};
/**
 * Get Job Structured Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobStructuredResultApiV1ParsingJobJobIdResultStructuredGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/structured",
        ...options
    });
};
/**
 * Get Job Raw Structured Result
 * Get a job by id
 */ const getJobRawStructuredResultApiV1ParsingJobJobIdResultRawStructuredGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/raw/structured",
        ...options
    });
};
/**
 * Get Job Raw Xlsx Result
 * Get a job by id
 */ const getJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/xlsx",
        ...options
    });
};
/**
 * Get Job Raw Xlsx Result Raw
 * Get a job by id
 */ const getJobRawXlsxResultRawApiV1ParsingJobJobIdResultRawXlsxGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/raw/xlsx",
        ...options
    });
};
/**
 * Get Job Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobResultApiV1ParsingJobJobIdResultMarkdownGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/markdown",
        ...options
    });
};
/**
 * Get Job Raw Md Result
 * Get a job by id
 */ const getJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/raw/markdown",
        ...options
    });
};
/**
 * Get Job Json Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobJsonResultApiV1ParsingJobJobIdResultJsonGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/json",
        ...options
    });
};
/**
 * Get Job Json Raw Result
 * Get a job by id
 */ const getJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/raw/json",
        ...options
    });
};
/**
 * @deprecated
 * Get Parsing History Result
 * Get parsing history for user
 *
 * This endpoint is deprecated.
 * Use /api/v1/jobs/?job_name=parsing&project_id=YOUR_PROJECT_ID instead.
 */ const getParsingHistoryResultApiV1ParsingHistoryGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/history",
        ...options
    });
};
/**
 * Generate Presigned Url
 * Generate a presigned URL for a job
 */ const generatePresignedUrlApiV1ParsingJobJobIdReadFilenameGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/read/{filename}",
        ...options
    });
};
/**
 * Get Chat Apps
 */ const getChatAppsApiV1AppsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/apps/",
        ...options
    });
};
/**
 * Create Chat App
 * Create a new chat app.
 */ const createChatAppApiV1AppsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/apps/",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Chat App
 */ const deleteChatAppApiV1AppsIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/apps/{id}",
        ...options
    });
};
/**
 * Get Chat App
 * Get a chat app by ID.
 */ const getChatAppApiV1AppsIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/apps/{id}",
        ...options
    });
};
/**
 * Update Chat App
 * Update a chat app.
 */ const updateChatAppApiV1AppsIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/apps/{id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Chat With Chat App
 * Chat with a chat app.
 */ const chatWithChatAppApiV1AppsIdChatPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/apps/{id}/chat",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Classify Jobs
 * List classify jobs.
 * Experimental: This endpoint is not yet ready for production use and is subject to change at any time.
 */ const listClassifyJobsApiV1ClassifierJobsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/classifier/jobs",
        ...options
    });
};
/**
 * Create Classify Job
 * Create a classify job.
 * Experimental: This endpoint is not yet ready for production use and is subject to change at any time.
 */ const createClassifyJobApiV1ClassifierJobsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/classifier/jobs",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Classify Job
 * Get a classify job.
 * Experimental: This endpoint is not yet ready for production use and is subject to change at any time.
 */ const getClassifyJobApiV1ClassifierJobsClassifyJobIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/classifier/jobs/{classify_job_id}",
        ...options
    });
};
/**
 * Get Classification Job Results
 * Get the results of a classify job.
 * Experimental: This endpoint is not yet ready for production use and is subject to change at any time.
 */ const getClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/classifier/jobs/{classify_job_id}/results",
        ...options
    });
};
/**
 * Read Self
 */ const readSelfApiV1AuthMeGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/auth/me",
        ...options
    });
};
/**
 * Create Customer Portal Session
 * Create a new customer portal session.
 */ const createCustomerPortalSessionApiV1BillingCustomerPortalSessionPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/billing/customer-portal-session",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Downgrade Plan
 */ const downgradePlanApiV1BillingDowngradePlanPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/billing/downgrade-plan",
        ...options
    });
};
/**
 * Create Intent And Customer Session
 * Create a new setup intent and and a customer session.
 *
 * See https://docs.stripe.com/payments/existing-customers?platform=web&ui=elements
 */ const createIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/billing/create-intent-and-customer-session",
        ...options
    });
};
/**
 * Get Metronome Dashboard
 * Get the invoices for a given organization.
 */ const getMetronomeDashboardApiV1BillingMetronomeDashboardGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/billing/metronome/dashboard",
        ...options
    });
};
/**
 * List Jobs
 */ const listJobsApiV1ExtractionJobsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/jobs",
        ...options
    });
};
/**
 * Run Job
 */ const runJobApiV1ExtractionJobsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/jobs",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Job
 */ const getJobApiV1ExtractionJobsJobIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/jobs/{job_id}",
        ...options
    });
};
/**
 * Run Job On File
 */ const runJobOnFileApiV1ExtractionJobsFilePost = (options)=>{
    return (options.client ?? client).post({
        ...k,
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/jobs/file",
        ...options,
        headers: {
            "Content-Type": null,
            ...options?.headers
        }
    });
};
/**
 * Run Batch Jobs
 */ const runBatchJobsApiV1ExtractionJobsBatchPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/jobs/batch",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Job Result
 */ const getJobResultApiV1ExtractionJobsJobIdResultGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/jobs/{job_id}/result",
        ...options
    });
};
/**
 * List Extract Runs
 */ const listExtractRunsApiV1ExtractionRunsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/runs",
        ...options
    });
};
/**
 * Get Latest Run From Ui
 */ const getLatestRunFromUiApiV1ExtractionRunsLatestFromUiGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/runs/latest-from-ui",
        ...options
    });
};
/**
 * Get Run By Job Id
 */ const getRunByJobIdApiV1ExtractionRunsByJobJobIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/runs/by-job/{job_id}",
        ...options
    });
};
/**
 * Delete Extraction Run
 */ const deleteExtractionRunApiV1ExtractionRunsRunIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/runs/{run_id}",
        ...options
    });
};
/**
 * Get Run
 */ const getRunApiV1ExtractionRunsRunIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/runs/{run_id}",
        ...options
    });
};
/**
 * Extract Stateless
 * Stateless extraction endpoint that uses a default extraction agent in the user's default project.
 * Requires data_schema, config, and either file_id, text, or base64 encoded file data.
 */ const extractStatelessApiV1ExtractionRunPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/run",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Extraction Agents
 */ const listExtractionAgentsApiV1ExtractionExtractionAgentsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents",
        ...options
    });
};
/**
 * Create Extraction Agent
 */ const createExtractionAgentApiV1ExtractionExtractionAgentsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Validate Extraction Schema
 * Validates an extraction agent's schema definition.
 * Returns the normalized and validated schema if valid, otherwise raises an HTTP 400.
 */ const validateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents/schema/validation",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Generate Extraction Schema
 * Generates an extraction agent's schema definition from a file and/or natural language prompt.
 */ const generateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents/schema/generate",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Extraction Agent By Name
 */ const getExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents/by-name/{name}",
        ...options
    });
};
/**
 * Get Or Create Default Extraction Agent
 * Get or create a default extraction agent for the current project.
 * The default agent has an empty schema and default configuration.
 */ const getOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents/default",
        ...options
    });
};
/**
 * Delete Extraction Agent
 */ const deleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}",
        ...options
    });
};
/**
 * Get Extraction Agent
 */ const getExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}",
        ...options
    });
};
/**
 * Update Extraction Agent
 */ const updateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List Api Keys
 * List API keys.
 *
 * If project_id is provided, validates user has access to that project.
 * If project_id is not provided, scopes results to the current user.
 *
 * Args:
 * user: Current user
 * db: Database session
 * page_size: Number of items per page
 * page_token: Token for pagination
 * name: Filter by API key name
 * project_id: Filter by project ID
 * key_type: Filter by key type
 *
 * Returns:
 * Paginated response with API keys
 */ const listApiKeysApiV1BetaApiKeysGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/api-keys",
        ...options
    });
};
/**
 * Create Api Key
 * Create a new API key.
 *
 * If project_id is specified, validates user has admin permissions for that project.
 *
 * Args:
 * api_key_create: API key creation data
 * user: Current user
 * db: Database session
 *
 * Returns:
 * The created API key with the secret key visible in redacted_api_key field
 */ const createApiKeyApiV1BetaApiKeysPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/api-keys",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Api Key
 * Delete an API key.
 *
 * If the API key belongs to a project, validates user has admin permissions for that project.
 * If the API key has no project, validates it belongs to the current user.
 *
 * Args:
 * api_key_id: The ID of the API key to delete
 * user: Current user
 * db: Database session
 */ const deleteApiKeyApiV1BetaApiKeysApiKeyIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/api-keys/{api_key_id}",
        ...options
    });
};
/**
 * Get Api Key
 * Get an API key by ID.
 *
 * Args:
 * api_key_id: The ID of the API key
 * user: Current user
 * db: Database session
 *
 * Returns:
 * The API key
 */ const getApiKeyApiV1BetaApiKeysApiKeyIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/api-keys/{api_key_id}",
        ...options
    });
};
/**
 * List Batches
 */ const listBatchesApiV1BetaBatchesGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/batches",
        ...options
    });
};
/**
 * Create Batch
 */ const createBatchApiV1BetaBatchesPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/batches",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Batch
 */ const getBatchApiV1BetaBatchesBatchIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/batches/{batch_id}",
        ...options
    });
};
/**
 * Delete Agent Data
 * Delete agent data by ID.
 */ const deleteAgentDataApiV1BetaAgentDataItemIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options
    });
};
/**
 * Get Agent Data
 * Get agent data by ID.
 */ const getAgentDataApiV1BetaAgentDataItemIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options
    });
};
/**
 * Update Agent Data
 * Update agent data by ID (overwrites).
 */ const updateAgentDataApiV1BetaAgentDataItemIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Create Agent Data
 * Create new agent data.
 */ const createAgentDataApiV1BetaAgentDataPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Search Agent Data
 * Search agent data with filtering, sorting, and pagination.
 */ const searchAgentDataApiV1BetaAgentDataSearchPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/:search",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Aggregate Agent Data
 * Aggregate agent data with grouping and optional counting/first item retrieval.
 */ const aggregateAgentDataApiV1BetaAgentDataAggregatePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/:aggregate",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Agent Data By Query
 * Bulk delete agent data by query (deployment_name, collection, optional filters).
 */ const deleteAgentDataByQueryApiV1BetaAgentDataDeletePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/:delete",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * List quota configurations
 * Retrieve a paginated list of quota configurations with optional filtering.
 */ const listQuotaConfigurationsApiV1BetaQuotaManagementGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/quota-management",
        ...options
    });
};
/**
 * Create File
 * Create a new file in the project.
 *
 * Args:
 * file_create: File creation data
 * project: Validated project from dependency
 * db: Database session
 *
 * Returns:
 * The created file
 */ const createFileApiV1BetaFilesPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/files",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert File
 * Upsert a file (create or update if exists) in the project.
 *
 * Args:
 * file_create: File creation/update data
 * project: Validated project from dependency
 * db: Database session
 *
 * Returns:
 * The upserted file
 */ const upsertFileApiV1BetaFilesPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/files",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Query Files
 * Query files with flexible filtering and pagination.
 *
 * Args:
 * request: The query request with filters and pagination
 * project: Validated project from dependency
 * db: Database session
 *
 * Returns:
 * Paginated response with files
 */ const queryFilesApiV1BetaFilesQueryPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/files/query",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete File
 * Delete a single file from the project.
 *
 * Args:
 * file_id: The ID of the file to delete
 * project: Validated project from dependency
 * db: Database session
 *
 * Returns:
 * None (204 No Content on success)
 */ const deleteFileApiV1BetaFilesFileIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/files/{file_id}",
        ...options
    });
};
/**
 * List Parse Configurations
 * List parse configurations for the current project.
 *
 * Args:
 * project: Validated project from dependency
 * user: Current user
 * db: Database session
 * page_size: Number of items per page
 * page_token: Token for pagination
 * name: Filter by configuration name
 * creator: Filter by creator
 * version: Filter by version
 *
 * Returns:
 * Paginated response with parse configurations
 */ const listParseConfigurationsApiV1BetaParseConfigurationsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/parse-configurations",
        ...options
    });
};
/**
 * Create Parse Configuration
 * Create a new parse configuration.
 *
 * Args:
 * config_create: Parse configuration creation data
 * project: Validated project from dependency
 * user: Current user
 * db: Database session
 *
 * Returns:
 * The created parse configuration
 */ const createParseConfigurationApiV1BetaParseConfigurationsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/parse-configurations",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Upsert Parse Configuration
 * Create or update a parse configuration by name.
 *
 * Args:
 * config_create: Parse configuration creation data
 * project: Validated project from dependency
 * user: Current user
 * db: Database session
 *
 * Returns:
 * The created or updated parse configuration
 */ const upsertParseConfigurationApiV1BetaParseConfigurationsPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/parse-configurations",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Parse Configuration
 * Delete a parse configuration.
 *
 * Args:
 * config_id: The ID of the parse configuration to delete
 * project: Validated project from dependency
 * user: Current user
 * db: Database session
 */ const deleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/parse-configurations/{config_id}",
        ...options
    });
};
/**
 * Get Parse Configuration
 * Get a parse configuration by ID.
 *
 * Args:
 * config_id: The ID of the parse configuration
 * project: Validated project from dependency
 * user: Current user
 * db: Database session
 *
 * Returns:
 * The parse configuration
 */ const getParseConfigurationApiV1BetaParseConfigurationsConfigIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/parse-configurations/{config_id}",
        ...options
    });
};
/**
 * Update Parse Configuration
 * Update a parse configuration.
 *
 * Args:
 * config_id: The ID of the parse configuration to update
 * config_update: Update data
 * project: Validated project from dependency
 * user: Current user
 * db: Database session
 *
 * Returns:
 * The updated parse configuration
 */ const updateParseConfigurationApiV1BetaParseConfigurationsConfigIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/parse-configurations/{config_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Query Parse Configurations
 * Query parse configurations with filtering and pagination.
 *
 * Args:
 * query_request: Query request with filters and pagination
 * project: Validated project from dependency
 * user: Current user
 * db: Database session
 *
 * Returns:
 * Paginated response with parse configurations
 */ const queryParseConfigurationsApiV1BetaParseConfigurationsQueryPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/parse-configurations/query",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Latest Parse Configuration
 * Get the latest parse configuration for the current project.
 *
 * Args:
 * project: Validated project from dependency
 * user: Current user
 * db: Database session
 * creator: Optional creator filter
 *
 * Returns:
 * The latest parse configuration or None if not found
 */ const getLatestParseConfigurationApiV1BetaParseConfigurationsLatestGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/parse-configurations/latest",
        ...options
    });
};
/**
 * List Spreadsheet Jobs
 * List spreadsheet parsing jobs.
 * Experimental: This endpoint is not yet ready for production use and is subject to change at any time.
 */ const listSpreadsheetJobsApiV1BetaSpreadsheetJobsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/spreadsheet/jobs",
        ...options
    });
};
/**
 * Create Spreadsheet Job
 * Create a spreadsheet parsing job.
 * Experimental: This endpoint is not yet ready for production use and is subject to change at any time.
 */ const createSpreadsheetJobApiV1BetaSpreadsheetJobsPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/spreadsheet/jobs",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Get Spreadsheet Job
 * Get a spreadsheet parsing job.
 *
 * When include_results=True (default), the response will include extracted tables and results
 * if the job is complete, eliminating the need for a separate /results call.
 *
 * Experimental: This endpoint is not yet ready for production use and is subject to change at any time.
 */ const getSpreadsheetJobApiV1BetaSpreadsheetJobsSpreadsheetJobIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/spreadsheet/jobs/{spreadsheet_job_id}",
        ...options
    });
};
/**
 * Get Table Download Presigned Url
 * Generate a presigned URL to download a specific extracted table.
 * Experimental: This endpoint is not yet ready for production use and is subject to change at any time.
 */ const getTableDownloadPresignedUrlApiV1BetaSpreadsheetJobsSpreadsheetJobIdTablesTableIdResultGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/spreadsheet/jobs/{spreadsheet_job_id}/tables/{table_id}/result",
        ...options
    });
};
/**
 * Upload File V2
 */ const uploadFileV2ApiV2Alpha1ParseUploadPost = (options)=>{
    return (options?.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v2alpha1/parse/upload",
        ...options
    });
};
/**
 * Get Job Image Result
 * Get a job by id
 */ const getJobImageResultApiParsingJobJobIdResultImageNameGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/image/{name}",
        ...options
    });
};
/**
 * Get Supported File Extensions
 * Get a list of supported file extensions
 */ const getSupportedFileExtensionsApiParsingSupportedFileExtensionsGet = (options)=>{
    return (options?.client ?? client).get({
        url: "/api/parsing/supported_file_extensions",
        ...options
    });
};
/**
 * Screenshot
 */ const screenshotApiParsingScreenshotPost = (options)=>{
    return (options?.client ?? client).post({
        ...k,
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/screenshot",
        ...options,
        headers: {
            "Content-Type": null,
            ...options?.headers
        }
    });
};
/**
 * Upload File
 */ const uploadFileApiParsingUploadPost = (options)=>{
    return (options?.client ?? client).post({
        ...k,
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/upload",
        ...options,
        headers: {
            "Content-Type": null,
            ...options?.headers
        }
    });
};
/**
 * Get Job
 * Get a job by id
 */ const getJobApiParsingJobJobIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}",
        ...options
    });
};
/**
 * Get Job Parameters
 * Get a job by id
 */ const getJobParametersApiParsingJobJobIdParametersGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/parameters",
        ...options
    });
};
/**
 * Get Parsing Job Details
 * Get a job by id
 */ const getParsingJobDetailsApiParsingJobJobIdDetailsGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/details",
        ...options
    });
};
/**
 * Get Job Text Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobTextResultApiParsingJobJobIdResultTextGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/text",
        ...options
    });
};
/**
 * Get Job Raw Text Result Raw
 * Get a job by id
 */ const getJobRawTextResultRawApiParsingJobJobIdResultRawTextGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/raw/text",
        ...options
    });
};
/**
 * Get Job Raw Text Result
 * Get a job by id
 */ const getJobRawTextResultApiParsingJobJobIdResultPdfGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/pdf",
        ...options
    });
};
/**
 * Get Job Raw Text Result Raw Pdf
 * Get a job by id
 */ const getJobRawTextResultRawPdfApiParsingJobJobIdResultRawPdfGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/raw/pdf",
        ...options
    });
};
/**
 * Get Job Structured Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobStructuredResultApiParsingJobJobIdResultStructuredGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/structured",
        ...options
    });
};
/**
 * Get Job Raw Structured Result
 * Get a job by id
 */ const getJobRawStructuredResultApiParsingJobJobIdResultRawStructuredGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/raw/structured",
        ...options
    });
};
/**
 * Get Job Raw Xlsx Result
 * Get a job by id
 */ const getJobRawXlsxResultApiParsingJobJobIdResultXlsxGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/xlsx",
        ...options
    });
};
/**
 * Get Job Raw Xlsx Result Raw
 * Get a job by id
 */ const getJobRawXlsxResultRawApiParsingJobJobIdResultRawXlsxGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/raw/xlsx",
        ...options
    });
};
/**
 * Get Job Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobResultApiParsingJobJobIdResultMarkdownGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/markdown",
        ...options
    });
};
/**
 * Get Job Raw Md Result
 * Get a job by id
 */ const getJobRawMdResultApiParsingJobJobIdResultRawMarkdownGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/raw/markdown",
        ...options
    });
};
/**
 * Get Job Json Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobJsonResultApiParsingJobJobIdResultJsonGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/json",
        ...options
    });
};
/**
 * Get Job Json Raw Result
 * Get a job by id
 */ const getJobJsonRawResultApiParsingJobJobIdResultRawJsonGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/result/raw/json",
        ...options
    });
};
/**
 * @deprecated
 * Get Parsing History Result
 * Get parsing history for user
 *
 * This endpoint is deprecated.
 * Use /api/v1/jobs/?job_name=parsing&project_id=YOUR_PROJECT_ID instead.
 */ const getParsingHistoryResultApiParsingHistoryGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/history",
        ...options
    });
};
/**
 * Generate Presigned Url
 * Generate a presigned URL for a job
 */ const generatePresignedUrlApiParsingJobJobIdReadFilenameGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/parsing/job/{job_id}/read/{filename}",
        ...options
    });
};

client.setConfig({
    baseUrl: "https://api.cloud.llamaindex.ai/",
    headers: {
        "X-SDK-Name": "llamaindex-ts"
    }
});

export { ApiKeyType, BoxAuthMechanism, CompositeRetrievalMode, ConfigurableDataSinkNames, ConfigurableDataSourceNames, DocumentChunkMode, ExtractMode, ExtractModels, ExtractState, ExtractTarget, FailPageMode, FilterCondition, FilterOperator, JobNameMapping, JobNames, LlamaParseSupportedFileExtensions, ManagedIngestionStatus, MessageRole, MetronomeDashboardType, NodeRelationship, ObjectType, ParsePlanLevel, ParserLanguages, ParsingMode, PartitionNames, PgVectorDistanceMethod, PgVectorVectorType, PipelineType, Pooling, PublicModelName, ReRankerType, RetrievalMode, SparseModelType, StatusEnum, SupportedLlmModelNames, VertexEmbeddingMode, addDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPut, addFilesToPipelineApiApiV1PipelinesPipelineIdFilesPut, addUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPut, addUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPut, aggregateAgentDataApiV1BetaAgentDataAggregatePost, assignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPut, batchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePut, cancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPost, chatApiV1PipelinesPipelineIdChatPost, chatWithChatAppApiV1AppsIdChatPost, client, copyPipelineApiV1PipelinesPipelineIdCopyPost, createAgentDataApiV1BetaAgentDataPost, createApiKeyApiV1BetaApiKeysPost, createBatchApiV1BetaBatchesPost, createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost, createChatAppApiV1AppsPost, createClassifyJobApiV1ClassifierJobsPost, createCustomerPortalSessionApiV1BillingCustomerPortalSessionPost, createDataSinkApiV1DataSinksPost, createDataSourceApiV1DataSourcesPost, createEmbeddingModelConfigApiV1EmbeddingModelConfigsPost, createExtractionAgentApiV1ExtractionExtractionAgentsPost, createFileApiV1BetaFilesPost, createIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPost, createOrganizationApiV1OrganizationsPost, createParseConfigurationApiV1BetaParseConfigurationsPost, createPipelineApiV1PipelinesPost, createProjectApiV1ProjectsPost, createRetrieverApiV1RetrieversPost, createSpreadsheetJobApiV1BetaSpreadsheetJobsPost, deleteAgentDataApiV1BetaAgentDataItemIdDelete, deleteAgentDataByQueryApiV1BetaAgentDataDeletePost, deleteApiKeyApiV1ApiKeysApiKeyIdDelete, deleteApiKeyApiV1BetaApiKeysApiKeyIdDelete, deleteChatAppApiV1AppsIdDelete, deleteDataSinkApiV1DataSinksDataSinkIdDelete, deleteDataSourceApiV1DataSourcesDataSourceIdDelete, deleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDelete, deleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDelete, deleteExtractionRunApiV1ExtractionRunsRunIdDelete, deleteFileApiV1BetaFilesFileIdDelete, deleteFileApiV1FilesIdDelete, deleteOrganizationApiV1OrganizationsOrganizationIdDelete, deleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDelete, deletePipelineApiV1PipelinesPipelineIdDelete, deletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDelete, deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete, deletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDelete, deletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDelete, deleteProjectApiV1ProjectsProjectIdDelete, deleteRetrieverApiV1RetrieversRetrieverIdDelete, directRetrieveApiV1RetrieversRetrievePost, downgradePlanApiV1BillingDowngradePlanPost, extractStatelessApiV1ExtractionRunPost, forceDeletePipelineApiV1PipelinesPipelineIdForceDeletePost, forceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPost, generateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePost, generateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPost, generateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPost, generateKeyApiV1ApiKeysPost, generatePresignedUrlApiParsingJobJobIdReadFilenameGet, generatePresignedUrlApiV1FilesPut, generatePresignedUrlApiV1ParsingJobJobIdReadFilenameGet, getAgentDataApiV1BetaAgentDataItemIdGet, getApiKeyApiV1BetaApiKeysApiKeyIdGet, getBatchApiV1BetaBatchesBatchIdGet, getChatAppApiV1AppsIdGet, getChatAppsApiV1AppsGet, getClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGet, getClassifyJobApiV1ClassifierJobsClassifyJobIdGet, getCurrentProjectApiV1ProjectsCurrentGet, getDataSinkApiV1DataSinksDataSinkIdGet, getDataSourceApiV1DataSourcesDataSourceIdGet, getDefaultOrganizationApiV1OrganizationsDefaultGet, getExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGet, getExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGet, getFileApiV1FilesIdGet, getFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGet, getFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGet, getJobApiParsingJobJobIdGet, getJobApiV1ExtractionJobsJobIdGet, getJobApiV1ParsingJobJobIdGet, getJobImageResultApiParsingJobJobIdResultImageNameGet, getJobImageResultApiV1ParsingJobJobIdResultImageNameGet, getJobJsonRawResultApiParsingJobJobIdResultRawJsonGet, getJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGet, getJobJsonResultApiParsingJobJobIdResultJsonGet, getJobJsonResultApiV1ParsingJobJobIdResultJsonGet, getJobParametersApiParsingJobJobIdParametersGet, getJobParametersApiV1ParsingJobJobIdParametersGet, getJobRawMdResultApiParsingJobJobIdResultRawMarkdownGet, getJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGet, getJobRawStructuredResultApiParsingJobJobIdResultRawStructuredGet, getJobRawStructuredResultApiV1ParsingJobJobIdResultRawStructuredGet, getJobRawTextResultApiParsingJobJobIdResultPdfGet, getJobRawTextResultApiV1ParsingJobJobIdResultPdfGet, getJobRawTextResultRawApiParsingJobJobIdResultRawTextGet, getJobRawTextResultRawApiV1ParsingJobJobIdResultRawTextGet, getJobRawTextResultRawPdfApiParsingJobJobIdResultRawPdfGet, getJobRawTextResultRawPdfApiV1ParsingJobJobIdResultRawPdfGet, getJobRawXlsxResultApiParsingJobJobIdResultXlsxGet, getJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGet, getJobRawXlsxResultRawApiParsingJobJobIdResultRawXlsxGet, getJobRawXlsxResultRawApiV1ParsingJobJobIdResultRawXlsxGet, getJobResultApiParsingJobJobIdResultMarkdownGet, getJobResultApiV1ExtractionJobsJobIdResultGet, getJobResultApiV1ParsingJobJobIdResultMarkdownGet, getJobStructuredResultApiParsingJobJobIdResultStructuredGet, getJobStructuredResultApiV1ParsingJobJobIdResultStructuredGet, getJobTextResultApiParsingJobJobIdResultTextGet, getJobTextResultApiV1ParsingJobJobIdResultTextGet, getJobsApiV1JobsGet, getLatestParseConfigurationApiV1BetaParseConfigurationsLatestGet, getLatestRunFromUiApiV1ExtractionRunsLatestFromUiGet, getMetronomeDashboardApiV1BillingMetronomeDashboardGet, getOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGet, getOrganizationApiV1OrganizationsOrganizationIdGet, getOrganizationUsageApiV1OrganizationsOrganizationIdUsageGet, getParseConfigurationApiV1BetaParseConfigurationsConfigIdGet, getParsingHistoryResultApiParsingHistoryGet, getParsingHistoryResultApiV1ParsingHistoryGet, getParsingJobDetailsApiParsingJobJobIdDetailsGet, getParsingJobDetailsApiV1ParsingJobJobIdDetailsGet, getPipelineApiV1PipelinesPipelineIdGet, getPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGet, getPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGet, getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet, getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet, getPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGet, getPipelineJobApiV1PipelinesPipelineIdJobsJobIdGet, getPipelineStatusApiV1PipelinesPipelineIdStatusGet, getPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGet, getProjectApiV1ProjectsProjectIdGet, getProjectUsageApiV1ProjectsProjectIdUsageGet, getRetrieverApiV1RetrieversRetrieverIdGet, getRunApiV1ExtractionRunsRunIdGet, getRunByJobIdApiV1ExtractionRunsByJobJobIdGet, getSpreadsheetJobApiV1BetaSpreadsheetJobsSpreadsheetJobIdGet, getSupportedFileExtensionsApiParsingSupportedFileExtensionsGet, getSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGet, getTableDownloadPresignedUrlApiV1BetaSpreadsheetJobsSpreadsheetJobIdTablesTableIdResultGet, getUserRoleApiV1OrganizationsOrganizationIdUsersRolesGet, importPipelineMetadataApiV1PipelinesPipelineIdMetadataPut, listApiKeysApiV1BetaApiKeysGet, listBatchesApiV1BetaBatchesGet, listClassifyJobsApiV1ClassifierJobsGet, listDataSinksApiV1DataSinksGet, listDataSourcesApiV1DataSourcesGet, listDeploymentsApiV1ProjectsProjectIdAgentsGet, listEmbeddingModelConfigsApiV1EmbeddingModelConfigsGet, listExtractRunsApiV1ExtractionRunsGet, listExtractionAgentsApiV1ExtractionExtractionAgentsGet, listFilePageFiguresApiV1FilesIdPageFiguresPageIndexGet, listFilePageScreenshotsApiV1FilesIdPageScreenshotsGet, listFilePagesFiguresApiV1FilesIdPageFiguresGet, listFilesApiV1FilesGet, listJobsApiV1ExtractionJobsGet, listKeysApiV1ApiKeysGet, listOrganizationUsersApiV1OrganizationsOrganizationIdUsersGet, listOrganizationsApiV1OrganizationsGet, listParseConfigurationsApiV1BetaParseConfigurationsGet, listPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGet, listPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGet, listPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGet, listPipelineFiles2ApiV1PipelinesPipelineIdFiles2Get, listPipelineFilesApiV1PipelinesPipelineIdFilesGet, listPipelineJobsApiV1PipelinesPipelineIdJobsGet, listProjectsApiV1ProjectsGet, listProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGet, listQuotaConfigurationsApiV1BetaQuotaManagementGet, listRetrieversApiV1RetrieversGet, listRolesApiV1OrganizationsOrganizationIdRolesGet, listSpreadsheetJobsApiV1BetaSpreadsheetJobsGet, listSupportedModelsApiV1EvalsModelsGet, paginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGet, queryFilesApiV1BetaFilesQueryPost, queryParseConfigurationsApiV1BetaParseConfigurationsQueryPost, readFileContentApiV1FilesIdContentGet, readSelfApiV1AuthMeGet, removeUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDelete, removeUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDelete, retrieveApiV1RetrieversRetrieverIdRetrievePost, runBatchJobsApiV1ExtractionJobsBatchPost, runJobApiV1ExtractionJobsPost, runJobOnFileApiV1ExtractionJobsFilePost, runSearchApiV1PipelinesPipelineIdRetrievePost, screenshotApiParsingScreenshotPost, screenshotApiV1ParsingScreenshotPost, searchAgentDataApiV1BetaAgentDataSearchPost, searchPipelinesApiV1PipelinesGet, setDefaultOrganizationApiV1OrganizationsDefaultPut, syncDeploymentsApiV1ProjectsProjectIdAgentsSyncPost, syncFilesApiV1FilesSyncPut, syncPipelineApiV1PipelinesPipelineIdSyncPost, syncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPost, syncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPost, updateAgentDataApiV1BetaAgentDataItemIdPut, updateChatAppApiV1AppsIdPut, updateDataSinkApiV1DataSinksDataSinkIdPut, updateDataSourceApiV1DataSourcesDataSourceIdPut, updateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPut, updateExistingPipelineApiV1PipelinesPipelineIdPut, updateExistingProjectApiV1ProjectsProjectIdPut, updateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPut, updateOrganizationApiV1OrganizationsOrganizationIdPut, updateParseConfigurationApiV1BetaParseConfigurationsConfigIdPut, updatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPut, updatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPut, updateRetrieverApiV1RetrieversRetrieverIdPut, uploadFileApiParsingUploadPost, uploadFileApiV1FilesPost, uploadFileApiV1ParsingUploadPost, uploadFileFromUrlApiV1FilesUploadFromUrlPut, uploadFileV2ApiV2Alpha1ParseUploadPost, upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut, upsertDataSinkApiV1DataSinksPut, upsertDataSourceApiV1DataSourcesPut, upsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPut, upsertFileApiV1BetaFilesPut, upsertOrganizationApiV1OrganizationsPut, upsertParseConfigurationApiV1BetaParseConfigurationsPut, upsertPipelineApiV1PipelinesPut, upsertProjectApiV1ProjectsPut, upsertRetrieverApiV1RetrieversPut, validateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPost, validateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPost, validateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPost, validateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPost };
