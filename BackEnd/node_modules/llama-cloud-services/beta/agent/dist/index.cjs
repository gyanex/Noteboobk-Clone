Object.defineProperty(exports, '__esModule', { value: true });

var index_cjs = require('../../../api/dist/index.cjs');

var j = async (t, r)=>{
    let e = typeof r == "function" ? await r(t) : r;
    if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
}, R = {
    bodySerializer: (t)=>JSON.stringify(t, (r, e)=>typeof e == "bigint" ? e.toString() : e)
}, U = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, _ = (t)=>{
    switch(t){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
}, D = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, O = ({ allowReserved: t, explode: r, name: e, style: i, value: a })=>{
    if (!r) {
        let n = (t ? a : a.map((l)=>encodeURIComponent(l))).join(_(i));
        switch(i){
            case "label":
                return `.${n}`;
            case "matrix":
                return `;${e}=${n}`;
            case "simple":
                return n;
            default:
                return `${e}=${n}`;
        }
    }
    let o = U(i), s = a.map((n)=>i === "label" || i === "simple" ? t ? n : encodeURIComponent(n) : y({
            allowReserved: t,
            name: e,
            value: n
        })).join(o);
    return i === "label" || i === "matrix" ? o + s : s;
}, y = ({ allowReserved: t, name: r, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${r}=${t ? e : encodeURIComponent(e)}`;
}, q = ({ allowReserved: t, explode: r, name: e, style: i, value: a })=>{
    if (a instanceof Date) return `${e}=${a.toISOString()}`;
    if (i !== "deepObject" && !r) {
        let n = [];
        Object.entries(a).forEach(([f, p])=>{
            n = [
                ...n,
                f,
                t ? p : encodeURIComponent(p)
            ];
        });
        let l = n.join(",");
        switch(i){
            case "form":
                return `${e}=${l}`;
            case "label":
                return `.${l}`;
            case "matrix":
                return `;${e}=${l}`;
            default:
                return l;
        }
    }
    let o = D(i), s = Object.entries(a).map(([n, l])=>y({
            allowReserved: t,
            name: i === "deepObject" ? `${e}[${n}]` : n,
            value: l
        })).join(o);
    return i === "label" || i === "matrix" ? o + s : s;
};
var H = /\{[^{}]+\}/g, B = ({ path: t, url: r })=>{
    let e = r, i = r.match(H);
    if (i) for (let a of i){
        let o = false, s = a.substring(1, a.length - 1), n = "simple";
        s.endsWith("*") && (o = true, s = s.substring(0, s.length - 1)), s.startsWith(".") ? (s = s.substring(1), n = "label") : s.startsWith(";") && (s = s.substring(1), n = "matrix");
        let l = t[s];
        if (l == null) continue;
        if (Array.isArray(l)) {
            e = e.replace(a, O({
                explode: o,
                name: s,
                style: n,
                value: l
            }));
            continue;
        }
        if (typeof l == "object") {
            e = e.replace(a, q({
                explode: o,
                name: s,
                style: n,
                value: l
            }));
            continue;
        }
        if (n === "matrix") {
            e = e.replace(a, `;${y({
                name: s,
                value: l
            })}`);
            continue;
        }
        let f = encodeURIComponent(n === "label" ? `.${l}` : l);
        e = e.replace(a, f);
    }
    return e;
}, A = ({ allowReserved: t, array: r, object: e } = {})=>(a)=>{
        let o = [];
        if (a && typeof a == "object") for(let s in a){
            let n = a[s];
            if (n != null) if (Array.isArray(n)) {
                let l = O({
                    allowReserved: t,
                    explode: true,
                    name: s,
                    style: "form",
                    value: n,
                    ...r
                });
                l && o.push(l);
            } else if (typeof n == "object") {
                let l = q({
                    allowReserved: t,
                    explode: true,
                    name: s,
                    style: "deepObject",
                    value: n,
                    ...e
                });
                l && o.push(l);
            } else {
                let l = y({
                    allowReserved: t,
                    name: s,
                    value: n
                });
                l && o.push(l);
            }
        }
        return o.join("&");
    }, P = (t)=>{
    if (!t) return "stream";
    let r = t.split(";")[0]?.trim();
    if (r) {
        if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
        if (r === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((e)=>r.startsWith(e))) return "blob";
        if (r.startsWith("text/")) return "text";
    }
}, E = async ({ security: t, ...r })=>{
    for (let e of t){
        let i = await j(e, r.auth);
        if (!i) continue;
        let a = e.name ?? "Authorization";
        switch(e.in){
            case "query":
                r.query || (r.query = {}), r.query[a] = i;
                break;
            case "cookie":
                r.headers.append("Cookie", `${a}=${i}`);
                break;
            case "header":
            default:
                r.headers.set(a, i);
                break;
        }
        return;
    }
}, S = (t)=>W({
        baseUrl: t.baseUrl,
        path: t.path,
        query: t.query,
        querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : A(t.querySerializer),
        url: t.url
    }), W = ({ baseUrl: t, path: r, query: e, querySerializer: i, url: a })=>{
    let o = a.startsWith("/") ? a : `/${a}`, s = (t ?? "") + o;
    r && (s = B({
        path: r,
        url: s
    }));
    let n = e ? i(e) : "";
    return n.startsWith("?") && (n = n.substring(1)), n && (s += `?${n}`), s;
}, x = (t, r)=>{
    let e = {
        ...t,
        ...r
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = C(t.headers, r.headers), e;
}, C = (...t)=>{
    let r = new Headers;
    for (let e of t){
        if (!e || typeof e != "object") continue;
        let i = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [a, o] of i)if (o === null) r.delete(a);
        else if (Array.isArray(o)) for (let s of o)r.append(a, s);
        else o !== void 0 && r.set(a, typeof o == "object" ? JSON.stringify(o) : o);
    }
    return r;
}, h = class {
    constructor(){
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    getInterceptorIndex(r) {
        return typeof r == "number" ? this._fns[r] ? r : -1 : this._fns.indexOf(r);
    }
    exists(r) {
        let e = this.getInterceptorIndex(r);
        return !!this._fns[e];
    }
    eject(r) {
        let e = this.getInterceptorIndex(r);
        this._fns[e] && (this._fns[e] = null);
    }
    update(r, e) {
        let i = this.getInterceptorIndex(r);
        return this._fns[i] ? (this._fns[i] = e, r) : false;
    }
    use(r) {
        return this._fns = [
            ...this._fns,
            r
        ], this._fns.length - 1;
    }
}, v = ()=>({
        error: new h,
        request: new h,
        response: new h
    }), N = A({
    allowReserved: false,
    array: {
        explode: true,
        style: "form"
    },
    object: {
        explode: true,
        style: "deepObject"
    }
}), Q = {
    "Content-Type": "application/json"
}, w = (t = {})=>({
        ...R,
        headers: Q,
        parseAs: "auto",
        querySerializer: N,
        ...t
    });
var J = (t = {})=>{
    let r = x(w(), t), e = ()=>({
            ...r
        }), i = (s)=>(r = x(r, s), e()), a = v(), o = async (s)=>{
        let n = {
            ...r,
            ...s,
            fetch: s.fetch ?? r.fetch ?? globalThis.fetch,
            headers: C(r.headers, s.headers)
        };
        n.security && await E({
            ...n,
            security: n.security
        }), n.body && n.bodySerializer && (n.body = n.bodySerializer(n.body)), (n.body === void 0 || n.body === "") && n.headers.delete("Content-Type");
        let l = S(n), f = {
            redirect: "follow",
            ...n
        }, p = new Request(l, f);
        for (let c of a.request._fns)c && (p = await c(p, n));
        let T = n.fetch, u = await T(p);
        for (let c of a.response._fns)c && (u = await c(u, p, n));
        let m = {
            request: p,
            response: u
        };
        if (u.ok) {
            if (u.status === 204 || u.headers.get("Content-Length") === "0") return {
                data: {},
                ...m
            };
            let c = (n.parseAs === "auto" ? P(u.headers.get("Content-Type")) : n.parseAs) ?? "json";
            if (c === "stream") return {
                data: u.body,
                ...m
            };
            let b = await u[c]();
            return c === "json" && (n.responseValidator && await n.responseValidator(b), n.responseTransformer && (b = await n.responseTransformer(b))), {
                data: b,
                ...m
            };
        }
        let g = await u.text();
        try {
            g = JSON.parse(g);
        } catch  {}
        let d = g;
        for (let c of a.error._fns)c && (d = await c(g, u, p, n));
        if (d = d || {}, n.throwOnError) throw d;
        return {
            error: d,
            ...m
        };
    };
    return {
        buildUrl: S,
        connect: (s)=>o({
                ...s,
                method: "CONNECT"
            }),
        delete: (s)=>o({
                ...s,
                method: "DELETE"
            }),
        get: (s)=>o({
                ...s,
                method: "GET"
            }),
        getConfig: e,
        head: (s)=>o({
                ...s,
                method: "HEAD"
            }),
        interceptors: a,
        options: (s)=>o({
                ...s,
                method: "OPTIONS"
            }),
        patch: (s)=>o({
                ...s,
                method: "PATCH"
            }),
        post: (s)=>o({
                ...s,
                method: "POST"
            }),
        put: (s)=>o({
                ...s,
                method: "PUT"
            }),
        request: o,
        setConfig: i,
        trace: (s)=>o({
                ...s,
                method: "TRACE"
            })
    };
};

// This file is auto-generated by @hey-api/openapi-ts
const client = J(w());

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Delete Agent Data
 * Delete agent data by ID.
 */ const deleteAgentDataApiV1BetaAgentDataItemIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options
    });
};
/**
 * Get Agent Data
 * Get agent data by ID.
 */ const getAgentDataApiV1BetaAgentDataItemIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options
    });
};
/**
 * Update Agent Data
 * Update agent data by ID (overwrites).
 */ const updateAgentDataApiV1BetaAgentDataItemIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Create Agent Data
 * Create new agent data.
 */ const createAgentDataApiV1BetaAgentDataPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Search Agent Data
 * Search agent data with filtering, sorting, and pagination.
 */ const searchAgentDataApiV1BetaAgentDataSearchPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/:search",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Aggregate Agent Data
 * Aggregate agent data with grouping and optional counting/first item retrieval.
 */ const aggregateAgentDataApiV1BetaAgentDataAggregatePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/:aggregate",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Delete Agent Data By Query
 * Bulk delete agent data by query (deployment_name, collection, optional filters).
 */ const deleteAgentDataByQueryApiV1BetaAgentDataDeletePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/:delete",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};

/**
 * Async client for agent data operations
 */ class AgentClient {
    constructor({ client = index_cjs.client, collection = "default", deploymentName = "_public", agentUrlId }){
        this.client = client;
        this.collection = collection;
        this.deploymentName = agentUrlId || deploymentName;
    }
    /**
   * Create new agent data
   */ async createItem(data) {
        const response = await createAgentDataApiV1BetaAgentDataPost({
            throwOnError: true,
            body: {
                deployment_name: this.deploymentName,
                collection: this.collection,
                data: data
            },
            client: this.client
        });
        return this.transformResponse(response.data);
    }
    /**
   * Get agent data by ID
   */ async getItem(id) {
        try {
            const response = await getAgentDataApiV1BetaAgentDataItemIdGet({
                throwOnError: true,
                path: {
                    item_id: id
                },
                client: this.client
            });
            return this.transformResponse(response.data);
        } catch (error) {
            if (error instanceof Error && "response" in error && error.response?.status === 404) {
                return null;
            }
            throw error;
        }
    }
    /**
   * Update agent data
   */ async updateItem(id, data) {
        const response = await updateAgentDataApiV1BetaAgentDataItemIdPut({
            throwOnError: true,
            path: {
                item_id: id
            },
            body: {
                data: data
            },
            client: this.client
        });
        return this.transformResponse(response.data);
    }
    /**
   * Delete agent data
   */ async deleteItem(id) {
        await deleteAgentDataApiV1BetaAgentDataItemIdDelete({
            throwOnError: true,
            path: {
                item_id: id
            },
            client: this.client
        });
    }
    /**
   * Delete all matching agent data, returns the total number of deleted items
   */ async delete(options) {
        const response = await deleteAgentDataByQueryApiV1BetaAgentDataDeletePost({
            throwOnError: true,
            body: {
                deployment_name: this.deploymentName,
                ...this.collection !== undefined && {
                    collection: this.collection
                },
                ...options.filter !== undefined && {
                    filter: options.filter
                }
            },
            client: this.client
        });
        return response.data.deleted_count;
    }
    /**
   * Search agent data
   */ async search(options) {
        const response = await searchAgentDataApiV1BetaAgentDataSearchPost({
            throwOnError: true,
            body: {
                deployment_name: this.deploymentName,
                ...this.collection !== undefined && {
                    collection: this.collection
                },
                ...options.filter !== undefined && {
                    filter: options.filter
                },
                ...options.orderBy !== undefined && {
                    order_by: options.orderBy
                },
                ...options.pageSize !== undefined && {
                    page_size: options.pageSize
                },
                ...options.offset !== undefined && {
                    offset: options.offset
                },
                ...options.includeTotal !== undefined && {
                    include_total: options.includeTotal
                }
            },
            client: this.client
        });
        const result = {
            items: response.data.items.map((item)=>this.transformResponse(item))
        };
        if (response.data.total_size !== null && response.data.total_size !== undefined) {
            result.totalSize = response.data.total_size;
        }
        if (response.data.next_page_token !== null && response.data.next_page_token !== undefined) {
            result.nextPageToken = response.data.next_page_token;
        }
        return result;
    }
    /**
   * Aggregate agent data into groups
   */ async aggregate(options) {
        const response = await aggregateAgentDataApiV1BetaAgentDataAggregatePost({
            throwOnError: true,
            body: {
                deployment_name: this.deploymentName,
                ...this.collection !== undefined && {
                    collection: this.collection
                },
                ...options.filter !== undefined && {
                    filter: options.filter
                },
                ...options.groupBy !== undefined && {
                    group_by: options.groupBy
                },
                ...options.count !== undefined && {
                    count: options.count
                },
                ...options.first !== undefined && {
                    first: options.first
                },
                ...options.orderBy !== undefined && {
                    order_by: options.orderBy
                },
                ...options.offset !== undefined && {
                    offset: options.offset
                },
                ...options.pageSize !== undefined && {
                    page_size: options.pageSize
                }
            },
            client: this.client
        });
        const result = {
            items: response.data.items.map((item)=>this.transformAggregateResponse(item))
        };
        if (response.data.total_size !== null && response.data.total_size !== undefined) {
            result.totalSize = response.data.total_size;
        }
        if (response.data.next_page_token !== null && response.data.next_page_token !== undefined) {
            result.nextPageToken = response.data.next_page_token;
        }
        return result;
    }
    /**
   * Transform API response to typed data
   */ transformResponse(data) {
        const result = {
            id: data.id,
            deploymentName: data.deployment_name,
            data: data.data,
            createdAt: new Date(data.created_at),
            updatedAt: new Date(data.updated_at)
        };
        if (data.collection !== undefined) {
            result.collection = data.collection;
        }
        return result;
    }
    /**
   * Transform API aggregate response to typed data
   */ transformAggregateResponse(data) {
        const result = {
            groupKey: data.group_key
        };
        if (data.count !== null && data.count !== undefined) {
            result.count = data.count;
        }
        if (data.first_item !== null && data.first_item !== undefined) {
            result.firstItem = data.first_item;
        }
        return result;
    }
}
/**
 * Create a new AsyncAgentDataClient instance. Does it's best to infer an agent url id from environment.
 * Pass in the window url and/or env to infer the agent url id from them.
 * @param options - The options for the client
 * @returns A new AgentClient instance
 */ function createAgentDataClient({ client = index_cjs.client, windowUrl, env, deploymentName, agentUrlId, collection = "default" } = {}) {
    if (env && !deploymentName) {
        deploymentName = env.LLAMA_DEPLOY_DEPLOYMENT_NAME || env.NEXT_PUBLIC_LLAMA_DEPLOY_DEPLOYMENT_NAME || env.VITE_LLAMA_DEPLOY_DEPLOYMENT_NAME;
    }
    if (windowUrl && !deploymentName) {
        try {
            const url = new URL(windowUrl);
            const path = url.pathname;
            const isLocalhost = url.hostname.includes("localhost") || url.hostname.includes("127.0.0.1");
            if (path.startsWith("/deployments/") && !isLocalhost) {
                // /deployments/<agent-url-id>/ui/ -> ["", "deployments", "<agent-url-id>", "ui"]
                deploymentName = path.split("/")[2];
            }
        } catch (error) {
            console.warn("Failed to infer deployment name from window url, falling back to default", error);
        }
    }
    return new AgentClient({
        ...deploymentName && {
            deploymentName
        },
        ...agentUrlId && {
            agentUrlId
        },
        collection,
        client
    });
}

/**
 * Status types for agent data processing
 */ const StatusType = {
    ERROR: "error",
    ACCEPTED: "accepted",
    REJECTED: "rejected",
    PENDING_REVIEW: "pending_review"
};

exports.AgentClient = AgentClient;
exports.StatusTypeEnum = StatusType;
exports.createAgentDataClient = createAgentDataClient;
