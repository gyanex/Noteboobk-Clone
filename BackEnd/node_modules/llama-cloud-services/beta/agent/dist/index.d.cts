import { createClient } from '@hey-api/client-fetch';

/**
 * API request model for a filter comparison operation.
 */
type FilterOperation$1 = {
    eq?: number | number | string | null;
    gt?: number | number | string | null;
    gte?: number | number | string | null;
    lt?: number | number | string | null;
    lte?: number | number | string | null;
    includes?: Array<number | number | string | null>;
};

/**
 * Status types for agent data processing
 */
declare const StatusType: {
    readonly ERROR: "error";
    readonly ACCEPTED: "accepted";
    readonly REJECTED: "rejected";
    readonly PENDING_REVIEW: "pending_review";
};
type StatusType = (typeof StatusType)[keyof typeof StatusType];
declare const ComparisonOperator: {
    readonly GT: "gt";
    readonly GTE: "gte";
    readonly LT: "lt";
    readonly LTE: "lte";
    readonly EQ: "eq";
    readonly INCLUDES: "includes";
};
type ComparisonOperator = (typeof ComparisonOperator)[keyof typeof ComparisonOperator];
/**
 * Filter operation for searching/filtering agent data
 */
type FilterOperation = FilterOperation$1;
/**
 * Metadata for an extracted field, including confidence and citation information
 */
interface ExtractedFieldMetadata {
    /** The reasoning for the confidence score */
    reasoning?: string;
    /** The confidence score for the field, combined with parsing confidence if applicable */
    confidence?: number;
    /** The confidence score for the field based on the extracted text only */
    extraction_confidence?: number;
    citation?: FieldCitation[];
}
interface FieldCitation {
    /** The page number that the field occurred on */
    page?: number;
    /** The original text this field's value was derived from */
    matching_text?: string;
}
/**
 * Dictionary mapping field names to their metadata
 * Values can be ExtractedFieldMetadata objects, nested dictionaries, or arrays
 */
type ExtractedFieldMetadataDict = Record<string, ExtractedFieldMetadata | Record<string, unknown> | unknown[]>;
/**
 * Base extracted data interface
 */
interface ExtractedData<T = unknown> {
    /** The original data that was extracted from the document. For tracking changes. Should not be updated. */
    original_data: T;
    /** The latest state of the data. Will differ if data has been updated. */
    data: T;
    /** The status of the extracted data. Prefer to use the StatusType values, but any string is allowed. */
    status: StatusType | string;
    /** The overall confidence score for the extracted data. */
    overall_confidence?: number;
    /** Page links, and perhaps eventually bounding boxes, for individual fields in the extracted data. */
    field_metadata?: ExtractedFieldMetadataDict;
    /** The ID of the file that was used to extract the data. */
    file_id?: string;
    /** The name of the file that was used to extract the data. */
    file_name?: string;
    /** The hash of the file that was used to extract the data. */
    file_hash?: string;
    /** Additional metadata about the extracted data, such as errors, tokens, etc. */
    metadata?: Record<string, unknown>;
}
/**
 * TypedAgentData interface for typed agent data
 */
interface TypedAgentData<T = unknown> {
    /** The unique ID of the agent data record. */
    id: string;
    /** The deployment name of the agent that created the data. */
    deploymentName: string;
    /** The collection of the agent data. */
    collection?: string;
    /** The data of the agent data. Usually an ExtractedData&lt;SomeOtherType&gt; */
    data: T;
    /** The date and time the data was created. */
    createdAt: Date;
    /** The date and time the data was last updated. */
    updatedAt: Date;
}
/**
 * Paginated response of typed agent data items
 */
interface TypedAgentDataItems<T = unknown> {
    items: TypedAgentData<T>[];
    totalSize?: number;
    nextPageToken?: string;
}
/**
 * Options for listing agent data
 */
interface SearchAgentDataOptions {
    /** Filter options for the list. */
    filter?: Record<string, FilterOperation>;
    /** Order by options for the list. */
    orderBy?: string;
    /** Page size for the list. */
    pageSize?: number;
    /** Offset for the list. */
    offset?: number;
    /**
     * Whether to include the total number of items in the response.
     * Should use only for first request to build total pagination, and not subsequent requests.
     */
    includeTotal?: boolean;
}
/**
 * Options for deleting agent data
 */
interface DeleteAgentDataOptions {
    /** Filter options for the deletion. */
    filter?: Record<string, FilterOperation>;
}
/**
 * Options for aggregating agent data
 */
interface AggregateAgentDataOptions {
    /** Filter options for the aggregation. */
    filter?: Record<string, FilterOperation>;
    /** Fields to group by. */
    groupBy?: string[];
    /** Whether to count the number of items in each group. */
    count?: boolean;
    /** Whether to return the first item in each group. */
    first?: boolean;
    /** Order by options for the aggregation. */
    orderBy?: string;
    /** Offset for the aggregation. */
    offset?: number;
    /** Page size for the aggregation. */
    pageSize?: number;
}
/**
 * Single aggregation group result
 */
interface TypedAggregateGroup<T = unknown> {
    /** The group key values */
    groupKey: Record<string, unknown>;
    /** Count of items in the group */
    count?: number;
    /** First item in the group */
    firstItem?: T;
}
/**
 * Paginated response of aggregated agent data
 */
interface TypedAggregateGroupItems<T = unknown> {
    items: TypedAggregateGroup<T>[];
    totalSize?: number;
    nextPageToken?: string;
}

/**
 * Async client for agent data operations
 */
declare class AgentClient<T = unknown> {
    private client;
    private collection;
    private deploymentName;
    constructor({ client, collection, deploymentName, agentUrlId, }: {
        client?: ReturnType<typeof createClient>;
        collection?: string;
        deploymentName?: string;
        agentUrlId?: string;
    });
    /**
     * Create new agent data
     */
    createItem(data: T): Promise<TypedAgentData<T>>;
    /**
     * Get agent data by ID
     */
    getItem(id: string): Promise<TypedAgentData<T> | null>;
    /**
     * Update agent data
     */
    updateItem(id: string, data: T): Promise<TypedAgentData<T>>;
    /**
     * Delete agent data
     */
    deleteItem(id: string): Promise<void>;
    /**
     * Delete all matching agent data, returns the total number of deleted items
     */
    delete(options: DeleteAgentDataOptions): Promise<number>;
    /**
     * Search agent data
     */
    search(options: SearchAgentDataOptions): Promise<TypedAgentDataItems<T>>;
    /**
     * Aggregate agent data into groups
     */
    aggregate(options: AggregateAgentDataOptions): Promise<TypedAggregateGroupItems<T>>;
    /**
     * Transform API response to typed data
     */
    private transformResponse;
    /**
     * Transform API aggregate response to typed data
     */
    private transformAggregateResponse;
}
/**
 * Create a new AsyncAgentDataClient instance. Does it's best to infer an agent url id from environment.
 * Pass in the window url and/or env to infer the agent url id from them.
 * @param options - The options for the client
 * @returns A new AgentClient instance
 */
declare function createAgentDataClient<T = unknown>({ client, windowUrl, env, deploymentName, agentUrlId, collection, }?: {
    client?: ReturnType<typeof createClient>;
    windowUrl?: string;
    env?: Record<string, string>;
    deploymentName?: string;
    agentUrlId?: string;
    collection?: string;
}): AgentClient<T>;

export { AgentClient, ComparisonOperator, StatusType, StatusType as StatusTypeEnum, createAgentDataClient };
export type { AggregateAgentDataOptions, ExtractedData, ExtractedFieldMetadata, ExtractedFieldMetadataDict, FilterOperation, SearchAgentDataOptions, TypedAgentData, TypedAgentDataItems, TypedAggregateGroup, TypedAggregateGroupItems };
