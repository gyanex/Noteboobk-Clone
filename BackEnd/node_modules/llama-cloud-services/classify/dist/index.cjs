Object.defineProperty(exports, '__esModule', { value: true });

var index_cjs = require('../../api/dist/index.cjs');
require('@llamaindex/core/global');
var env = require('@llamaindex/env');
require('fs');
var path = require('path');
var fs = require('fs/promises');
var buffer = require('buffer');
var fileType = require('file-type');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return n;
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__default = /*#__PURE__*/_interopDefault(fs);

async function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}

function textToFile(text, fileName = null) {
    return new buffer.File([
        text
    ], fileName ?? "uploadedFile_" + env.randomUUID().replaceAll("-", "_") + ".txt");
}
async function uploadFile(filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    let file = undefined;
    if (typeof filePath === "undefined" && typeof fileContent === "undefined") {
        throw new Error("One between filePath and fileContent needs to be provided");
    } else if (typeof filePath != "undefined") {
        const buffer$1 = await fs__default.default.readFile(filePath);
        const actualFileName = fileName ?? path__namespace.basename(filePath);
        const uint8Array = new Uint8Array(buffer$1);
        file = new buffer.File([
            uint8Array
        ], actualFileName);
    } else if (typeof fileContent != "undefined") {
        if (fileContent instanceof buffer.File) {
            file = fileContent;
        } else if (fileContent instanceof Buffer) {
            const fileType$1 = await fileType.fileTypeFromBuffer(fileContent);
            const ext = fileType$1?.ext ?? "pdf";
            const uint8Array = new Uint8Array(fileContent);
            file = new buffer.File([
                uint8Array
            ], fileName ?? "uploadedFile_" + env.randomUUID().replaceAll("-", "_") + "." + ext);
        } else if (fileContent instanceof Uint8Array) {
            const fileType$1 = await fileType.fileTypeFromBuffer(fileContent);
            const ext = fileType$1?.ext ?? "pdf";
            file = new buffer.File([
                fileContent
            ], fileName ?? "uploadedFile_" + env.randomUUID().replaceAll("-", "_") + "." + ext);
        } else if (typeof fileContent === "string") {
            file = textToFile(fileContent, fileName);
        } else {
            throw new Error("Unsupported fileContent type");
        }
    }
    const fileToUpload = {
        upload_file: file
    };
    const uploadData = {
        body: fileToUpload,
        query: {
            organization_id: organization_id,
            project_id: project_id
        }
    };
    const uploadOptions = uploadData;
    if (typeof client != "undefined") {
        uploadOptions.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while processing your file: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const uploadResponse = await index_cjs.uploadFileApiV1FilesPost(uploadOptions);
        let fileId = undefined;
        if (!uploadResponse.response.ok) {
            retries++;
            await sleep(retryInterval * 1000);
        }
        if (uploadResponse.response.ok && typeof uploadResponse.data != "undefined") {
            fileId = uploadResponse.data.id;
            return fileId;
        }
    }
}

async function createClassifyJob(fileIds, rules, parsingConfiguration, organizationId, projectId, client, maxRetriesOnError = 10, retryInterval = 0.5) {
    const rawData = {
        file_ids: fileIds,
        rules: rules,
        parsing_configuration: parsingConfiguration
    };
    const data = {
        body: rawData,
        query: {
            project_id: projectId,
            organization_id: organizationId
        }
    };
    const options = data;
    if (typeof client != "undefined") {
        options.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while creating the classify job: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const response = await index_cjs.createClassifyJobApiV1ClassifierJobsPost(options);
        if (!response.response.ok) {
            if ("error" in response) {
                console.log(`An error occurred while creating the classification job.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
            }
            retries++;
            await sleep(retryInterval * 1000);
        } else {
            if (typeof response.data != "undefined") {
                return response.data.id;
            } else {
                throw new Error("Error while creating the classify job: the job creation succeeded but no data where returned");
            }
        }
    }
}
async function pollForJobCompletion(jobId, interval = 1, maxIterations = 1800, client = undefined) {
    let status = undefined;
    const jobData = {
        path: {
            classify_job_id: jobId
        }
    };
    const jobOptions = jobData;
    if (typeof client != "undefined") {
        jobOptions.client = client;
    }
    let numIterations = 0;
    while(true){
        if (numIterations > maxIterations) {
            return false;
        }
        const response = await index_cjs.getClassifyJobApiV1ClassifierJobsClassifyJobIdGet(jobOptions);
        if (!response.response.ok) {
            numIterations++;
        }
        if (typeof response.data != "undefined") {
            status = response.data.status;
            if (status == index_cjs.StatusEnum.CANCELLED || status == index_cjs.StatusEnum.ERROR) {
                throw new Error("There was an error during the classification job.");
            } else if (status == index_cjs.StatusEnum.SUCCESS) {
                return true;
            } else {
                numIterations++;
                await sleep(interval * 1000);
            }
        }
    }
}
async function getJobResult(jobId, client = undefined, projectId = null, organizationId = null, maxRetriesOnError = 10, retryInterval = 0.5) {
    const jobData = {
        path: {
            classify_job_id: jobId
        },
        query: {
            organization_id: organizationId,
            project_id: projectId
        }
    };
    const jobOptions = jobData;
    if (typeof client != "undefined") {
        jobOptions.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while getting the result of the classification job: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const response = await index_cjs.getClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGet(jobOptions);
        if (!response.response.ok) {
            if ("error" in response) {
                console.log("An error occurred: ", JSON.stringify(response.error), "\nRetrying...");
            }
            retries++;
            await sleep(retryInterval * 1000);
        }
        if (typeof response.data != "undefined") {
            return response.data;
        } else {
            throw new Error("Error while retrieving results for the classify job: the result was successfully obtained but no data were returned");
        }
    }
}
async function classify(rules, parsingConfiguration, fileContents = undefined, filePaths = undefined, projectId = null, organizationId = null, client = undefined, pollingInterval = 1, maxPollingIterations = 1800, maxRetriesOnError = 10, retryInterval = 0.5) {
    const fileIds = [];
    if (!filePaths && !fileContents) {
        throw new Error("One between filePath and fileContent needs to be provided");
    }
    if (filePaths) {
        const uploadPromises = filePaths.map(async (name)=>{
            try {
                const fileId = await uploadFile(name, undefined, undefined, projectId, organizationId, client, maxRetriesOnError, retryInterval);
                if (fileId) {
                    return fileId;
                } else {
                    console.error(`Unable to upload ${name}, skipping...`);
                    return null;
                }
            } catch (error) {
                console.error(`Error uploading ${name}:`, error);
                return null;
            }
        });
        const results = await Promise.all(uploadPromises);
        fileIds.push(...results.filter((id)=>id !== null));
    }
    if (fileContents) {
        const uploadPromises = fileContents.map(async (content)=>{
            try {
                const fileId = await uploadFile(undefined, content, undefined, projectId, organizationId, client, maxRetriesOnError, retryInterval);
                if (fileId) {
                    return fileId;
                } else {
                    console.error(`Unable to upload file (content), skipping...`);
                    return null;
                }
            } catch (error) {
                console.error(`Error uploading file (content):`, error);
                return null;
            }
        });
        const results = await Promise.all(uploadPromises);
        fileIds.push(...results.filter((id)=>id !== null));
    }
    if (fileIds.length == 0) {
        throw new Error("None of the provided files was successfully uploaded, it is not possible to create a classification job.");
    }
    const jobId = await createClassifyJob(fileIds, rules, parsingConfiguration, organizationId, projectId, client, maxRetriesOnError, retryInterval);
    const success = await pollForJobCompletion(jobId, pollingInterval, maxPollingIterations, client);
    if (!success) {
        throw new Error("Your job is taking longer than 10 minutes, timing out...");
    } else {
        return await getJobResult(jobId, client, projectId, organizationId, maxRetriesOnError, retryInterval);
    }
}

exports.classify = classify;
