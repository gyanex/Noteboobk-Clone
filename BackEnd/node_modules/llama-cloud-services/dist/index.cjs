Object.defineProperty(exports, '__esModule', { value: true });

var index_cjs$1 = require('../api/dist/index.cjs');
var global = require('@llamaindex/core/global');
var env = require('@llamaindex/env');
require('fs');
require('path');
var queryEngine = require('@llamaindex/core/query-engine');
var retriever = require('@llamaindex/core/retriever');
var schema = require('@llamaindex/core/schema');
var utils = require('@llamaindex/core/utils');
var tools = require('@llamaindex/core/tools');
var zod = require('zod');
var index_cjs = require('../reader/dist/index.cjs');
var extract = require('../extract/dist/index.cjs');
var index_cjs$2 = require('../classify/dist/index.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return n;
}

var extract__namespace = /*#__PURE__*/_interopNamespace(extract);

function getBaseUrl(baseUrl) {
    return baseUrl ?? env.getEnv("LLAMA_CLOUD_BASE_URL") ?? global.DEFAULT_BASE_URL;
}
function getAppBaseUrl() {
    return index_cjs$1.client.getConfig().baseUrl?.replace(/api\./, "") ?? "";
}
// fixme: refactor this to init at the top level or module level
let initOnce = false;
function initService({ apiKey, baseUrl } = {}) {
    if (initOnce) {
        return;
    }
    initOnce = true;
    index_cjs$1.client.setConfig({
        baseUrl: getBaseUrl(baseUrl),
        throwOnError: true
    });
    const token = apiKey ?? env.getEnv("LLAMA_CLOUD_API_KEY");
    index_cjs$1.client.interceptors.request.use((request)=>{
        request.headers.set("Authorization", `Bearer ${token}`);
        return request;
    });
    index_cjs$1.client.interceptors.error.use((error)=>{
        throw new Error(`LlamaCloud API request failed. Error details: ${JSON.stringify(error)}`);
    });
    if (!token) {
        throw new Error("API Key is required for LlamaCloudIndex. Please pass the apiKey parameter");
    }
}
async function getProjectId(projectName, organizationId) {
    const { data: projects } = await index_cjs$1.listProjectsApiV1ProjectsGet({
        query: {
            project_name: projectName,
            organization_id: organizationId ?? null
        },
        throwOnError: true
    });
    if (projects.length === 0) {
        throw new Error(`Unknown project name ${projectName}. Please confirm a managed project with this name exists.`);
    } else if (projects.length > 1) {
        throw new Error(`Multiple projects found with name ${projectName}. Please specify organization_id.`);
    }
    const project = projects[0];
    if (!project.id) {
        throw new Error(`No project found with name ${projectName}`);
    }
    return project.id;
}
async function getPipelineId(name, projectName, organizationId) {
    const { data: pipelines } = await index_cjs$1.searchPipelinesApiV1PipelinesGet({
        query: {
            project_id: await getProjectId(projectName, organizationId),
            pipeline_name: name
        },
        throwOnError: true
    });
    if (pipelines.length === 0 || !pipelines[0].id) {
        throw new Error(`No pipeline found with name ${name} in project ${projectName}`);
    }
    return pipelines[0].id;
}
const URLS = {
    us: "https://api.cloud.llamaindex.ai",
    eu: "https://api.cloud.eu.llamaindex.ai",
    "us-staging": "https://api.staging.llamaindex.ai"
};
function getUrl(baseUrl, region) {
    if (typeof baseUrl != "undefined") {
        return baseUrl;
    }
    if (typeof region === "undefined") {
        return URLS["us"];
    } else if (region === "us" || region === "eu" || region === "us-staging") {
        return URLS[region];
    } else {
        throw new Error(`Unsupported region: ${region}`);
    }
}

class LLamaCloudFileService {
    /**
   * Get list of projects, each project contains a list of pipelines
   */ static async getAllProjectsWithPipelines() {
        initService();
        try {
            const { data: projects } = await index_cjs$1.listProjectsApiV1ProjectsGet({
                throwOnError: true
            });
            const { data: pipelines } = await index_cjs$1.searchPipelinesApiV1PipelinesGet({
                throwOnError: true
            });
            return projects.map((project)=>({
                    ...project,
                    pipelines: pipelines.filter((p)=>p.project_id === project.id)
                }));
        } catch (error) {
            console.error("Error listing projects and pipelines:", error);
            return [];
        }
    }
    /**
   * Upload a file to a pipeline in LlamaCloud
   */ static async addFileToPipeline(projectId, pipelineId, uploadFile, // eslint-disable-next-line @typescript-eslint/no-explicit-any
    customMetadata = {}) {
        initService();
        const { data: file } = await index_cjs$1.uploadFileApiV1FilesPost({
            query: {
                project_id: projectId
            },
            body: {
                upload_file: uploadFile
            },
            throwOnError: true
        });
        const files = [
            {
                file_id: file.id,
                custom_metadata: {
                    file_id: file.id,
                    ...customMetadata
                }
            }
        ];
        await index_cjs$1.addFilesToPipelineApiApiV1PipelinesPipelineIdFilesPut({
            path: {
                pipeline_id: pipelineId
            },
            body: files
        });
        // Wait 2s for the file to be processed
        const maxAttempts = 20;
        let attempt = 0;
        while(attempt < maxAttempts){
            const { data: result } = await index_cjs$1.getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet({
                path: {
                    pipeline_id: pipelineId,
                    file_id: file.id
                },
                throwOnError: true
            });
            if (result.status === "ERROR") {
                throw new Error(`File processing failed: ${JSON.stringify(result)}`);
            }
            if (result.status === "SUCCESS") {
                // File is ingested - return the file id
                return file.id;
            }
            attempt += 1;
            await new Promise((resolve)=>setTimeout(resolve, 100)); // Sleep for 100ms
        }
        throw new Error(`File processing did not complete after ${maxAttempts} attempts. Check your LlamaCloud index at https://cloud.llamaindex.ai/project/${projectId}/deploy/${pipelineId} for more details.`);
    }
    /**
   * Get download URL for a file in LlamaCloud
   */ static async getFileUrl(pipelineId, filename) {
        initService();
        const { data: allPipelineFiles } = await index_cjs$1.listPipelineFilesApiV1PipelinesPipelineIdFilesGet({
            path: {
                pipeline_id: pipelineId
            },
            throwOnError: true
        });
        const file = allPipelineFiles.find((file)=>file.name === filename);
        if (!file?.file_id) return null;
        const { data: fileContent } = await index_cjs$1.readFileContentApiV1FilesIdContentGet({
            path: {
                id: file.file_id
            },
            query: {
                project_id: file.project_id
            },
            throwOnError: true
        });
        return fileContent.url;
    }
}

class LlamaCloudRetriever extends retriever.BaseRetriever {
    resultNodesToNodeWithScore(nodes) {
        return nodes.map((node)=>{
            const textNode = schema.jsonToNode(node.node, schema.ObjectType.TEXT);
            textNode.metadata = {
                ...textNode.metadata,
                ...node.node.extra_info
            };
            return {
                // Currently LlamaCloud only supports text nodes
                node: textNode,
                score: node.score ?? undefined
            };
        });
    }
    async fetchBase64FromPresignedUrl(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Failed to fetch media from presigned URL: ${response.status} ${response.statusText}`);
        }
        const buffer = Buffer.from(await response.arrayBuffer());
        return buffer.toString("base64");
    }
    async pageScreenshotNodesToNodeWithScore(nodes, projectId) {
        if (!nodes || nodes.length === 0) return [];
        const results = await Promise.all(nodes.map(async (n)=>{
            const { data: presigned } = await index_cjs$1.generateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPost({
                throwOnError: true,
                path: {
                    id: n.node.file_id,
                    page_index: n.node.page_index
                },
                query: {
                    project_id: projectId,
                    organization_id: this.organizationId ?? null
                }
            });
            const base64 = await this.fetchBase64FromPresignedUrl(presigned.url);
            const imageNode = new schema.ImageNode({
                image: base64,
                metadata: {
                    ...n.node.metadata ?? {},
                    file_id: n.node.file_id,
                    page_index: n.node.page_index
                }
            });
            return {
                node: imageNode,
                score: n.score
            };
        }));
        return results;
    }
    async pageFigureNodesToNodeWithScore(nodes, projectId) {
        if (!nodes || nodes.length === 0) return [];
        const results = await Promise.all(nodes.map(async (n)=>{
            const { data: presigned } = await index_cjs$1.generateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPost({
                throwOnError: true,
                path: {
                    id: n.node.file_id,
                    page_index: n.node.page_index,
                    figure_name: n.node.figure_name
                },
                query: {
                    project_id: projectId,
                    organization_id: this.organizationId ?? null
                }
            });
            const base64 = await this.fetchBase64FromPresignedUrl(presigned.url);
            const imageNode = new schema.ImageNode({
                image: base64,
                metadata: {
                    ...n.node.metadata ?? {},
                    file_id: n.node.file_id,
                    page_index: n.node.page_index,
                    figure_name: n.node.figure_name
                }
            });
            return {
                node: imageNode,
                score: n.score
            };
        }));
        return results;
    }
    // LlamaCloud expects null values for filters, but LlamaIndexTS uses undefined for empty values
    // This function converts the undefined values to null
    convertFilter(filters) {
        if (!filters) return null;
        const processFilter = (filter)=>{
            if ("filters" in filter) {
                // type MetadataFilters
                return {
                    ...filter,
                    filters: filter.filters.map(processFilter)
                };
            }
            return {
                ...filter,
                value: filter.value ?? null
            };
        };
        return {
            ...filters,
            filters: filters.filters.map(processFilter)
        };
    }
    constructor(params){
        super(), this.projectName = global.DEFAULT_PROJECT_NAME;
        this.clientParams = {
            apiKey: params.apiKey,
            baseUrl: params.baseUrl
        };
        initService(this.clientParams);
        this.retrieveParams = params;
        this.pipelineName = params.name;
        if (params.projectName) {
            this.projectName = params.projectName;
        }
        if (params.organizationId) {
            this.organizationId = params.organizationId;
        }
    }
    async _retrieve(query) {
        // Handle deprecated image retrieval flag
        const retrieveImageNodes = this.retrieveParams.retrieve_image_nodes;
        if (typeof retrieveImageNodes !== "undefined") {
            console.warn("The `retrieve_image_nodes` parameter is deprecated. Use `retrieve_page_screenshot_nodes` and `retrieve_page_figure_nodes` instead.");
        }
        const retrievePageScreenshotNodes = this.retrieveParams.retrieve_page_screenshot_nodes;
        const retrievePageFigureNodes = this.retrieveParams.retrieve_page_figure_nodes;
        if (retrieveImageNodes) {
            if (retrievePageScreenshotNodes === false || retrievePageFigureNodes === false) {
                throw new Error("If `retrieve_image_nodes` is set to true, both `retrieve_page_screenshot_nodes` and `retrieve_page_figure_nodes` must also be set to true or omitted.");
            }
            this.retrieveParams.retrieve_page_screenshot_nodes = true;
            this.retrieveParams.retrieve_page_figure_nodes = true;
        }
        const pipelineId = await getPipelineId(this.pipelineName, this.projectName, this.organizationId);
        const filters = this.convertFilter(this.retrieveParams.filters);
        const { data: results } = await index_cjs$1.runSearchApiV1PipelinesPipelineIdRetrievePost({
            throwOnError: true,
            path: {
                pipeline_id: pipelineId
            },
            body: {
                ...this.retrieveParams,
                query: utils.extractText(query),
                search_filters: filters,
                dense_similarity_top_k: this.retrieveParams.similarityTopK
            }
        });
        const textNodes = this.resultNodesToNodeWithScore(results.retrieval_nodes);
        const needScreenshots = this.retrieveParams.retrieve_page_screenshot_nodes;
        const needFigures = this.retrieveParams.retrieve_page_figure_nodes;
        if (!needScreenshots && !needFigures) {
            return textNodes;
        }
        const projectId = await getProjectId(this.projectName, this.organizationId);
        const [screenshotNodes, figureNodes] = await Promise.all([
            needScreenshots ? this.pageScreenshotNodesToNodeWithScore(results.image_nodes, projectId) : Promise.resolve([]),
            needFigures ? this.pageFigureNodesToNodeWithScore(results.page_figure_nodes, projectId) : Promise.resolve([])
        ]);
        return [
            ...textNodes,
            ...screenshotNodes,
            ...figureNodes
        ];
    }
}

const DEFAULT_NAME = "llama_cloud_index_tool";
const DEFAULT_DESCRIPTION = "Useful for retrieving relevant information from document stored in a LlamaCloud Index";
function createQueryEngineTool(options) {
    const { queryEngine, metadata, includeSourceNodes } = options;
    return tools.tool({
        name: metadata?.name ?? DEFAULT_NAME,
        description: metadata?.description ?? DEFAULT_DESCRIPTION,
        parameters: zod.z.object({
            query: zod.z.string({
                description: "The query to search for"
            })
        }),
        execute: async ({ query })=>{
            const response = await queryEngine.query({
                query
            });
            if (!includeSourceNodes) {
                return {
                    content: response.message.content
                };
            }
            return {
                content: response.message.content,
                sourceNodes: response.sourceNodes
            };
        }
    });
}

class LlamaCloudIndex {
    constructor(params){
        this.params = params;
        initService(this.params);
    }
    async waitForPipelineIngestion(verbose = false, raiseOnError = false) {
        const pipelineId = await this.getPipelineId();
        if (verbose) {
            console.log("Waiting for pipeline ingestion: ");
        }
        while(true){
            const { data: pipelineStatus } = await index_cjs$1.getPipelineStatusApiV1PipelinesPipelineIdStatusGet({
                path: {
                    pipeline_id: pipelineId
                },
                throwOnError: true
            });
            if (pipelineStatus.status === "SUCCESS") {
                if (verbose) {
                    console.log("Pipeline ingestion completed successfully");
                }
                break;
            }
            if (pipelineStatus.status === "ERROR") {
                if (verbose) {
                    console.error("Pipeline ingestion failed");
                }
                if (raiseOnError) {
                    throw new Error("Pipeline ingestion failed");
                }
            }
            if (verbose) {
                process.stdout.write(".");
            }
            await new Promise((resolve)=>setTimeout(resolve, 1000));
        }
    }
    async waitForDocumentIngestion(docIds, verbose = false, raiseOnError = false) {
        const pipelineId = await this.getPipelineId();
        if (verbose) {
            console.log("Loading data: ");
        }
        const pendingDocs = new Set(docIds);
        while(pendingDocs.size){
            const docsToRemove = new Set();
            for (const doc of pendingDocs){
                const { data: { status } } = await index_cjs$1.getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet({
                    path: {
                        pipeline_id: pipelineId,
                        document_id: doc
                    },
                    throwOnError: true
                });
                if (status === "NOT_STARTED" || status === "IN_PROGRESS") {
                    continue;
                }
                if (status === "ERROR") {
                    if (verbose) {
                        console.error(`Document ingestion failed for ${doc}`);
                    }
                    if (raiseOnError) {
                        throw new Error(`Document ingestion failed for ${doc}`);
                    }
                }
                docsToRemove.add(doc);
            }
            for (const doc of docsToRemove){
                pendingDocs.delete(doc);
            }
            if (pendingDocs.size) {
                if (verbose) {
                    process.stdout.write(".");
                }
                await new Promise((resolve)=>setTimeout(resolve, 500));
            }
        }
        if (verbose) {
            console.log("Done!");
        }
        await this.waitForPipelineIngestion(verbose, raiseOnError);
    }
    async getPipelineId(name, projectName, organizationId) {
        return await getPipelineId(name ?? this.params.name, projectName ?? this.params.projectName, organizationId ?? this.params.organizationId);
    }
    async getProjectId(projectName, organizationId) {
        return await getProjectId(projectName ?? this.params.projectName, organizationId ?? this.params.organizationId);
    }
    /**
   * Adds documents to the given index parameters. If the index does not exist, it will be created.
   *
   * @param params - An object containing the following properties:
   *   - documents: An array of Document objects to be added to the index.
   *   - verbose: Optional boolean to enable verbose logging.
   *   - Additional properties from CloudConstructorParams.
   * @returns A Promise that resolves to a new LlamaCloudIndex instance.
   */ static async fromDocuments(params, config) {
        const index = new LlamaCloudIndex({
            ...params
        });
        await index.ensureIndex({
            ...config,
            verbose: params.verbose ?? false
        });
        await index.addDocuments(params.documents, params.verbose);
        return index;
    }
    async addDocuments(documents, verbose) {
        const apiUrl = getAppBaseUrl();
        const projectId = await this.getProjectId();
        const pipelineId = await this.getPipelineId();
        await index_cjs$1.upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut({
            path: {
                pipeline_id: pipelineId
            },
            body: documents.map((doc)=>({
                    metadata: doc.metadata,
                    text: doc.text,
                    excluded_embed_metadata_keys: doc.excludedEmbedMetadataKeys,
                    excluded_llm_metadata_keys: doc.excludedEmbedMetadataKeys,
                    id: doc.id_
                }))
        });
        while(true){
            const { data: pipelineStatus } = await index_cjs$1.getPipelineStatusApiV1PipelinesPipelineIdStatusGet({
                path: {
                    pipeline_id: pipelineId
                },
                throwOnError: true
            });
            if (pipelineStatus.status === "SUCCESS") {
                console.info("Documents ingested successfully, pipeline is ready to use");
                break;
            }
            if (pipelineStatus.status === "ERROR") {
                console.error(`Some documents failed to ingest, check your pipeline logs at ${apiUrl}/project/${projectId}/deploy/${pipelineId}`);
                throw new Error("Some documents failed to ingest");
            }
            if (pipelineStatus.status === "PARTIAL_SUCCESS") {
                console.info(`Documents ingestion partially succeeded, to check a more complete status check your pipeline at ${apiUrl}/project/${projectId}/deploy/${pipelineId}`);
                break;
            }
            if (verbose) {
                process.stdout.write(".");
            }
            await new Promise((resolve)=>setTimeout(resolve, 1000));
        }
        if (verbose) {
            console.info(`Ingestion completed, find your index at ${apiUrl}/project/${projectId}/deploy/${pipelineId}`);
        }
    }
    asRetriever(params = {}) {
        return new LlamaCloudRetriever({
            ...this.params,
            ...params
        });
    }
    asQueryEngine(params) {
        const retriever = new LlamaCloudRetriever({
            ...this.params,
            ...params
        });
        return new queryEngine.RetrieverQueryEngine(retriever, params?.responseSynthesizer, params?.nodePostprocessors);
    }
    asQueryTool(params) {
        return createQueryEngineTool({
            queryEngine: this.asQueryEngine(params),
            metadata: params?.metadata,
            includeSourceNodes: params?.includeSourceNodes ?? false
        });
    }
    queryTool(params) {
        return this.asQueryTool(params);
    }
    async insert(document) {
        const pipelineId = await this.getPipelineId();
        await index_cjs$1.createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost({
            path: {
                pipeline_id: pipelineId
            },
            body: [
                {
                    metadata: document.metadata,
                    text: document.text,
                    excluded_embed_metadata_keys: document.excludedLlmMetadataKeys,
                    excluded_llm_metadata_keys: document.excludedEmbedMetadataKeys,
                    id: document.id_
                }
            ]
        });
        await this.waitForDocumentIngestion([
            document.id_
        ]);
    }
    async delete(document) {
        const pipelineId = await this.getPipelineId();
        await index_cjs$1.deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete({
            path: {
                pipeline_id: pipelineId,
                document_id: document.id_
            }
        });
        await this.waitForPipelineIngestion();
    }
    async refreshDoc(document) {
        const pipelineId = await this.getPipelineId();
        await index_cjs$1.upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut({
            path: {
                pipeline_id: pipelineId
            },
            body: [
                {
                    metadata: document.metadata,
                    text: document.text,
                    excluded_embed_metadata_keys: document.excludedLlmMetadataKeys,
                    excluded_llm_metadata_keys: document.excludedEmbedMetadataKeys,
                    id: document.id_
                }
            ]
        });
        await this.waitForDocumentIngestion([
            document.id_
        ]);
    }
    async ensureIndex(config) {
        const projectId = await this.getProjectId();
        const { data: pipelines } = await index_cjs$1.searchPipelinesApiV1PipelinesGet({
            query: {
                project_id: projectId,
                pipeline_name: this.params.name
            },
            throwOnError: true
        });
        if (pipelines.length === 0) {
            // no pipeline found, create a new one
            let embeddingConfig = config?.embedding;
            if (!embeddingConfig) {
                // no embedding config provided, use OpenAI as default
                const openAIApiKey = env.getEnv("OPENAI_API_KEY");
                const embeddingModel = env.getEnv("EMBEDDING_MODEL");
                if (!openAIApiKey || !embeddingModel) {
                    throw new Error("No embedding configuration provided. Fallback to OpenAI embedding model. OPENAI_API_KEY and EMBEDDING_MODEL environment variables must be set.");
                }
                embeddingConfig = {
                    type: "OPENAI_EMBEDDING",
                    component: {
                        api_key: openAIApiKey,
                        model_name: embeddingModel
                    }
                };
            }
            let transformConfig = config?.transform;
            if (!transformConfig) {
                transformConfig = {
                    mode: "auto",
                    chunk_size: 1024,
                    chunk_overlap: 200
                };
            }
            const { data: pipeline } = await index_cjs$1.upsertPipelineApiV1PipelinesPut({
                query: {
                    project_id: projectId
                },
                body: {
                    name: this.params.name,
                    embedding_config: embeddingConfig,
                    transform_config: transformConfig
                },
                throwOnError: true
            });
            if (config?.verbose) {
                console.log(`Created pipeline ${pipeline.id} with name ${pipeline.name}`);
            }
        }
    }
}

var j = async (t, r)=>{
    let e = typeof r == "function" ? await r(t) : r;
    if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
}, R = {
    bodySerializer: (t)=>JSON.stringify(t, (r, e)=>typeof e == "bigint" ? e.toString() : e)
}, U = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, _ = (t)=>{
    switch(t){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
}, D = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, O = ({ allowReserved: t, explode: r, name: e, style: i, value: a })=>{
    if (!r) {
        let n = (t ? a : a.map((l)=>encodeURIComponent(l))).join(_(i));
        switch(i){
            case "label":
                return `.${n}`;
            case "matrix":
                return `;${e}=${n}`;
            case "simple":
                return n;
            default:
                return `${e}=${n}`;
        }
    }
    let o = U(i), s = a.map((n)=>i === "label" || i === "simple" ? t ? n : encodeURIComponent(n) : y({
            allowReserved: t,
            name: e,
            value: n
        })).join(o);
    return i === "label" || i === "matrix" ? o + s : s;
}, y = ({ allowReserved: t, name: r, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${r}=${t ? e : encodeURIComponent(e)}`;
}, q = ({ allowReserved: t, explode: r, name: e, style: i, value: a })=>{
    if (a instanceof Date) return `${e}=${a.toISOString()}`;
    if (i !== "deepObject" && !r) {
        let n = [];
        Object.entries(a).forEach(([f, p])=>{
            n = [
                ...n,
                f,
                t ? p : encodeURIComponent(p)
            ];
        });
        let l = n.join(",");
        switch(i){
            case "form":
                return `${e}=${l}`;
            case "label":
                return `.${l}`;
            case "matrix":
                return `;${e}=${l}`;
            default:
                return l;
        }
    }
    let o = D(i), s = Object.entries(a).map(([n, l])=>y({
            allowReserved: t,
            name: i === "deepObject" ? `${e}[${n}]` : n,
            value: l
        })).join(o);
    return i === "label" || i === "matrix" ? o + s : s;
};
var H = /\{[^{}]+\}/g, B = ({ path: t, url: r })=>{
    let e = r, i = r.match(H);
    if (i) for (let a of i){
        let o = false, s = a.substring(1, a.length - 1), n = "simple";
        s.endsWith("*") && (o = true, s = s.substring(0, s.length - 1)), s.startsWith(".") ? (s = s.substring(1), n = "label") : s.startsWith(";") && (s = s.substring(1), n = "matrix");
        let l = t[s];
        if (l == null) continue;
        if (Array.isArray(l)) {
            e = e.replace(a, O({
                explode: o,
                name: s,
                style: n,
                value: l
            }));
            continue;
        }
        if (typeof l == "object") {
            e = e.replace(a, q({
                explode: o,
                name: s,
                style: n,
                value: l
            }));
            continue;
        }
        if (n === "matrix") {
            e = e.replace(a, `;${y({
                name: s,
                value: l
            })}`);
            continue;
        }
        let f = encodeURIComponent(n === "label" ? `.${l}` : l);
        e = e.replace(a, f);
    }
    return e;
}, A = ({ allowReserved: t, array: r, object: e } = {})=>(a)=>{
        let o = [];
        if (a && typeof a == "object") for(let s in a){
            let n = a[s];
            if (n != null) if (Array.isArray(n)) {
                let l = O({
                    allowReserved: t,
                    explode: true,
                    name: s,
                    style: "form",
                    value: n,
                    ...r
                });
                l && o.push(l);
            } else if (typeof n == "object") {
                let l = q({
                    allowReserved: t,
                    explode: true,
                    name: s,
                    style: "deepObject",
                    value: n,
                    ...e
                });
                l && o.push(l);
            } else {
                let l = y({
                    allowReserved: t,
                    name: s,
                    value: n
                });
                l && o.push(l);
            }
        }
        return o.join("&");
    }, P = (t)=>{
    if (!t) return "stream";
    let r = t.split(";")[0]?.trim();
    if (r) {
        if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
        if (r === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((e)=>r.startsWith(e))) return "blob";
        if (r.startsWith("text/")) return "text";
    }
}, E = async ({ security: t, ...r })=>{
    for (let e of t){
        let i = await j(e, r.auth);
        if (!i) continue;
        let a = e.name ?? "Authorization";
        switch(e.in){
            case "query":
                r.query || (r.query = {}), r.query[a] = i;
                break;
            case "cookie":
                r.headers.append("Cookie", `${a}=${i}`);
                break;
            case "header":
            default:
                r.headers.set(a, i);
                break;
        }
        return;
    }
}, S = (t)=>W({
        baseUrl: t.baseUrl,
        path: t.path,
        query: t.query,
        querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : A(t.querySerializer),
        url: t.url
    }), W = ({ baseUrl: t, path: r, query: e, querySerializer: i, url: a })=>{
    let o = a.startsWith("/") ? a : `/${a}`, s = (t ?? "") + o;
    r && (s = B({
        path: r,
        url: s
    }));
    let n = e ? i(e) : "";
    return n.startsWith("?") && (n = n.substring(1)), n && (s += `?${n}`), s;
}, x = (t, r)=>{
    let e = {
        ...t,
        ...r
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = C(t.headers, r.headers), e;
}, C = (...t)=>{
    let r = new Headers;
    for (let e of t){
        if (!e || typeof e != "object") continue;
        let i = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [a, o] of i)if (o === null) r.delete(a);
        else if (Array.isArray(o)) for (let s of o)r.append(a, s);
        else o !== void 0 && r.set(a, typeof o == "object" ? JSON.stringify(o) : o);
    }
    return r;
}, h = class {
    constructor(){
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    getInterceptorIndex(r) {
        return typeof r == "number" ? this._fns[r] ? r : -1 : this._fns.indexOf(r);
    }
    exists(r) {
        let e = this.getInterceptorIndex(r);
        return !!this._fns[e];
    }
    eject(r) {
        let e = this.getInterceptorIndex(r);
        this._fns[e] && (this._fns[e] = null);
    }
    update(r, e) {
        let i = this.getInterceptorIndex(r);
        return this._fns[i] ? (this._fns[i] = e, r) : false;
    }
    use(r) {
        return this._fns = [
            ...this._fns,
            r
        ], this._fns.length - 1;
    }
}, v = ()=>({
        error: new h,
        request: new h,
        response: new h
    }), N = A({
    allowReserved: false,
    array: {
        explode: true,
        style: "form"
    },
    object: {
        explode: true,
        style: "deepObject"
    }
}), Q = {
    "Content-Type": "application/json"
}, w = (t = {})=>({
        ...R,
        headers: Q,
        parseAs: "auto",
        querySerializer: N,
        ...t
    });
var J = (t = {})=>{
    let r = x(w(), t), e = ()=>({
            ...r
        }), i = (s)=>(r = x(r, s), e()), a = v(), o = async (s)=>{
        let n = {
            ...r,
            ...s,
            fetch: s.fetch ?? r.fetch ?? globalThis.fetch,
            headers: C(r.headers, s.headers)
        };
        n.security && await E({
            ...n,
            security: n.security
        }), n.body && n.bodySerializer && (n.body = n.bodySerializer(n.body)), (n.body === void 0 || n.body === "") && n.headers.delete("Content-Type");
        let l = S(n), f = {
            redirect: "follow",
            ...n
        }, p = new Request(l, f);
        for (let c of a.request._fns)c && (p = await c(p, n));
        let T = n.fetch, u = await T(p);
        for (let c of a.response._fns)c && (u = await c(u, p, n));
        let m = {
            request: p,
            response: u
        };
        if (u.ok) {
            if (u.status === 204 || u.headers.get("Content-Length") === "0") return {
                data: {},
                ...m
            };
            let c = (n.parseAs === "auto" ? P(u.headers.get("Content-Type")) : n.parseAs) ?? "json";
            if (c === "stream") return {
                data: u.body,
                ...m
            };
            let b = await u[c]();
            return c === "json" && (n.responseValidator && await n.responseValidator(b), n.responseTransformer && (b = await n.responseTransformer(b))), {
                data: b,
                ...m
            };
        }
        let g = await u.text();
        try {
            g = JSON.parse(g);
        } catch  {}
        let d = g;
        for (let c of a.error._fns)c && (d = await c(g, u, p, n));
        if (d = d || {}, n.throwOnError) throw d;
        return {
            error: d,
            ...m
        };
    };
    return {
        buildUrl: S,
        connect: (s)=>o({
                ...s,
                method: "CONNECT"
            }),
        delete: (s)=>o({
                ...s,
                method: "DELETE"
            }),
        get: (s)=>o({
                ...s,
                method: "GET"
            }),
        getConfig: e,
        head: (s)=>o({
                ...s,
                method: "HEAD"
            }),
        interceptors: a,
        options: (s)=>o({
                ...s,
                method: "OPTIONS"
            }),
        patch: (s)=>o({
                ...s,
                method: "PATCH"
            }),
        post: (s)=>o({
                ...s,
                method: "POST"
            }),
        put: (s)=>o({
                ...s,
                method: "PUT"
            }),
        request: o,
        setConfig: i,
        trace: (s)=>o({
                ...s,
                method: "TRACE"
            })
    };
};

class LlamaExtractAgent {
    constructor(agent, client){
        this.agent = agent;
        this.client = client;
        this.id = agent.id;
        this.name = agent.name;
        this.dataSchema = agent.data_schema;
    }
    async extract(filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, fromUi = undefined, pollingInterval = 1, maxPollingIterations = 1800, maxRetriesOnError = 10, retryInterval = 0.5) {
        return await extract__namespace.extract(this.agent.id, filePath, fileContent, fileName, project_id, organization_id, this.client, fromUi, pollingInterval, maxPollingIterations, maxRetriesOnError, retryInterval);
    }
}
class LlamaExtract {
    constructor(apiKey = undefined, baseUrl = undefined, region = undefined){
        const key = apiKey ?? env.getEnv("LLAMA_CLOUD_API_KEY");
        if (typeof key === "undefined") {
            throw new Error("No API key provided and no API key found in environment. Please pass the API key or set `LLAMA_CLOUD_API_KEY` as an environment variable.");
        }
        const url = getUrl(baseUrl, region);
        this.client = J(w({
            baseUrl: url,
            headers: {
                Authorization: `Bearer ${key}`
            }
        }));
    }
    async createAgent(name, dataSchema, config = undefined, project_id = null, organization_id = null, maxRetriesOnError = 10, retryInterval = 0.5) {
        const agent = await extract__namespace.createAgent(name, dataSchema, config, project_id, organization_id, this.client, maxRetriesOnError, retryInterval);
        if (typeof agent != "undefined") {
            return new LlamaExtractAgent(agent, this.client);
        }
    }
    async getAgent(name = undefined, id = undefined, project_id = null, organization_id = null, maxRetriesOnError = 10, retryInterval = 0.5) {
        const agent = await extract__namespace.getAgent(id, name, project_id, organization_id, this.client, maxRetriesOnError, retryInterval);
        if (typeof agent != "undefined") {
            return new LlamaExtractAgent(agent, this.client);
        }
    }
    async deleteAgent(id, maxRetriesOnError = 10, retryInterval = 500) {
        return await extract__namespace.deleteAgent(id, this.client, maxRetriesOnError, retryInterval);
    }
    async extract(dataSchema, config = undefined, filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, pollingInterval = 1, maxPollingIterations = 1800, maxRetriesOnError = 10, retryInterval = 0.5) {
        return await extract__namespace.extractStateless(dataSchema, config, filePath, fileContent, fileName, project_id, organization_id, this.client, pollingInterval, maxPollingIterations, maxRetriesOnError, retryInterval);
    }
}

class LlamaClassify {
    constructor(apiKey = undefined, baseUrl = undefined, region = undefined){
        const key = apiKey ?? env.getEnv("LLAMA_CLOUD_API_KEY");
        if (typeof key === "undefined") {
            throw new Error("No API key provided and no API key found in environment. Please pass the API key or set `LLAMA_CLOUD_API_KEY` as an environment variable.");
        }
        const url = getUrl(baseUrl, region);
        this.client = J(w({
            baseUrl: url,
            headers: {
                Authorization: `Bearer ${key}`
            }
        }));
    }
    async classify(rules, parsingConfiguration, fileContents = undefined, filePaths = undefined, projectId = null, organizationId = null, pollingInterval = 1, maxPollingIterations = 1800, maxRetriesOnError = 10, retryInterval = 0.5) {
        const result = await index_cjs$2.classify(rules, parsingConfiguration, fileContents, filePaths, projectId, organizationId, this.client, pollingInterval, maxPollingIterations, maxRetriesOnError, retryInterval);
        return result;
    }
}

Object.defineProperty(exports, "LlamaParseReader", {
  enumerable: true,
  get: function () { return index_cjs.LlamaParseReader; }
});
exports.LLamaCloudFileService = LLamaCloudFileService;
exports.LlamaClassify = LlamaClassify;
exports.LlamaCloudIndex = LlamaCloudIndex;
exports.LlamaCloudRetriever = LlamaCloudRetriever;
exports.LlamaExtract = LlamaExtract;
exports.LlamaExtractAgent = LlamaExtractAgent;
