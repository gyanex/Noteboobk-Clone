Object.defineProperty(exports, '__esModule', { value: true });

var process = require('process');
var index_cjs = require('../../api/dist/index.cjs');
require('@llamaindex/core/global');
var env = require('@llamaindex/env');
require('fs');
var path = require('path');
var fs = require('fs/promises');
var buffer = require('buffer');
var fileType = require('file-type');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return n;
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__default = /*#__PURE__*/_interopDefault(fs);

async function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}

function textToFile(text, fileName = null) {
    return new buffer.File([
        text
    ], fileName ?? "uploadedFile_" + env.randomUUID().replaceAll("-", "_") + ".txt");
}
async function uploadFile(filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    let file = undefined;
    if (typeof filePath === "undefined" && typeof fileContent === "undefined") {
        throw new Error("One between filePath and fileContent needs to be provided");
    } else if (typeof filePath != "undefined") {
        const buffer$1 = await fs__default.default.readFile(filePath);
        const actualFileName = fileName ?? path__namespace.basename(filePath);
        const uint8Array = new Uint8Array(buffer$1);
        file = new buffer.File([
            uint8Array
        ], actualFileName);
    } else if (typeof fileContent != "undefined") {
        if (fileContent instanceof buffer.File) {
            file = fileContent;
        } else if (fileContent instanceof Buffer) {
            const fileType$1 = await fileType.fileTypeFromBuffer(fileContent);
            const ext = fileType$1?.ext ?? "pdf";
            const uint8Array = new Uint8Array(fileContent);
            file = new buffer.File([
                uint8Array
            ], fileName ?? "uploadedFile_" + env.randomUUID().replaceAll("-", "_") + "." + ext);
        } else if (fileContent instanceof Uint8Array) {
            const fileType$1 = await fileType.fileTypeFromBuffer(fileContent);
            const ext = fileType$1?.ext ?? "pdf";
            file = new buffer.File([
                fileContent
            ], fileName ?? "uploadedFile_" + env.randomUUID().replaceAll("-", "_") + "." + ext);
        } else if (typeof fileContent === "string") {
            file = textToFile(fileContent, fileName);
        } else {
            throw new Error("Unsupported fileContent type");
        }
    }
    const fileToUpload = {
        upload_file: file
    };
    const uploadData = {
        body: fileToUpload,
        query: {
            organization_id: organization_id,
            project_id: project_id
        }
    };
    const uploadOptions = uploadData;
    if (typeof client != "undefined") {
        uploadOptions.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while processing your file: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const uploadResponse = await index_cjs.uploadFileApiV1FilesPost(uploadOptions);
        let fileId = undefined;
        if (!uploadResponse.response.ok) {
            retries++;
            await sleep(retryInterval * 1000);
        }
        if (uploadResponse.response.ok && typeof uploadResponse.data != "undefined") {
            fileId = uploadResponse.data.id;
            return fileId;
        }
    }
}

async function createAgent(name, dataSchema, config = {}, project_id = null, organization_id = null, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    const agentData = {
        name: name,
        data_schema: dataSchema,
        config: config
    };
    const agentDataCreation = {
        body: agentData,
        query: {
            project_id: project_id,
            organization_id: organization_id
        }
    };
    const options = agentDataCreation;
    if (typeof client != "undefined") {
        options.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while creating the agent: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const response = await index_cjs.createExtractionAgentApiV1ExtractionExtractionAgentsPost(options);
        if (!response.response.ok) {
            if ("error" in response) {
                console.log(`An error occurred while creating the extraction agent.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
            }
            retries++;
            await sleep(retryInterval * 1000);
        } else {
            return response.data;
        }
    }
}
async function getAgent(id = undefined, name = undefined, project_id = null, organization_id = null, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    if (typeof id === "undefined" && typeof name === "undefined") {
        throw new Error("One of `id` and `string` must be passed.");
    } else if (typeof id != "undefined" && typeof name != "undefined") {
        process.emitWarning("You passed both `id` and `name`, using only id...");
        const data = {
            path: {
                extraction_agent_id: id
            }
        };
        const options = data;
        if (typeof client != "undefined") {
            options.client = client;
        }
        let retries = 0;
        while(true){
            if (retries > maxRetriesOnError) {
                throw new Error("Error while getting the agent: Exceeded maximum number of retries, the API keeps returning errors.");
            }
            const response = await index_cjs.getExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGet(options);
            if (!response.response.ok) {
                if ("error" in response) {
                    console.log(`An error occurred while getting the extraction agent by ID.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
                }
                retries++;
                await sleep(retryInterval * 1000);
            } else {
                return response.data;
            }
        }
    } else if (typeof name != "undefined" && typeof id === "undefined") {
        const data = {
            path: {
                name: name
            },
            query: {
                organization_id: organization_id,
                project_id: project_id
            }
        };
        const options = data;
        if (typeof client != "undefined") {
            options.client = client;
        }
        let retries = 0;
        while(true){
            if (retries > maxRetriesOnError) {
                throw new Error("Error while getting the agent: Exceeded maximum number of retries, the API keeps returning errors.");
            }
            const response = await index_cjs.getExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGet(options);
            if (!response.response.ok) {
                if ("error" in response) {
                    console.log(`An error occurred while getting the extraction agent by name.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
                }
                retries++;
                await sleep(retryInterval * 1000);
            } else {
                return response.data;
            }
        }
    } else {
        const data = {
            path: {
                extraction_agent_id: id
            }
        };
        const options = data;
        if (typeof client != "undefined") {
            options.client = client;
        }
        let retries = 0;
        while(true){
            if (retries > maxRetriesOnError) {
                throw new Error("Error while getting the agent: Exceeded maximum number of retries, the API keeps returning errors.");
            }
            const response = await index_cjs.getExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGet(options);
            if (!response.response.ok) {
                if (!response.response.ok) {
                    if ("error" in response) {
                        console.log(`An error occurred while getting the extraction agent by ID.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
                    }
                    retries++;
                    await sleep(retryInterval * 1000);
                }
            } else {
                return response.data;
            }
        }
    }
}
async function createExtractJob(options, stateless = false, maxRetriesOnError = 10, retryInterval = 0.5) {
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while creating the extraction job: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        let response = undefined;
        if (!stateless) {
            response = await index_cjs.runJobApiV1ExtractionJobsPost(options);
        } else {
            response = await index_cjs.extractStatelessApiV1ExtractionRunPost(options);
        }
        if (!response.response.ok) {
            if ("error" in response) {
                console.log("An error occurred: ", JSON.stringify(response.error), "\nRetrying...");
            }
            retries++;
            await sleep(retryInterval * 1000);
        }
        if (typeof response.data != "undefined") {
            const jobStatus = response.data.status;
            if (jobStatus == "CANCELLED") {
                retries++;
                await sleep(retryInterval * 1000);
            } else if (jobStatus == "ERROR") {
                retries++;
                await sleep(retryInterval * 1000);
            } else {
                return response.data.id;
            }
        }
    }
}
async function pollForJobCompletion(jobId, interval = 1, maxIterations = 1800, client = undefined) {
    let status = undefined;
    const jobData = {
        path: {
            job_id: jobId
        }
    };
    const jobOptions = jobData;
    if (typeof client != "undefined") {
        jobOptions.client = client;
    }
    let numIterations = 0;
    while(true){
        if (numIterations > maxIterations) {
            return false;
        }
        const response = await index_cjs.getJobApiV1ExtractionJobsJobIdGet(jobOptions);
        if (!response.response.ok) {
            numIterations++;
        }
        if (typeof response.data != "undefined") {
            status = response.data.status;
            if (status == index_cjs.StatusEnum.CANCELLED || status == index_cjs.StatusEnum.ERROR) {
                throw new Error("There was an error extracting data from your file.");
            } else if (status == index_cjs.StatusEnum.SUCCESS) {
                return true;
            } else {
                numIterations++;
                await sleep(interval * 1000);
            }
        }
    }
}
async function getJobResult(jobId, client = undefined, project_id = null, organization_id = null, maxRetriesOnError = 10, retryInterval = 0.5) {
    const jobData = {
        path: {
            job_id: jobId
        },
        query: {
            organization_id: organization_id,
            project_id: project_id
        }
    };
    const jobOptions = jobData;
    if (typeof client != "undefined") {
        jobOptions.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while getting the result of the extraction job: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const response = await index_cjs.getJobResultApiV1ExtractionJobsJobIdResultGet(jobOptions);
        if (!response.response.ok) {
            if ("error" in response) {
                console.log("An error occurred: ", JSON.stringify(response.error), "\nRetrying...");
            }
            retries++;
            await sleep(retryInterval * 1000);
        }
        if (typeof response.data != "undefined") {
            return {
                data: response.data.data,
                extractionMetadata: response.data.extraction_metadata
            };
        }
    }
}
async function extract(agentId, filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, client = undefined, fromUi = undefined, pollingInterval = 1, maxPollingIterations = 1800, maxRetriesOnError = 10, retryInterval = 0.5) {
    const fileId = await uploadFile(filePath, fileContent, fileName, project_id, organization_id, client, maxRetriesOnError, retryInterval);
    const extractJobCreate = {
        extraction_agent_id: agentId,
        file_id: fileId
    };
    const extractData = {
        body: extractJobCreate,
        query: {
            from_ui: fromUi
        }
    };
    const extractOptions = extractData;
    if (typeof client != "undefined") {
        extractOptions.client = client;
    }
    const jobId = await createExtractJob(extractOptions, false, maxRetriesOnError, retryInterval);
    const success = await pollForJobCompletion(jobId, pollingInterval, maxPollingIterations, client);
    if (!success) {
        throw new Error("Your job is taking longer than 10 minutes, timing out...");
    } else {
        return await getJobResult(jobId, client, project_id, organization_id, maxRetriesOnError, retryInterval);
    }
}
async function extractStateless(dataSchema, config = {}, filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, client = undefined, pollingInterval = 1, maxPollingIterations = 1800, maxRetriesOnError = 10, retryInterval = 0.5) {
    const fileId = await uploadFile(filePath, fileContent, fileName, project_id, organization_id, client, maxRetriesOnError, retryInterval);
    const extractStatetelessCreate = {
        data_schema: dataSchema,
        file_id: fileId,
        config: config
    };
    const extractStatetelessData = {
        body: extractStatetelessCreate
    };
    const extractOptions = extractStatetelessData;
    if (typeof client != "undefined") {
        extractOptions.client = client;
    }
    const jobId = await createExtractJob(extractOptions, true, maxRetriesOnError, retryInterval);
    const success = await pollForJobCompletion(jobId, pollingInterval, maxPollingIterations, client);
    if (!success) {
        throw new Error("Your job is taking longer than 10 minutes, timing out...");
    } else {
        return await getJobResult(jobId, client, project_id, organization_id, maxRetriesOnError, retryInterval);
    }
}
async function deleteAgent(id, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    const deleteData = {
        path: {
            extraction_agent_id: id
        }
    };
    const deleteOptions = deleteData;
    if (typeof client != "undefined") {
        deleteOptions.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Maximum number of attempts for deleting agent " + id + " reached, but the API continues to return errors.");
        }
        const response = await index_cjs.deleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDelete(deleteOptions);
        if (!response.response.ok) {
            if ("error" in response) {
                console.log(`An error occurred while deleting the agent: ${JSON.stringify(response.error)}\nRetrying...`);
            }
            retries++;
            await sleep(retryInterval * 1000);
        } else {
            return true;
        }
    }
}

exports.createAgent = createAgent;
exports.deleteAgent = deleteAgent;
exports.extract = extract;
exports.extractStateless = extractStateless;
exports.getAgent = getAgent;
