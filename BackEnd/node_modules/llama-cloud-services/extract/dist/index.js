import { emitWarning } from 'process';
import { uploadFileApiV1FilesPost, createExtractionAgentApiV1ExtractionExtractionAgentsPost, getExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGet, getExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGet, deleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDelete, runJobApiV1ExtractionJobsPost, extractStatelessApiV1ExtractionRunPost, getJobApiV1ExtractionJobsJobIdGet, StatusEnum, getJobResultApiV1ExtractionJobsJobIdResultGet } from '../../api/dist/index.js';
import '@llamaindex/core/global';
import { randomUUID } from '@llamaindex/env';
import 'fs';
import * as path from 'path';
import fs from 'fs/promises';
import { File } from 'buffer';
import { fileTypeFromBuffer } from 'file-type';

async function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}

function textToFile(text, fileName = null) {
    return new File([
        text
    ], fileName ?? "uploadedFile_" + randomUUID().replaceAll("-", "_") + ".txt");
}
async function uploadFile(filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    let file = undefined;
    if (typeof filePath === "undefined" && typeof fileContent === "undefined") {
        throw new Error("One between filePath and fileContent needs to be provided");
    } else if (typeof filePath != "undefined") {
        const buffer = await fs.readFile(filePath);
        const actualFileName = fileName ?? path.basename(filePath);
        const uint8Array = new Uint8Array(buffer);
        file = new File([
            uint8Array
        ], actualFileName);
    } else if (typeof fileContent != "undefined") {
        if (fileContent instanceof File) {
            file = fileContent;
        } else if (fileContent instanceof Buffer) {
            const fileType = await fileTypeFromBuffer(fileContent);
            const ext = fileType?.ext ?? "pdf";
            const uint8Array = new Uint8Array(fileContent);
            file = new File([
                uint8Array
            ], fileName ?? "uploadedFile_" + randomUUID().replaceAll("-", "_") + "." + ext);
        } else if (fileContent instanceof Uint8Array) {
            const fileType = await fileTypeFromBuffer(fileContent);
            const ext = fileType?.ext ?? "pdf";
            file = new File([
                fileContent
            ], fileName ?? "uploadedFile_" + randomUUID().replaceAll("-", "_") + "." + ext);
        } else if (typeof fileContent === "string") {
            file = textToFile(fileContent, fileName);
        } else {
            throw new Error("Unsupported fileContent type");
        }
    }
    const fileToUpload = {
        upload_file: file
    };
    const uploadData = {
        body: fileToUpload,
        query: {
            organization_id: organization_id,
            project_id: project_id
        }
    };
    const uploadOptions = uploadData;
    if (typeof client != "undefined") {
        uploadOptions.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while processing your file: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const uploadResponse = await uploadFileApiV1FilesPost(uploadOptions);
        let fileId = undefined;
        if (!uploadResponse.response.ok) {
            retries++;
            await sleep(retryInterval * 1000);
        }
        if (uploadResponse.response.ok && typeof uploadResponse.data != "undefined") {
            fileId = uploadResponse.data.id;
            return fileId;
        }
    }
}

async function createAgent(name, dataSchema, config = {}, project_id = null, organization_id = null, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    const agentData = {
        name: name,
        data_schema: dataSchema,
        config: config
    };
    const agentDataCreation = {
        body: agentData,
        query: {
            project_id: project_id,
            organization_id: organization_id
        }
    };
    const options = agentDataCreation;
    if (typeof client != "undefined") {
        options.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while creating the agent: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const response = await createExtractionAgentApiV1ExtractionExtractionAgentsPost(options);
        if (!response.response.ok) {
            if ("error" in response) {
                console.log(`An error occurred while creating the extraction agent.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
            }
            retries++;
            await sleep(retryInterval * 1000);
        } else {
            return response.data;
        }
    }
}
async function getAgent(id = undefined, name = undefined, project_id = null, organization_id = null, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    if (typeof id === "undefined" && typeof name === "undefined") {
        throw new Error("One of `id` and `string` must be passed.");
    } else if (typeof id != "undefined" && typeof name != "undefined") {
        emitWarning("You passed both `id` and `name`, using only id...");
        const data = {
            path: {
                extraction_agent_id: id
            }
        };
        const options = data;
        if (typeof client != "undefined") {
            options.client = client;
        }
        let retries = 0;
        while(true){
            if (retries > maxRetriesOnError) {
                throw new Error("Error while getting the agent: Exceeded maximum number of retries, the API keeps returning errors.");
            }
            const response = await getExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGet(options);
            if (!response.response.ok) {
                if ("error" in response) {
                    console.log(`An error occurred while getting the extraction agent by ID.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
                }
                retries++;
                await sleep(retryInterval * 1000);
            } else {
                return response.data;
            }
        }
    } else if (typeof name != "undefined" && typeof id === "undefined") {
        const data = {
            path: {
                name: name
            },
            query: {
                organization_id: organization_id,
                project_id: project_id
            }
        };
        const options = data;
        if (typeof client != "undefined") {
            options.client = client;
        }
        let retries = 0;
        while(true){
            if (retries > maxRetriesOnError) {
                throw new Error("Error while getting the agent: Exceeded maximum number of retries, the API keeps returning errors.");
            }
            const response = await getExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGet(options);
            if (!response.response.ok) {
                if ("error" in response) {
                    console.log(`An error occurred while getting the extraction agent by name.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
                }
                retries++;
                await sleep(retryInterval * 1000);
            } else {
                return response.data;
            }
        }
    } else {
        const data = {
            path: {
                extraction_agent_id: id
            }
        };
        const options = data;
        if (typeof client != "undefined") {
            options.client = client;
        }
        let retries = 0;
        while(true){
            if (retries > maxRetriesOnError) {
                throw new Error("Error while getting the agent: Exceeded maximum number of retries, the API keeps returning errors.");
            }
            const response = await getExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGet(options);
            if (!response.response.ok) {
                if (!response.response.ok) {
                    if ("error" in response) {
                        console.log(`An error occurred while getting the extraction agent by ID.\nDetails:\n\n${JSON.stringify(response.error)}\n\nRetrying...`);
                    }
                    retries++;
                    await sleep(retryInterval * 1000);
                }
            } else {
                return response.data;
            }
        }
    }
}
async function createExtractJob(options, stateless = false, maxRetriesOnError = 10, retryInterval = 0.5) {
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while creating the extraction job: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        let response = undefined;
        if (!stateless) {
            response = await runJobApiV1ExtractionJobsPost(options);
        } else {
            response = await extractStatelessApiV1ExtractionRunPost(options);
        }
        if (!response.response.ok) {
            if ("error" in response) {
                console.log("An error occurred: ", JSON.stringify(response.error), "\nRetrying...");
            }
            retries++;
            await sleep(retryInterval * 1000);
        }
        if (typeof response.data != "undefined") {
            const jobStatus = response.data.status;
            if (jobStatus == "CANCELLED") {
                retries++;
                await sleep(retryInterval * 1000);
            } else if (jobStatus == "ERROR") {
                retries++;
                await sleep(retryInterval * 1000);
            } else {
                return response.data.id;
            }
        }
    }
}
async function pollForJobCompletion(jobId, interval = 1, maxIterations = 1800, client = undefined) {
    let status = undefined;
    const jobData = {
        path: {
            job_id: jobId
        }
    };
    const jobOptions = jobData;
    if (typeof client != "undefined") {
        jobOptions.client = client;
    }
    let numIterations = 0;
    while(true){
        if (numIterations > maxIterations) {
            return false;
        }
        const response = await getJobApiV1ExtractionJobsJobIdGet(jobOptions);
        if (!response.response.ok) {
            numIterations++;
        }
        if (typeof response.data != "undefined") {
            status = response.data.status;
            if (status == StatusEnum.CANCELLED || status == StatusEnum.ERROR) {
                throw new Error("There was an error extracting data from your file.");
            } else if (status == StatusEnum.SUCCESS) {
                return true;
            } else {
                numIterations++;
                await sleep(interval * 1000);
            }
        }
    }
}
async function getJobResult(jobId, client = undefined, project_id = null, organization_id = null, maxRetriesOnError = 10, retryInterval = 0.5) {
    const jobData = {
        path: {
            job_id: jobId
        },
        query: {
            organization_id: organization_id,
            project_id: project_id
        }
    };
    const jobOptions = jobData;
    if (typeof client != "undefined") {
        jobOptions.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Error while getting the result of the extraction job: Exceeded maximum number of retries, the API keeps returning errors.");
        }
        const response = await getJobResultApiV1ExtractionJobsJobIdResultGet(jobOptions);
        if (!response.response.ok) {
            if ("error" in response) {
                console.log("An error occurred: ", JSON.stringify(response.error), "\nRetrying...");
            }
            retries++;
            await sleep(retryInterval * 1000);
        }
        if (typeof response.data != "undefined") {
            return {
                data: response.data.data,
                extractionMetadata: response.data.extraction_metadata
            };
        }
    }
}
async function extract(agentId, filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, client = undefined, fromUi = undefined, pollingInterval = 1, maxPollingIterations = 1800, maxRetriesOnError = 10, retryInterval = 0.5) {
    const fileId = await uploadFile(filePath, fileContent, fileName, project_id, organization_id, client, maxRetriesOnError, retryInterval);
    const extractJobCreate = {
        extraction_agent_id: agentId,
        file_id: fileId
    };
    const extractData = {
        body: extractJobCreate,
        query: {
            from_ui: fromUi
        }
    };
    const extractOptions = extractData;
    if (typeof client != "undefined") {
        extractOptions.client = client;
    }
    const jobId = await createExtractJob(extractOptions, false, maxRetriesOnError, retryInterval);
    const success = await pollForJobCompletion(jobId, pollingInterval, maxPollingIterations, client);
    if (!success) {
        throw new Error("Your job is taking longer than 10 minutes, timing out...");
    } else {
        return await getJobResult(jobId, client, project_id, organization_id, maxRetriesOnError, retryInterval);
    }
}
async function extractStateless(dataSchema, config = {}, filePath = undefined, fileContent = undefined, fileName = undefined, project_id = null, organization_id = null, client = undefined, pollingInterval = 1, maxPollingIterations = 1800, maxRetriesOnError = 10, retryInterval = 0.5) {
    const fileId = await uploadFile(filePath, fileContent, fileName, project_id, organization_id, client, maxRetriesOnError, retryInterval);
    const extractStatetelessCreate = {
        data_schema: dataSchema,
        file_id: fileId,
        config: config
    };
    const extractStatetelessData = {
        body: extractStatetelessCreate
    };
    const extractOptions = extractStatetelessData;
    if (typeof client != "undefined") {
        extractOptions.client = client;
    }
    const jobId = await createExtractJob(extractOptions, true, maxRetriesOnError, retryInterval);
    const success = await pollForJobCompletion(jobId, pollingInterval, maxPollingIterations, client);
    if (!success) {
        throw new Error("Your job is taking longer than 10 minutes, timing out...");
    } else {
        return await getJobResult(jobId, client, project_id, organization_id, maxRetriesOnError, retryInterval);
    }
}
async function deleteAgent(id, client = undefined, maxRetriesOnError = 10, retryInterval = 0.5) {
    const deleteData = {
        path: {
            extraction_agent_id: id
        }
    };
    const deleteOptions = deleteData;
    if (typeof client != "undefined") {
        deleteOptions.client = client;
    }
    let retries = 0;
    while(true){
        if (retries > maxRetriesOnError) {
            throw new Error("Maximum number of attempts for deleting agent " + id + " reached, but the API continues to return errors.");
        }
        const response = await deleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDelete(deleteOptions);
        if (!response.response.ok) {
            if ("error" in response) {
                console.log(`An error occurred while deleting the agent: ${JSON.stringify(response.error)}\nRetrying...`);
            }
            retries++;
            await sleep(retryInterval * 1000);
        } else {
            return true;
        }
    }
}

export { createAgent, deleteAgent, extract, extractStateless, getAgent };
