import { workflowEvent, createWorkflow } from '@llamaindex/workflow-core';
import { createStatefulMiddleware } from '@llamaindex/workflow-core/middleware/state';
import { withTraceEvents } from '@llamaindex/workflow-core/middleware/trace-events';
import { pRetryHandler } from '@llamaindex/workflow-core/util/p-retry';
import { getEnv, fs, path } from '@llamaindex/env';
import { zodEvent } from '@llamaindex/workflow-core/util/zod';
import { z as z$1 } from 'zod';

var j = async (t, r)=>{
    let e = typeof r == "function" ? await r(t) : r;
    if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
}, z = (t, r, e)=>{
    typeof e == "string" || e instanceof Blob ? t.append(r, e) : t.append(r, JSON.stringify(e));
}, k = {
    bodySerializer: (t)=>{
        let r = new FormData;
        return Object.entries(t).forEach(([e, i])=>{
            i != null && (Array.isArray(i) ? i.forEach((a)=>z(r, e, a)) : z(r, e, i));
        }), r;
    }
}, R = {
    bodySerializer: (t)=>JSON.stringify(t, (r, e)=>typeof e == "bigint" ? e.toString() : e)
}, U = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, _ = (t)=>{
    switch(t){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
}, D = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, O = ({ allowReserved: t, explode: r, name: e, style: i, value: a })=>{
    if (!r) {
        let n = (t ? a : a.map((l)=>encodeURIComponent(l))).join(_(i));
        switch(i){
            case "label":
                return `.${n}`;
            case "matrix":
                return `;${e}=${n}`;
            case "simple":
                return n;
            default:
                return `${e}=${n}`;
        }
    }
    let o = U(i), s = a.map((n)=>i === "label" || i === "simple" ? t ? n : encodeURIComponent(n) : y({
            allowReserved: t,
            name: e,
            value: n
        })).join(o);
    return i === "label" || i === "matrix" ? o + s : s;
}, y = ({ allowReserved: t, name: r, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${r}=${t ? e : encodeURIComponent(e)}`;
}, q = ({ allowReserved: t, explode: r, name: e, style: i, value: a })=>{
    if (a instanceof Date) return `${e}=${a.toISOString()}`;
    if (i !== "deepObject" && !r) {
        let n = [];
        Object.entries(a).forEach(([f, p])=>{
            n = [
                ...n,
                f,
                t ? p : encodeURIComponent(p)
            ];
        });
        let l = n.join(",");
        switch(i){
            case "form":
                return `${e}=${l}`;
            case "label":
                return `.${l}`;
            case "matrix":
                return `;${e}=${l}`;
            default:
                return l;
        }
    }
    let o = D(i), s = Object.entries(a).map(([n, l])=>y({
            allowReserved: t,
            name: i === "deepObject" ? `${e}[${n}]` : n,
            value: l
        })).join(o);
    return i === "label" || i === "matrix" ? o + s : s;
};
var H = /\{[^{}]+\}/g, B = ({ path: t, url: r })=>{
    let e = r, i = r.match(H);
    if (i) for (let a of i){
        let o = false, s = a.substring(1, a.length - 1), n = "simple";
        s.endsWith("*") && (o = true, s = s.substring(0, s.length - 1)), s.startsWith(".") ? (s = s.substring(1), n = "label") : s.startsWith(";") && (s = s.substring(1), n = "matrix");
        let l = t[s];
        if (l == null) continue;
        if (Array.isArray(l)) {
            e = e.replace(a, O({
                explode: o,
                name: s,
                style: n,
                value: l
            }));
            continue;
        }
        if (typeof l == "object") {
            e = e.replace(a, q({
                explode: o,
                name: s,
                style: n,
                value: l
            }));
            continue;
        }
        if (n === "matrix") {
            e = e.replace(a, `;${y({
                name: s,
                value: l
            })}`);
            continue;
        }
        let f = encodeURIComponent(n === "label" ? `.${l}` : l);
        e = e.replace(a, f);
    }
    return e;
}, A = ({ allowReserved: t, array: r, object: e } = {})=>(a)=>{
        let o = [];
        if (a && typeof a == "object") for(let s in a){
            let n = a[s];
            if (n != null) if (Array.isArray(n)) {
                let l = O({
                    allowReserved: t,
                    explode: true,
                    name: s,
                    style: "form",
                    value: n,
                    ...r
                });
                l && o.push(l);
            } else if (typeof n == "object") {
                let l = q({
                    allowReserved: t,
                    explode: true,
                    name: s,
                    style: "deepObject",
                    value: n,
                    ...e
                });
                l && o.push(l);
            } else {
                let l = y({
                    allowReserved: t,
                    name: s,
                    value: n
                });
                l && o.push(l);
            }
        }
        return o.join("&");
    }, P = (t)=>{
    if (!t) return "stream";
    let r = t.split(";")[0]?.trim();
    if (r) {
        if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
        if (r === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((e)=>r.startsWith(e))) return "blob";
        if (r.startsWith("text/")) return "text";
    }
}, E = async ({ security: t, ...r })=>{
    for (let e of t){
        let i = await j(e, r.auth);
        if (!i) continue;
        let a = e.name ?? "Authorization";
        switch(e.in){
            case "query":
                r.query || (r.query = {}), r.query[a] = i;
                break;
            case "cookie":
                r.headers.append("Cookie", `${a}=${i}`);
                break;
            case "header":
            default:
                r.headers.set(a, i);
                break;
        }
        return;
    }
}, S = (t)=>W({
        baseUrl: t.baseUrl,
        path: t.path,
        query: t.query,
        querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : A(t.querySerializer),
        url: t.url
    }), W = ({ baseUrl: t, path: r, query: e, querySerializer: i, url: a })=>{
    let o = a.startsWith("/") ? a : `/${a}`, s = (t ?? "") + o;
    r && (s = B({
        path: r,
        url: s
    }));
    let n = e ? i(e) : "";
    return n.startsWith("?") && (n = n.substring(1)), n && (s += `?${n}`), s;
}, x = (t, r)=>{
    let e = {
        ...t,
        ...r
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = C(t.headers, r.headers), e;
}, C = (...t)=>{
    let r = new Headers;
    for (let e of t){
        if (!e || typeof e != "object") continue;
        let i = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [a, o] of i)if (o === null) r.delete(a);
        else if (Array.isArray(o)) for (let s of o)r.append(a, s);
        else o !== void 0 && r.set(a, typeof o == "object" ? JSON.stringify(o) : o);
    }
    return r;
}, h = class {
    constructor(){
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    getInterceptorIndex(r) {
        return typeof r == "number" ? this._fns[r] ? r : -1 : this._fns.indexOf(r);
    }
    exists(r) {
        let e = this.getInterceptorIndex(r);
        return !!this._fns[e];
    }
    eject(r) {
        let e = this.getInterceptorIndex(r);
        this._fns[e] && (this._fns[e] = null);
    }
    update(r, e) {
        let i = this.getInterceptorIndex(r);
        return this._fns[i] ? (this._fns[i] = e, r) : false;
    }
    use(r) {
        return this._fns = [
            ...this._fns,
            r
        ], this._fns.length - 1;
    }
}, v = ()=>({
        error: new h,
        request: new h,
        response: new h
    }), N = A({
    allowReserved: false,
    array: {
        explode: true,
        style: "form"
    },
    object: {
        explode: true,
        style: "deepObject"
    }
}), Q = {
    "Content-Type": "application/json"
}, w = (t = {})=>({
        ...R,
        headers: Q,
        parseAs: "auto",
        querySerializer: N,
        ...t
    });
var J = (t = {})=>{
    let r = x(w(), t), e = ()=>({
            ...r
        }), i = (s)=>(r = x(r, s), e()), a = v(), o = async (s)=>{
        let n = {
            ...r,
            ...s,
            fetch: s.fetch ?? r.fetch ?? globalThis.fetch,
            headers: C(r.headers, s.headers)
        };
        n.security && await E({
            ...n,
            security: n.security
        }), n.body && n.bodySerializer && (n.body = n.bodySerializer(n.body)), (n.body === void 0 || n.body === "") && n.headers.delete("Content-Type");
        let l = S(n), f = {
            redirect: "follow",
            ...n
        }, p = new Request(l, f);
        for (let c of a.request._fns)c && (p = await c(p, n));
        let T = n.fetch, u = await T(p);
        for (let c of a.response._fns)c && (u = await c(u, p, n));
        let m = {
            request: p,
            response: u
        };
        if (u.ok) {
            if (u.status === 204 || u.headers.get("Content-Length") === "0") return {
                data: {},
                ...m
            };
            let c = (n.parseAs === "auto" ? P(u.headers.get("Content-Type")) : n.parseAs) ?? "json";
            if (c === "stream") return {
                data: u.body,
                ...m
            };
            let b = await u[c]();
            return c === "json" && (n.responseValidator && await n.responseValidator(b), n.responseTransformer && (b = await n.responseTransformer(b))), {
                data: b,
                ...m
            };
        }
        let g = await u.text();
        try {
            g = JSON.parse(g);
        } catch  {}
        let d = g;
        for (let c of a.error._fns)c && (d = await c(g, u, p, n));
        if (d = d || {}, n.throwOnError) throw d;
        return {
            error: d,
            ...m
        };
    };
    return {
        buildUrl: S,
        connect: (s)=>o({
                ...s,
                method: "CONNECT"
            }),
        delete: (s)=>o({
                ...s,
                method: "DELETE"
            }),
        get: (s)=>o({
                ...s,
                method: "GET"
            }),
        getConfig: e,
        head: (s)=>o({
                ...s,
                method: "HEAD"
            }),
        interceptors: a,
        options: (s)=>o({
                ...s,
                method: "OPTIONS"
            }),
        patch: (s)=>o({
                ...s,
                method: "PATCH"
            }),
        post: (s)=>o({
                ...s,
                method: "POST"
            }),
        put: (s)=>o({
                ...s,
                method: "PUT"
            }),
        request: o,
        setConfig: i,
        trace: (s)=>o({
                ...s,
                method: "TRACE"
            })
    };
};

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Enum for representing the different available page error handling modes
 */ const FailPageMode = {
    RAW_TEXT: "raw_text",
    BLANK_PAGE: "blank_page",
    ERROR_MESSAGE: "error_message"
};
/**
 * Enum for representing the languages supported by the parser
 */ const ParserLanguages = {
    AF: "af",
    AZ: "az",
    BS: "bs",
    CS: "cs",
    CY: "cy",
    DA: "da",
    DE: "de",
    EN: "en",
    ES: "es",
    ET: "et",
    FR: "fr",
    GA: "ga",
    HR: "hr",
    HU: "hu",
    ID: "id",
    IS: "is",
    IT: "it",
    KU: "ku",
    LA: "la",
    LT: "lt",
    LV: "lv",
    MI: "mi",
    MS: "ms",
    MT: "mt",
    NL: "nl",
    NO: "no",
    OC: "oc",
    PI: "pi",
    PL: "pl",
    PT: "pt",
    RO: "ro",
    RS_LATIN: "rs_latin",
    SK: "sk",
    SL: "sl",
    SQ: "sq",
    SV: "sv",
    SW: "sw",
    TL: "tl",
    TR: "tr",
    UZ: "uz",
    VI: "vi",
    AR: "ar",
    FA: "fa",
    UG: "ug",
    UR: "ur",
    BN: "bn",
    AS: "as",
    MNI: "mni",
    RU: "ru",
    RS_CYRILLIC: "rs_cyrillic",
    BE: "be",
    BG: "bg",
    UK: "uk",
    MN: "mn",
    ABQ: "abq",
    ADY: "ady",
    KBD: "kbd",
    AVA: "ava",
    DAR: "dar",
    INH: "inh",
    CHE: "che",
    LBE: "lbe",
    LEZ: "lez",
    TAB: "tab",
    TJK: "tjk",
    HI: "hi",
    MR: "mr",
    NE: "ne",
    BH: "bh",
    MAI: "mai",
    ANG: "ang",
    BHO: "bho",
    MAH: "mah",
    SCK: "sck",
    NEW: "new",
    GOM: "gom",
    SA: "sa",
    BGC: "bgc",
    TH: "th",
    CH_SIM: "ch_sim",
    CH_TRA: "ch_tra",
    JA: "ja",
    KO: "ko",
    TA: "ta",
    TE: "te",
    KN: "kn"
};
/**
 * Enum for representing the mode of parsing to be used
 */ const ParsingMode = {
    PARSE_PAGE_WITHOUT_LLM: "parse_page_without_llm",
    PARSE_PAGE_WITH_LLM: "parse_page_with_llm",
    PARSE_PAGE_WITH_LVM: "parse_page_with_lvm",
    PARSE_PAGE_WITH_AGENT: "parse_page_with_agent",
    PARSE_PAGE_WITH_LAYOUT_AGENT: "parse_page_with_layout_agent",
    PARSE_DOCUMENT_WITH_LLM: "parse_document_with_llm",
    PARSE_DOCUMENT_WITH_LVM: "parse_document_with_lvm",
    PARSE_DOCUMENT_WITH_AGENT: "parse_document_with_agent"
};

// This file is auto-generated by @hey-api/openapi-ts
const client = J(w());

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Upload File
 */ const uploadFileApiV1ParsingUploadPost = (options)=>{
    return (options?.client ?? client).post({
        ...k,
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/upload",
        ...options,
        headers: {
            "Content-Type": null,
            ...options?.headers
        }
    });
};
/**
 * Get Job
 * Get a job by id
 */ const getJobApiV1ParsingJobJobIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}",
        ...options
    });
};
/**
 * Get Job Text Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobTextResultApiV1ParsingJobJobIdResultTextGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/text",
        ...options
    });
};
/**
 * Get Job Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobResultApiV1ParsingJobJobIdResultMarkdownGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/markdown",
        ...options
    });
};
/**
 * Get Job Json Result
 * Get a job by id
 *
 * Note: The 'credits_used' and 'job_credits_usage' fields in the response metadata are deprecated
 * and will be removed in a future release.
 */ const getJobJsonResultApiV1ParsingJobJobIdResultJsonGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/parsing/job/{job_id}/result/json",
        ...options
    });
};

const VALUES = [
    ParserLanguages.EN,
    ...Object.values(ParserLanguages)
];
const languageSchema = z$1.enum(VALUES);
const PARSE_PRESETS = [
    "fast",
    "balanced",
    "premium",
    "structured",
    "auto",
    "scientific",
    "invoice",
    "slides",
    "_carlyle"
];
const parsePresetSchema = z$1.enum(PARSE_PRESETS);
const parseFormSchema = z$1.object({
    adaptive_long_table: z$1.boolean().optional(),
    annotate_links: z$1.boolean().optional(),
    auto_mode: z$1.boolean().optional(),
    auto_mode_trigger_on_image_in_page: z$1.boolean().optional(),
    auto_mode_trigger_on_table_in_page: z$1.boolean().optional(),
    auto_mode_trigger_on_text_in_page: z$1.string().optional(),
    auto_mode_trigger_on_regexp_in_page: z$1.string().optional(),
    auto_mode_configuration_json: z$1.string().optional(),
    azure_openai_api_version: z$1.string().optional(),
    azure_openai_deployment_name: z$1.string().optional(),
    azure_openai_endpoint: z$1.string().optional(),
    azure_openai_key: z$1.string().optional(),
    bbox_bottom: z$1.number().min(0).max(1).optional(),
    bbox_left: z$1.number().min(0).max(1).optional(),
    bbox_right: z$1.number().min(0).max(1).optional(),
    bbox_top: z$1.number().min(0).max(1).optional(),
    disable_ocr: z$1.boolean().optional(),
    disable_reconstruction: z$1.boolean().optional(),
    disable_image_extraction: z$1.boolean().optional(),
    do_not_cache: z$1.coerce.boolean().optional(),
    do_not_unroll_columns: z$1.coerce.boolean().optional(),
    extract_charts: z$1.boolean().optional(),
    guess_xlsx_sheet_name: z$1.boolean().optional(),
    html_make_all_elements_visible: z$1.boolean().optional(),
    html_remove_fixed_elements: z$1.boolean().optional(),
    html_remove_navigation_elements: z$1.boolean().optional(),
    http_proxy: z$1.string().url('Set a valid URL for the HTTP proxy, e.g., "http://proxy.example.com:8080"').refine((url)=>{
        try {
            const parsedUrl = new URL(url);
            return parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:";
        } catch  {
            return false;
        }
    }, {
        message: "Invalid HTTP proxy URL"
    }).optional(),
    input_s3_path: z$1.string().optional(),
    input_s3_region: z$1.string().optional(),
    input_url: z$1.string().optional(),
    invalidate_cache: z$1.boolean().optional(),
    language: z$1.array(languageSchema).optional(),
    extract_layout: z$1.boolean().optional(),
    max_pages: z$1.number().nullable().optional(),
    output_pdf_of_document: z$1.boolean().optional(),
    output_s3_path_prefix: z$1.string().optional(),
    output_s3_region: z$1.string().optional(),
    page_prefix: z$1.string().optional(),
    page_separator: z$1.string().optional(),
    page_suffix: z$1.string().optional(),
    preserve_layout_alignment_across_pages: z$1.boolean().optional(),
    skip_diagonal_text: z$1.boolean().optional(),
    spreadsheet_extract_sub_tables: z$1.boolean().optional(),
    specialized_chart_parsing_agentic: z$1.boolean().optional(),
    specialized_chart_parsing_efficient: z$1.boolean().optional(),
    specialized_chart_parsing_plus: z$1.boolean().optional(),
    precise_bounding_box: z$1.boolean().optional(),
    structured_output: z$1.boolean().optional(),
    structured_output_json_schema: z$1.string().optional(),
    structured_output_json_schema_name: z$1.string().optional(),
    take_screenshot: z$1.boolean().optional(),
    target_pages: z$1.string().optional(),
    vendor_multimodal_api_key: z$1.string().optional(),
    vendor_multimodal_model_name: z$1.string().optional(),
    model: z$1.string().optional(),
    webhook_url: z$1.string().url().optional(),
    parse_mode: z$1.nativeEnum(ParsingMode).nullable().optional(),
    system_prompt: z$1.string().optional(),
    system_prompt_append: z$1.string().optional(),
    user_prompt: z$1.string().optional(),
    job_timeout_in_seconds: z$1.number().optional(),
    job_timeout_extra_time_per_page_in_seconds: z$1.number().optional(),
    strict_mode_image_extraction: z$1.boolean().optional(),
    strict_mode_image_ocr: z$1.boolean().optional(),
    strict_mode_reconstruction: z$1.boolean().optional(),
    strict_mode_buggy_font: z$1.boolean().optional(),
    save_images: z$1.boolean().optional(),
    ignore_document_elements_for_layout_detection: z$1.boolean().optional(),
    output_tables_as_HTML: z$1.boolean().optional(),
    use_vendor_multimodal_model: z$1.boolean().optional(),
    bounding_box: z$1.string().optional(),
    gpt4o_mode: z$1.boolean().optional(),
    gpt4o_api_key: z$1.string().optional(),
    complemental_formatting_instruction: z$1.string().optional(),
    content_guideline_instruction: z$1.string().optional(),
    premium_mode: z$1.boolean().optional(),
    is_formatting_instruction: z$1.boolean().optional(),
    continuous_mode: z$1.boolean().optional(),
    parsing_instruction: z$1.string().optional(),
    fast_mode: z$1.boolean().optional(),
    formatting_instruction: z$1.string().optional(),
    preset: parsePresetSchema.optional(),
    compact_markdown_table: z$1.boolean().optional(),
    markdown_table_multiline_header_separator: z$1.string().optional(),
    page_error_tolerance: z$1.number().min(0).max(1).optional(),
    replace_failed_page_mode: z$1.nativeEnum(FailPageMode).nullable().optional(),
    replace_failed_page_with_error_message_prefix: z$1.string().optional(),
    replace_failed_page_with_error_message_suffix: z$1.string().optional()
});

const uploadEvent = zodEvent(parseFormSchema.merge(z$1.object({
    file: z$1.string().or(z$1.instanceof(File)).or(z$1.instanceof(Blob)).or(z$1.instanceof(Uint8Array)).optional().describe("input")
})), {
    debugLabel: "upload",
    uniqueId: "52099967-34a8-419b-8950-c859eab60145"
});
const checkStatusEvent = workflowEvent({
    debugLabel: "check-status",
    uniqueId: "462157fc-1ded-4ba7-9bc4-3e870395bd20"
});
const checkStatusSuccessEvent = workflowEvent({
    debugLabel: "check-status-success",
    uniqueId: "360b7641-30f7-456e-851d-104bb5e3f8d2"
});
const requestMarkdownEvent = workflowEvent({
    debugLabel: "markdown-request",
    uniqueId: "aa4c2e3c-0f09-4035-aab6-c72719c877cc"
});
const requestTextEvent = workflowEvent({
    debugLabel: "text-request",
    uniqueId: "6976536e-5399-4285-9455-0b70f1dfc92b"
});
const requestJsonEvent = workflowEvent({
    debugLabel: "json-request",
    uniqueId: "9fc4a330-52ad-4aac-8092-a650998b7f6f"
});
const markdownResultEvent = workflowEvent({
    debugLabel: "markdown-result",
    uniqueId: "2dfb57c8-73d1-4394-bea8-f05246d934d4"
});
const textResultEvent = workflowEvent({
    debugLabel: "text-result",
    uniqueId: "a27deec6-b24f-4eda-a5ac-ba2fb2bf37c8"
});
const jsonResultEvent = workflowEvent({
    debugLabel: "json-result",
    uniqueId: "e086e6bd-a612-4f25-ab41-9b31dcb8af86"
});

const URLS = {
    us: "https://api.cloud.llamaindex.ai",
    eu: "https://api.cloud.eu.llamaindex.ai",
    "us-staging": "https://api.staging.llamaindex.ai"
};
const { withState, getContext } = createStatefulMiddleware((params)=>{
    const apiKey = params.apiKey ?? getEnv("LLAMA_CLOUD_API_KEY");
    const region = params.region ?? "us";
    if (!apiKey) {
        throw new Error("LLAMA_CLOUD_API_KEY is not set");
    }
    return {
        cache: {},
        client: J(w({
            baseUrl: URLS[region],
            headers: {
                Authorization: `Bearer ${apiKey}`
            }
        }))
    };
});
const llamaParseWorkflow = withState(withTraceEvents(createWorkflow()));
llamaParseWorkflow.handle([
    uploadEvent
], async ({ data: form })=>{
    const { state } = getContext();
    const finalForm = {
        ...form
    };
    if ("file" in form) {
        // support loads from the file system
        const file = form?.file;
        const isFilePath = typeof file === "string";
        const data = isFilePath ? await fs.readFile(file) : file;
        const filename = isFilePath ? path.basename(file) : undefined;
        finalForm.file = data ? globalThis.File && filename ? new File([
            data
        ], filename) : new Blob([
            data
        ]) : undefined;
    }
    const { data: { id, status } } = await uploadFileApiV1ParsingUploadPost({
        throwOnError: true,
        body: {
            ...finalForm
        },
        client: state.client
    });
    state.cache[id] = status;
    return checkStatusEvent.with(id);
});
llamaParseWorkflow.handle([
    checkStatusEvent
], pRetryHandler(async ({ data: uuid })=>{
    const { state } = getContext();
    if (state.cache[uuid] === "SUCCESS") {
        return checkStatusSuccessEvent.with(uuid);
    }
    const { data: { status } } = await getJobApiV1ParsingJobJobIdGet({
        throwOnError: true,
        path: {
            job_id: uuid
        },
        client: state.client
    });
    state.cache[uuid] = status;
    if (status === "SUCCESS") {
        return checkStatusSuccessEvent.with(uuid);
    }
    throw new Error(`LLamaParse status: ${status}`);
}, {
    retries: 100
}));
//#region sub workflow
llamaParseWorkflow.handle([
    requestMarkdownEvent
], async ({ data: job_id })=>{
    const { state } = getContext();
    const { data } = await getJobResultApiV1ParsingJobJobIdResultMarkdownGet({
        throwOnError: true,
        path: {
            job_id
        },
        client: state.client
    });
    return markdownResultEvent.with(data.markdown);
});
llamaParseWorkflow.handle([
    requestTextEvent
], async ({ data: job_id })=>{
    const { state } = getContext();
    const { data } = await getJobTextResultApiV1ParsingJobJobIdResultTextGet({
        throwOnError: true,
        path: {
            job_id
        },
        client: state.client
    });
    return textResultEvent.with(data.text);
});
llamaParseWorkflow.handle([
    requestJsonEvent
], async ({ data: job_id })=>{
    const { state } = getContext();
    const { data } = await getJobJsonResultApiV1ParsingJobJobIdResultJsonGet({
        throwOnError: true,
        path: {
            job_id
        },
        client: state.client
    });
    return jsonResultEvent.with(data.pages);
});
const upload = async (params)=>{
    //#region upload event
    const context = llamaParseWorkflow.createContext(params);
    const { stream, sendEvent } = context;
    const ev = uploadEvent.with(params);
    sendEvent(ev);
    const uploadThread = await llamaParseWorkflow.substream(ev, stream).until((ev)=>checkStatusSuccessEvent.include(ev)).toArray();
    //#region
    const jobId = uploadThread.at(-1).data;
    return {
        get signal () {
            // lazy load
            return context.signal;
        },
        get jobId () {
            return jobId;
        },
        get form () {
            return ev.data;
        },
        get context () {
            return context;
        },
        async markdown () {
            const requestEv = requestMarkdownEvent.with(jobId);
            const { sendEvent, stream } = llamaParseWorkflow.createContext(params);
            sendEvent(requestEv);
            const markdownThread = await stream.until(markdownResultEvent).toArray();
            return markdownThread.at(-1).data;
        },
        async text () {
            const requestEv = requestTextEvent.with(jobId);
            const { sendEvent, stream } = llamaParseWorkflow.createContext(params);
            sendEvent(requestEv);
            const textThread = await stream.until(textResultEvent).toArray();
            return textThread.at(-1).data;
        },
        //eslint-disable-next-line @typescript-eslint/no-explicit-any
        async json () {
            const requestEv = requestJsonEvent.with(jobId);
            const { sendEvent, stream } = llamaParseWorkflow.createContext(params);
            sendEvent(requestEv);
            const jsonThread = await stream.until((ev)=>jsonResultEvent.include(ev)).toArray();
            return jsonThread.at(-1).data;
        }
    };
};

export { upload };
