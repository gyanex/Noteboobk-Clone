//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function() {
	return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i$1 = 0, n = keys.length, key; i$1 < n; i$1++) {
		key = keys[i$1];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

//#endregion
//#region ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
	__addDisposableResource: () => __addDisposableResource,
	__assign: () => __assign,
	__asyncDelegator: () => __asyncDelegator,
	__asyncGenerator: () => __asyncGenerator,
	__asyncValues: () => __asyncValues,
	__await: () => __await,
	__awaiter: () => __awaiter,
	__classPrivateFieldGet: () => __classPrivateFieldGet,
	__classPrivateFieldIn: () => __classPrivateFieldIn,
	__classPrivateFieldSet: () => __classPrivateFieldSet,
	__createBinding: () => __createBinding,
	__decorate: () => __decorate,
	__disposeResources: () => __disposeResources,
	__esDecorate: () => __esDecorate,
	__exportStar: () => __exportStar,
	__extends: () => __extends,
	__generator: () => __generator,
	__importDefault: () => __importDefault,
	__importStar: () => __importStar,
	__makeTemplateObject: () => __makeTemplateObject,
	__metadata: () => __metadata,
	__param: () => __param,
	__propKey: () => __propKey,
	__read: () => __read,
	__rest: () => __rest,
	__rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
	__runInitializers: () => __runInitializers,
	__setFunctionName: () => __setFunctionName,
	__spread: () => __spread,
	__spreadArray: () => __spreadArray,
	__spreadArrays: () => __spreadArrays,
	__values: () => __values,
	default: () => tslib_es6_default
});
function __extends(d, b) {
	if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	extendStatics(d, b);
	function __() {
		this.constructor = d;
	}
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
	var t = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i$1 = 0, p = Object.getOwnPropertySymbols(s); i$1 < p.length; i$1++) if (e.indexOf(p[i$1]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i$1])) t[p[i$1]] = s[p[i$1]];
	}
	return t;
}
function __decorate(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i$1 = decorators.length - 1; i$1 >= 0; i$1--) if (d = decorators[i$1]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	function accept(f) {
		if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
		return f;
	}
	var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	var _, done = false;
	for (var i$1 = decorators.length - 1; i$1 >= 0; i$1--) {
		var context = {};
		for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
		for (var p in contextIn.access) context.access[p] = contextIn.access[p];
		context.addInitializer = function(f) {
			if (done) throw new TypeError("Cannot add initializers after decoration has completed");
			extraInitializers.push(accept(f || null));
		};
		var result = (0, decorators[i$1])(kind === "accessor" ? {
			get: descriptor.get,
			set: descriptor.set
		} : descriptor[key], context);
		if (kind === "accessor") {
			if (result === void 0) continue;
			if (result === null || typeof result !== "object") throw new TypeError("Object expected");
			if (_ = accept(result.get)) descriptor.get = _;
			if (_ = accept(result.set)) descriptor.set = _;
			if (_ = accept(result.init)) initializers.unshift(_);
		} else if (_ = accept(result)) if (kind === "field") initializers.unshift(_);
		else descriptor[key] = _;
	}
	if (target) Object.defineProperty(target, contextIn.name, descriptor);
	done = true;
}
function __runInitializers(thisArg, initializers, value) {
	var useValue = arguments.length > 2;
	for (var i$1 = 0; i$1 < initializers.length; i$1++) value = useValue ? initializers[i$1].call(thisArg, value) : initializers[i$1].call(thisArg);
	return useValue ? value : void 0;
}
function __propKey(x) {
	return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
	if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
	return Object.defineProperty(f, "name", {
		configurable: true,
		value: prefix ? "".concat(prefix, " ", name) : name
	});
}
function __metadata(metadataKey, metadataValue) {
	if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
}
function __generator(thisArg, body) {
	var _ = {
		label: 0,
		sent: function() {
			if (t[0] & 1) throw t[1];
			return t[1];
		},
		trys: [],
		ops: []
	}, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
	return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
		return this;
	}), g;
	function verb(n) {
		return function(v) {
			return step([n, v]);
		};
	}
	function step(op) {
		if (f) throw new TypeError("Generator is already executing.");
		while (g && (g = 0, op[0] && (_ = 0)), _) try {
			if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
			if (y = 0, t) op = [op[0] & 2, t.value];
			switch (op[0]) {
				case 0:
				case 1:
					t = op;
					break;
				case 4:
					_.label++;
					return {
						value: op[1],
						done: false
					};
				case 5:
					_.label++;
					y = op[1];
					op = [0];
					continue;
				case 7:
					op = _.ops.pop();
					_.trys.pop();
					continue;
				default:
					if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
						_ = 0;
						continue;
					}
					if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
						_.label = op[1];
						break;
					}
					if (op[0] === 6 && _.label < t[1]) {
						_.label = t[1];
						t = op;
						break;
					}
					if (t && _.label < t[2]) {
						_.label = t[2];
						_.ops.push(op);
						break;
					}
					if (t[2]) _.ops.pop();
					_.trys.pop();
					continue;
			}
			op = body.call(thisArg, _);
		} catch (e) {
			op = [6, e];
			y = 0;
		} finally {
			f = t = 0;
		}
		if (op[0] & 5) throw op[1];
		return {
			value: op[0] ? op[1] : void 0,
			done: true
		};
	}
}
function __exportStar(m, o) {
	for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
	var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i$1 = 0;
	if (m) return m.call(o);
	if (o && typeof o.length === "number") return { next: function() {
		if (o && i$1 >= o.length) o = void 0;
		return {
			value: o && o[i$1++],
			done: !o
		};
	} };
	throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
	var m = typeof Symbol === "function" && o[Symbol.iterator];
	if (!m) return o;
	var i$1 = m.call(o), r, ar = [], e;
	try {
		while ((n === void 0 || n-- > 0) && !(r = i$1.next()).done) ar.push(r.value);
	} catch (error) {
		e = { error };
	} finally {
		try {
			if (r && !r.done && (m = i$1["return"])) m.call(i$1);
		} finally {
			if (e) throw e.error;
		}
	}
	return ar;
}
/** @deprecated */
function __spread() {
	for (var ar = [], i$1 = 0; i$1 < arguments.length; i$1++) ar = ar.concat(__read(arguments[i$1]));
	return ar;
}
/** @deprecated */
function __spreadArrays() {
	for (var s = 0, i$1 = 0, il = arguments.length; i$1 < il; i$1++) s += arguments[i$1].length;
	for (var r = Array(s), k = 0, i$1 = 0; i$1 < il; i$1++) for (var a = arguments[i$1], j$1 = 0, jl = a.length; j$1 < jl; j$1++, k++) r[k] = a[j$1];
	return r;
}
function __spreadArray(to, from, pack) {
	if (pack || arguments.length === 2) {
		for (var i$1 = 0, l = from.length, ar; i$1 < l; i$1++) if (ar || !(i$1 in from)) {
			if (!ar) ar = Array.prototype.slice.call(from, 0, i$1);
			ar[i$1] = from[i$1];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
	return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var g = generator.apply(thisArg, _arguments || []), i$1, q = [];
	return i$1 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i$1[Symbol.asyncIterator] = function() {
		return this;
	}, i$1;
	function awaitReturn(f) {
		return function(v) {
			return Promise.resolve(v).then(f, reject);
		};
	}
	function verb(n, f) {
		if (g[n]) {
			i$1[n] = function(v) {
				return new Promise(function(a, b) {
					q.push([
						n,
						v,
						a,
						b
					]) > 1 || resume(n, v);
				});
			};
			if (f) i$1[n] = f(i$1[n]);
		}
	}
	function resume(n, v) {
		try {
			step(g[n](v));
		} catch (e) {
			settle(q[0][3], e);
		}
	}
	function step(r) {
		r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
	}
	function fulfill(value) {
		resume("next", value);
	}
	function reject(value) {
		resume("throw", value);
	}
	function settle(f, v) {
		if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
	}
}
function __asyncDelegator(o) {
	var i$1, p;
	return i$1 = {}, verb("next"), verb("throw", function(e) {
		throw e;
	}), verb("return"), i$1[Symbol.iterator] = function() {
		return this;
	}, i$1;
	function verb(n, f) {
		i$1[n] = o[n] ? function(v) {
			return (p = !p) ? {
				value: __await(o[n](v)),
				done: false
			} : f ? f(v) : v;
		} : f;
	}
}
function __asyncValues(o) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m = o[Symbol.asyncIterator], i$1;
	return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i$1 = {}, verb("next"), verb("throw"), verb("return"), i$1[Symbol.asyncIterator] = function() {
		return this;
	}, i$1);
	function verb(n) {
		i$1[n] = o[n] && function(v) {
			return new Promise(function(resolve, reject) {
				v = o[n](v), settle(resolve, reject, v.done, v.value);
			});
		};
	}
	function settle(resolve, reject, d, v) {
		Promise.resolve(v).then(function(v$1) {
			resolve({
				value: v$1,
				done: d
			});
		}, reject);
	}
}
function __makeTemplateObject(cooked, raw) {
	if (Object.defineProperty) Object.defineProperty(cooked, "raw", { value: raw });
	else cooked.raw = raw;
	return cooked;
}
function __importStar(mod) {
	if (mod && mod.__esModule) return mod;
	var result = {};
	if (mod != null) {
		for (var k = ownKeys(mod), i$1 = 0; i$1 < k.length; i$1++) if (k[i$1] !== "default") __createBinding(result, mod, k[i$1]);
	}
	__setModuleDefault(result, mod);
	return result;
}
function __importDefault(mod) {
	return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
	if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
	return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
	if (value !== null && value !== void 0) {
		if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
		var dispose, inner;
		if (async) {
			if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
			dispose = value[Symbol.asyncDispose];
		}
		if (dispose === void 0) {
			if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
			dispose = value[Symbol.dispose];
			if (async) inner = dispose;
		}
		if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e) {
				return Promise.reject(e);
			}
		};
		env.stack.push({
			value,
			dispose,
			async
		});
	} else if (async) env.stack.push({ async: true });
	return value;
}
function __disposeResources(env) {
	function fail(e) {
		env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
		env.hasError = true;
	}
	var r, s = 0;
	function next() {
		while (r = env.stack.pop()) try {
			if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
			if (r.dispose) {
				var result = r.dispose.call(r.value);
				if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
					fail(e);
					return next();
				});
			} else s |= 1;
		} catch (e) {
			fail(e);
		}
		if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
		if (env.hasError) throw env.error;
	}
	return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
	if (typeof path === "string" && /^\.\.?\//.test(path)) return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
		return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
	});
	return path;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({ "../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs"() {
	extendStatics = function(d, b) {
		extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
			d$1.__proto__ = b$1;
		} || function(d$1, b$1) {
			for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
		};
		return extendStatics(d, b);
	};
	__assign = function() {
		__assign = Object.assign || function __assign$1(t) {
			for (var s, i$1 = 1, n = arguments.length; i$1 < n; i$1++) {
				s = arguments[i$1];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	__createBinding = Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	};
	__setModuleDefault = Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	};
	ownKeys = function(o) {
		ownKeys = Object.getOwnPropertyNames || function(o$1) {
			var ar = [];
			for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
			return ar;
		};
		return ownKeys(o);
	};
	_SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
		var e = new Error(message);
		return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};
	tslib_es6_default = {
		__extends,
		__assign,
		__rest,
		__decorate,
		__param,
		__esDecorate,
		__runInitializers,
		__propKey,
		__setFunctionName,
		__metadata,
		__awaiter,
		__generator,
		__createBinding,
		__exportStar,
		__values,
		__read,
		__spread,
		__spreadArrays,
		__spreadArray,
		__await,
		__asyncGenerator,
		__asyncDelegator,
		__asyncValues,
		__makeTemplateObject,
		__importStar,
		__importDefault,
		__classPrivateFieldGet,
		__classPrivateFieldSet,
		__classPrivateFieldIn,
		__addDisposableResource,
		__disposeResources,
		__rewriteRelativeImportExtension
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/AsyncStack.js
var require_AsyncStack = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/AsyncStack.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AsyncStack = void 0;
	const GlobalSymbol = Symbol("Global");
	var AsyncStack = class AsyncStack {
		static getCurrent() {
			const current = this.current;
			return current;
		}
		static set(ctx) {
			this.current = ctx;
		}
		static fork() {
			const origin = AsyncStack.getCurrent();
			const fork = new AsyncStack(origin);
			fork.start();
			return fork;
		}
		constructor(origin) {
			if (origin !== GlobalSymbol) this.origin = origin;
		}
		start() {
			AsyncStack.set(this);
		}
		yield() {
			AsyncStack.set(this.origin);
		}
	};
	exports.AsyncStack = AsyncStack;
	AsyncStack.Global = new AsyncStack(GlobalSymbol);
	AsyncStack.current = AsyncStack.Global;
	AsyncStack.NO_DATA = Symbol("NO_DATA");
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/_lib.js
var require__lib = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/_lib.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.runInStack = exports.withContext = exports.createAsyncResolver = void 0;
	exports.callWithContext = callWithContext;
	const AsyncStack_1$4 = require_AsyncStack();
	const createAsyncResolver = (stack, callback, onlyOnce = true) => {
		let called = false;
		return function(...args) {
			if (onlyOnce && called) return;
			called = true;
			stack.yield();
			const result = callback.call(this, ...args);
			return result;
		};
	};
	exports.createAsyncResolver = createAsyncResolver;
	function callWithContext(originalCallback, args) {
		const fork = AsyncStack_1$4.AsyncStack.fork();
		const patchedArgs = args.map((arg) => {
			if (typeof arg === "function") return (0, exports.createAsyncResolver)(fork, arg);
			return arg;
		});
		const result = originalCallback.call(this, ...patchedArgs);
		fork.yield();
		return result;
	}
	const withContext = (originalCallback, onlyOnce = true) => {
		if (typeof originalCallback === "undefined") return void 0;
		return function(...args) {
			return callWithContext.call(this, originalCallback, args);
		};
	};
	exports.withContext = withContext;
	const runInStack = (stackToUse, callback) => {
		const currentStack = AsyncStack_1$4.AsyncStack.getCurrent();
		stackToUse.start();
		try {
			const result = callback();
			currentStack.start();
			return result;
		} catch (err) {
			currentStack.start();
			throw err;
		}
	};
	exports.runInStack = runInStack;
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Promise.js
var require_Promise = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Promise.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PromiseWithContext = exports.OriginalPromise = void 0;
	const AsyncStack_1$3 = require_AsyncStack();
	const _lib_1$2 = require__lib();
	exports.OriginalPromise = Promise;
	var PromiseWithContext = class extends exports.OriginalPromise {
		constructor(callback) {
			super((resolve, reject) => {
				const fork = AsyncStack_1$3.AsyncStack.fork();
				const wrapResolve = (0, _lib_1$2.createAsyncResolver)(fork, resolve);
				const wrapReject = (0, _lib_1$2.createAsyncResolver)(fork, reject);
				callback(wrapResolve, wrapReject);
				fork.yield();
			});
		}
		then(...args) {
			return _lib_1$2.callWithContext.call(this, super.then, args);
		}
		catch(...args) {
			return _lib_1$2.callWithContext.call(this, super.catch, args);
		}
		finally(...args) {
			return _lib_1$2.callWithContext.call(this, super.finally, args);
		}
	};
	exports.PromiseWithContext = PromiseWithContext;
	Object.getOwnPropertyNames(Promise).forEach((method) => {
		if (typeof Promise[method] === "function") PromiseWithContext[method] = exports.OriginalPromise[method].bind(PromiseWithContext);
	});
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Events.js
var require_Events = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Events.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.addEventListenerWithContext = exports.dispatchWithContext = void 0;
	const AsyncStack_1$2 = require_AsyncStack();
	const _lib_1$1 = require__lib();
	const originalAddEventListerner = EventTarget.prototype.addEventListener;
	const originalDispatchEvent = EventTarget.prototype.dispatchEvent;
	const stackByEvent = /* @__PURE__ */ new WeakMap();
	const dispatchWithContext = function(event) {
		const stack = AsyncStack_1$2.AsyncStack.getCurrent();
		stackByEvent.set(event, stack);
		return originalDispatchEvent.call(this, event);
	};
	exports.dispatchWithContext = dispatchWithContext;
	const addEventListenerWithContext = function(event, callback, options) {
		const wrappedCallback = function(event$1) {
			const stackWhenDispatched = stackByEvent.get(event$1) || AsyncStack_1$2.AsyncStack.Global;
			return (0, _lib_1$1.runInStack)(stackWhenDispatched, () => {
				return callback.call(this, event$1);
			});
		};
		return originalAddEventListerner.call(this, event, wrappedCallback, options);
	};
	exports.addEventListenerWithContext = addEventListenerWithContext;
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Polyfill.js
var require_Polyfill = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Polyfill.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Polyfill = void 0;
	const Promise_1 = require_Promise();
	const Events_1 = require_Events();
	const _lib_1 = require__lib();
	const root = typeof global !== "undefined" && global || typeof window !== "undefined" && window;
	var Polyfill = class Polyfill {
		static ensureEnabled() {
			if (Polyfill.enabled) return;
			Polyfill.enabled = true;
			root.Promise = Promise_1.PromiseWithContext;
			root.setTimeout = (0, _lib_1.withContext)(root.setTimeout);
			root.setInterval = (0, _lib_1.withContext)(root.setInterval);
			root.setImmediate = (0, _lib_1.withContext)(root.setImmediate);
			EventTarget.prototype.addEventListener = Events_1.addEventListenerWithContext;
			EventTarget.prototype.dispatchEvent = Events_1.dispatchWithContext;
		}
	};
	exports.Polyfill = Polyfill;
	Polyfill.originalSetTimeout = setTimeout;
	Polyfill.OriginalPromise = Promise_1.OriginalPromise;
	Polyfill.enabled = false;
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/utils/runInFork.js
var require_runInFork = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/utils/runInFork.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.runInFork = void 0;
	const runInFork = (callback) => {
		let result;
		let error;
		new Promise((resolve) => {
			try {
				result = callback();
				resolve(result);
			} catch (err) {
				error = err;
			}
		});
		if (error) throw error;
		return result;
	};
	exports.runInFork = runInFork;
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncVariable.js
var require_AsyncVariable = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncVariable.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AsyncVariable = void 0;
	const AsyncStack_1$1 = require_AsyncStack();
	const runInFork_1$1 = require_runInFork();
	var AsyncVariable = class AsyncVariable {
		constructor() {
			this.data = /* @__PURE__ */ new WeakMap();
		}
		static registerVariable(variable, stack) {
			if (!AsyncVariable.variableByStack.has(stack)) AsyncVariable.variableByStack.set(stack, /* @__PURE__ */ new Set());
			AsyncVariable.variableByStack.get(stack).add(variable);
		}
		getBox(stack) {
			if (!stack) return void 0;
			const currentBox = this.data.get(stack);
			if (currentBox) return currentBox;
			const canWalkOrigin = AsyncVariable.stopWalkAt.has(stack);
			if (canWalkOrigin) return void 0;
			const parentBox = this.getBox(stack.origin);
			if (parentBox) this.setBox(stack, parentBox);
			return parentBox;
		}
		setBox(stack, box) {
			AsyncVariable.registerVariable(this, stack);
			this.data.set(stack, box);
		}
		set(stack, data) {
			this.setBox(stack, { value: data });
		}
		get() {
			var _a;
			const current = AsyncStack_1$1.AsyncStack.getCurrent();
			return (_a = this.getBox(current)) === null || _a === void 0 ? void 0 : _a.value;
		}
		run(data, callback) {
			return (0, runInFork_1$1.runInFork)(() => {
				const current = AsyncStack_1$1.AsyncStack.getCurrent();
				this.set(current, data);
				return callback();
			});
		}
		wrap(data, callback) {
			return (...args) => this.run(data, () => callback(...args));
		}
	};
	exports.AsyncVariable = AsyncVariable;
	AsyncVariable.stopWalkAt = /* @__PURE__ */ new WeakSet();
	AsyncVariable.variableByStack = /* @__PURE__ */ new WeakMap();
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncSnapshot.js
var require_AsyncSnapshot = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncSnapshot.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AsyncSnapshot = void 0;
	const AsyncStack_1 = require_AsyncStack();
	const AsyncVariable_1$1 = require_AsyncVariable();
	const runInFork_1 = require_runInFork();
	var AsyncSnapshot = class AsyncSnapshot {
		capture() {
			let current = AsyncStack_1.AsyncStack.getCurrent();
			while (current) {
				const variables = AsyncVariable_1$1.AsyncVariable.variableByStack.get(current);
				variables === null || variables === void 0 || variables.forEach((variable) => {
					const alreadyHasVariable = this.dataByVariable.has(variable);
					if (!alreadyHasVariable) {
						const value = variable.get();
						this.dataByVariable.set(variable, value);
					}
				});
				current = current.origin;
			}
		}
		constructor() {
			this.dataByVariable = /* @__PURE__ */ new Map();
			this.capture();
		}
		static create() {
			const snapshot = new AsyncSnapshot();
			return snapshot;
		}
		run(callback) {
			return (0, runInFork_1.runInFork)(() => {
				const current = AsyncStack_1.AsyncStack.getCurrent();
				AsyncVariable_1$1.AsyncVariable.stopWalkAt.add(current);
				this.dataByVariable.forEach((data, variable) => {
					variable.set(current, data);
				});
				return callback();
			});
		}
		wrap(callback) {
			return (...args) => this.run(() => callback(...args));
		}
		static wrap(callback) {
			return (0, runInFork_1.runInFork)(() => {
				const snapshot = AsyncSnapshot.create();
				return snapshot.wrap(callback);
			});
		}
	};
	exports.AsyncSnapshot = AsyncSnapshot;
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncContext.js
var require_AsyncContext = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncContext.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AsyncContext = void 0;
	const AsyncVariable_1 = require_AsyncVariable();
	const AsyncSnapshot_1 = require_AsyncSnapshot();
	var AsyncContext$2 = class {};
	exports.AsyncContext = AsyncContext$2;
	AsyncContext$2.Variable = AsyncVariable_1.AsyncVariable;
	AsyncContext$2.Snapshot = AsyncSnapshot_1.AsyncSnapshot;
} });

//#endregion
//#region ../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/index.js
var require_build = __commonJS({ "../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	const Polyfill_1 = require_Polyfill();
	Polyfill_1.Polyfill.ensureEnabled();
	tslib_1.__exportStar(require_AsyncContext(), exports);
} });

//#endregion
//#region src/async-context/index.browser.ts
var import_build = __toESM(require_build(), 1);

//#endregion
//#region src/core/event.ts
const eventMap = /* @__PURE__ */ new WeakMap();
const refMap = /* @__PURE__ */ new WeakMap();
const initCallbackMap = /* @__PURE__ */ new WeakMap();
let i = 0;
let j = 0;
/**
* Creates a new workflow event type.
*
* This is the primary factory function for creating event types that can be used
* in workflows. Each event type can carry specific data and be used to trigger
* handlers throughout the workflow system.
*
* @typeParam Data - The type of data this event will carry (defaults to void)
* @typeParam DebugLabel - Optional debug label type for development
*
* @param config - Optional configuration for the event type
* @returns A new workflow event type that can be instantiated with data
*
* @example
* ```typescript
* // Create a simple event with no data
* const StartEvent = workflowEvent();
*
* // Create an event that carries user data
* const UserEvent = workflowEvent<{ name: string; email: string }>({
*   debugLabel: 'UserEvent'
* });
*
* // Create event instances
* const start = StartEvent.with();
* const user = UserEvent.with({ name: 'John', email: 'john@example.com' });
* ```
*
* @category Events
* @public
*/
const workflowEvent = (config) => {
	const l1 = `${i++}`;
	const cb = /* @__PURE__ */ new Set();
	const event = {
		debugLabel: config?.debugLabel ?? l1,
		include: (instance) => s.has(instance),
		with: (data) => {
			const l2 = `${j++}`;
			const ref = {
				[Symbol.toStringTag]: config?.debugLabel ?? `WorkflowEvent(${l1}.${l2})`,
				toString: () => config?.debugLabel ? config.debugLabel : `WorkflowEvent(${l1}.${l2})`,
				toJSON: () => {
					return {
						type: config?.debugLabel ? config.debugLabel : l1,
						data
					};
				},
				get data() {
					return data;
				}
			};
			s.add(ref);
			refMap.set(ref, event);
			cb.forEach((c) => c(ref));
			return ref;
		},
		onInit: (callback) => {
			cb.add(callback);
			return () => {
				cb.delete(callback);
			};
		}
	};
	const s = /* @__PURE__ */ new WeakSet();
	eventMap.set(event, s);
	initCallbackMap.set(event, cb);
	Object.defineProperty(event, Symbol.toStringTag, { get: () => event?.debugLabel ?? `WorkflowEvent<${l1}>` });
	Object.defineProperty(event, "displayName", { value: event?.debugLabel ?? `WorkflowEvent<${l1}>` });
	let uniqueId = config?.uniqueId;
	Object.defineProperty(event, "uniqueId", {
		get: () => {
			if (!uniqueId) uniqueId = l1;
			return uniqueId;
		},
		set: () => {
			throw new Error("uniqueId is readonly");
		}
	});
	event.toString = () => config?.debugLabel ?? `WorkflowEvent<${l1}>`;
	return event;
};
const isWorkflowEvent = (instance) => typeof instance === "object" && instance !== null ? eventMap.has(instance) : false;
const isWorkflowEventData = (instance) => typeof instance === "object" && instance !== null ? refMap.has(instance) : false;
const eventSource = (instance) => typeof instance === "object" && instance !== null ? refMap.get(instance) : void 0;
const or = (...events) => {
	const debugLabel = `or(${events.map((e) => e.debugLabel || e.uniqueId).join(", ")})`;
	const l1 = `or_${i++}`;
	const orEvent = {
		_type: "or",
		events,
		debugLabel,
		include: (eventData) => {
			return events.some((event) => event.include(eventData)) || s.has(eventData);
		},
		with: (data) => {
			const ref = {
				[Symbol.toStringTag]: debugLabel,
				toString: () => debugLabel,
				toJSON: () => ({
					type: debugLabel,
					data
				}),
				get data() {
					return data;
				}
			};
			s.add(ref);
			refMap.set(ref, orEvent);
			return ref;
		}
	};
	const s = /* @__PURE__ */ new WeakSet();
	eventMap.set(orEvent, s);
	let uniqueId;
	Object.defineProperty(orEvent, "uniqueId", {
		get: () => {
			if (!uniqueId) uniqueId = l1;
			return uniqueId;
		},
		set: () => {
			throw new Error("uniqueId is readonly");
		}
	});
	Object.defineProperty(orEvent, Symbol.toStringTag, { get: () => debugLabel });
	Object.defineProperty(orEvent, "displayName", { value: debugLabel });
	orEvent.toString = () => debugLabel;
	return orEvent;
};

//#endregion
//#region src/core/utils.ts
const isEventData = (data) => data != null && typeof data === "object" && "data" in data;
const isPromiseLike = (value) => value != null && typeof value.then === "function";
function flattenEvents(acceptEventTypes, inputEventData) {
	const acceptance = new Array(acceptEventTypes.length);
	for (const eventData of inputEventData) for (let i$1 = 0; i$1 < acceptEventTypes.length; i$1++) {
		if (acceptance[i$1]) continue;
		if (acceptEventTypes[i$1].include(eventData)) {
			acceptance[i$1] = eventData;
			break;
		}
	}
	return acceptance.filter(Boolean);
}
const __internal__subscribesSourcemap = /* @__PURE__ */ new WeakMap();
/**
* @internal
*/
function getSubscribers(subscribable) {
	return __internal__subscribesSourcemap.get(subscribable);
}
/**
* @internal
*/
function createSubscribable() {
	const subscribers = /* @__PURE__ */ new Set();
	const obj = {
		subscribe: (callback) => {
			subscribers.add(callback);
			return () => {
				subscribers.delete(callback);
			};
		},
		publish: (...args) => {
			const results = [];
			for (const callback of subscribers) results.push(callback(...args));
			return results;
		}
	};
	__internal__subscribesSourcemap.set(obj, subscribers);
	return obj;
}

//#endregion
//#region src/core/stream.ts
var JsonEncodeTransform = class extends TransformStream {
	constructor() {
		super({ transform: (event, controller) => {
			if (eventSource(event)) controller.enqueue(JSON.stringify({
				data: event.data,
				uniqueId: eventSource(event).uniqueId
			}) + "\n");
		} });
	}
};
var JsonDecodeTransform = class extends TransformStream {
	#eventMap;
	constructor(eventMap$1) {
		super({ transform: (data, controller) => {
			const lines = data.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
			lines.forEach((line) => {
				const eventData = JSON.parse(line);
				const targetEvent = Object.values(this.#eventMap).find((e) => e.uniqueId === eventData.uniqueId);
				if (targetEvent) {
					const ev = targetEvent.with(eventData.data);
					controller.enqueue(ev);
				} else console.warn(`Unknown event: ${eventData.uniqueId}`);
			});
		} });
		this.#eventMap = eventMap$1;
	}
};
/**
* A reactive stream for processing workflow events.
*
* WorkflowStream extends the standard ReadableStream to provide specialized
* methods for filtering, transforming, and consuming workflow events.
* It supports reactive patterns and can be used to build complex event
* processing pipelines.
*
* @typeParam R - The type of data flowing through the stream
*
* @example
* ```typescript
* // Get stream from workflow context
* const stream = context.stream;
*
* // Filter for specific events
* const userEvents = stream.filter(UserEvent);
*
* // Transform events
* const processed = stream.map(event => ({
*   type: event.constructor.name,
*   timestamp: Date.now(),
*   data: event.data
* }));
*
* // Consume events
* for await (const event of stream.take(10)) {
*   console.log('Received:', event);
* }
* ```
*
* @category Streaming
* @public
*/
var WorkflowStream = class WorkflowStream extends ReadableStream {
	#stream;
	#subscribable;
	/**
	* Subscribe to specific workflow events.
	*
	* @param event - The event type to listen for
	* @param handler - Function to handle the event
	* @returns Unsubscribe function
	*
	* @example
	* ```typescript
	* const unsubscribe = stream.on(UserEvent, (event) => {
	*   console.log('User event:', event.data);
	* });
	*
	* // Later...
	* unsubscribe();
	* ```
	*/
	on(event, handler) {
		return this.#subscribable.subscribe((ev) => {
			if (event.include(ev)) handler(ev);
		});
	}
	constructor(subscribable, rootStream) {
		if (!subscribable && !rootStream) throw new TypeError("Either subscribable or root stream must be provided");
		super();
		if (!subscribable) {
			this.#subscribable = createSubscribable();
			this.#stream = rootStream.pipeThrough(new TransformStream({ transform: (ev, controller) => {
				this.#subscribable.publish(ev);
				controller.enqueue(ev);
			} }));
			return;
		} else {
			this.#subscribable = subscribable;
			let unsubscribe;
			this.#stream = rootStream ?? new ReadableStream({
				start: (controller) => {
					unsubscribe = subscribable.subscribe((event) => {
						controller.enqueue(event);
					});
				},
				cancel: () => {
					unsubscribe();
				}
			});
		}
	}
	/**
	* Create a WorkflowStream from a standard ReadableStream.
	*
	* @param stream - The ReadableStream to wrap
	* @returns A new WorkflowStream instance
	*/
	static fromReadableStream(stream) {
		return new WorkflowStream(null, stream.pipeThrough(new TransformStream({ transform: (event, controller) => {
			controller.enqueue(event);
		} })));
	}
	/**
	* Create a WorkflowStream from an HTTP Response.
	*
	* @param response - The HTTP Response containing workflow events
	* @param eventMap - Map of event unique IDs to event constructors
	* @returns A new WorkflowStream instance
	*/
	static fromResponse(response, eventMap$1) {
		const body = response.body;
		if (!body) throw new Error("Response body is not readable");
		return new WorkflowStream(null, body.pipeThrough(new TextDecoderStream()).pipeThrough(new JsonDecodeTransform(eventMap$1)));
	}
	/**
	* Convert the stream to an HTTP Response.
	*
	* @param init - Optional ResponseInit parameters
	* @param transformer - Optional custom transformer (defaults to JSON encoding)
	* @returns HTTP Response containing the stream data
	*/
	toResponse(init, transformer = new JsonEncodeTransform()) {
		return new Response(this.#stream.pipeThrough(transformer).pipeThrough(new TextEncoderStream()), init);
	}
	/** @internal */
	get locked() {
		return this.#stream.locked;
	}
	/** @internal */
	[Symbol.asyncIterator]() {
		return this.#stream[Symbol.asyncIterator]();
	}
	/** @internal */
	cancel(reason) {
		return this.#stream.cancel(reason);
	}
	getReader() {
		return this.#stream.getReader();
	}
	/** @internal */
	pipeThrough(transform, options) {
		const stream = this.#stream.pipeThrough(transform, options);
		return new WorkflowStream(null, stream);
	}
	/** @internal */
	pipeTo(destination, options) {
		return this.#stream.pipeTo(destination, options);
	}
	/** @internal */
	tee() {
		const [l, r] = this.#stream.tee();
		return [new WorkflowStream(this.#subscribable, l), new WorkflowStream(this.#subscribable, r)];
	}
	/**
	* Process each item in the stream with a callback function.
	*
	* @param callback - Function to call for each item
	* @returns Promise that resolves when all items are processed
	*
	* @example
	* ```typescript
	* await stream.forEach(event => {
	*   console.log('Processing:', event);
	* });
	* ```
	*/
	forEach(callback) {
		return this.#stream.pipeTo(new WritableStream({ write: (item) => {
			callback(item);
		} }));
	}
	/**
	* Transform each item in the stream.
	*
	* @param callback - Function to transform each item
	* @returns A new WorkflowStream with transformed items
	*
	* @example
	* ```typescript
	* const timestamps = stream.map(event => ({
	*   ...event,
	*   timestamp: Date.now()
	* }));
	* ```
	*/
	map(callback) {
		return this.pipeThrough(new TransformStream({ transform: (item, controller) => {
			controller.enqueue(callback(item));
		} }));
	}
	/** @internal */
	values(options) {
		return this.#stream.values(options);
	}
	/**
	* Take only the first N items from the stream.
	*
	* @param limit - Maximum number of items to take
	* @returns A new WorkflowStream limited to the specified number of items
	*
	* @example
	* ```typescript
	* const firstTen = stream.take(10);
	* for await (const event of firstTen) {
	*   console.log(event);
	* }
	* ```
	*/
	take(limit) {
		let count = 0;
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			if (count < limit) {
				controller.enqueue(ev);
				count++;
			}
			if (count >= limit) controller.terminate();
		} }));
	}
	filter(predicate) {
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			if (typeof predicate === "function" ? predicate(ev) : isWorkflowEvent(predicate) ? predicate.include(ev) : predicate === ev) controller.enqueue(ev);
		} }));
	}
	until(predicate) {
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			controller.enqueue(ev);
			if (typeof predicate === "function" ? predicate(ev) : isWorkflowEvent(predicate) ? predicate.include(ev) : predicate === ev) controller.terminate();
		} }));
	}
	async untilEvent(predicate) {
		const events = await this.until(predicate).toArray();
		const lastEvent = events[events.length - 1];
		if (!lastEvent) throw new Error("Stream ended without matching event");
		const matches = typeof predicate === "function" ? predicate(lastEvent) : isWorkflowEvent(predicate) ? predicate.include(lastEvent) : predicate === lastEvent;
		if (!matches) throw new Error("Stream ended without matching event");
		return lastEvent;
	}
	/**
	* Collect all items from the stream into an array.
	*
	* @returns Promise resolving to an array of all stream items
	*
	* @example
	* ```typescript
	* const events = await stream.take(5).toArray();
	* console.log('Collected events:', events);
	* ```
	*/
	async toArray() {
		const events = [];
		await this.pipeTo(new WritableStream({ write: (event) => {
			events.push(event);
		} }));
		return events;
	}
};

//#endregion
//#region src/core/context.ts
const _executorAsyncLocalStorage = new import_build.AsyncContext.Variable();
/**
* @deprecated Use the context parameter directly from workflow handlers instead.
* The context passed to handlers already includes all state properties.
*
* @example
* ```ts
* workflow.handle([startEvent], (context, event) => {
*   const { sendEvent } = context;
*   sendEvent(processEvent.with());
* });
* ```
*/
function getContext() {
	const context = _executorAsyncLocalStorage.get();
	if (!context) throw new Error("No current context found");
	return context;
}
/**
* Use this function to add or extend properties of the root context.
* Called by middleware's createContext to update the root context.
* Handler-scoped contexts will automatically inherit these properties from the root context.
* Never create a new object (e.g., using a spread `{...context}`) in your middleware's createContext.
*
* @param context The context to extend
* @param properties The properties to add to the context
* @param inheritanceTransformers The inheritance transformers to apply to existing properties (optional)
*/
function extendContext(context, properties, inheritanceTransformers) {
	Object.assign(context, properties);
	if (inheritanceTransformers) {
		if (!context.__internal__property_inheritance_handlers) context.__internal__property_inheritance_handlers = /* @__PURE__ */ new Map();
		for (const [propertyKey, transformer] of Object.entries(inheritanceTransformers)) {
			context.__internal__property_inheritance_handlers.set(propertyKey, transformer);
			const rootDescriptor = Object.getOwnPropertyDescriptor(context, propertyKey);
			if (rootDescriptor) {
				const newDescriptor = transformer(context, rootDescriptor);
				Object.defineProperty(context, propertyKey, newDescriptor);
			}
		}
	}
}
const handlerContextAsyncLocalStorage = new import_build.AsyncContext.Variable();
const eventContextWeakMap = /* @__PURE__ */ new WeakMap();
const createContext = ({ listeners }) => {
	const queue = [];
	let rootWorkflowContext;
	const runHandler = (handler, inputEvents, inputs, parentContext) => {
		let handlerAbortController;
		const handlerContext = {
			get abortController() {
				if (!handlerAbortController) handlerAbortController = new AbortController();
				return handlerAbortController;
			},
			async: "constructor" in handler ? handler.constructor.name === "AsyncFunction" : false,
			pending: null,
			handler,
			inputEvents,
			inputs,
			outputs: [],
			prev: parentContext,
			next: /* @__PURE__ */ new Set(),
			get root() {
				return handlerRootContext;
			}
		};
		handlerContext.prev.next.add(handlerContext);
		const specificContext = createWorkflowContext(handlerContext);
		const workflowContext = Object.create(rootWorkflowContext);
		const specificDescriptors = Object.getOwnPropertyDescriptors(specificContext);
		if (rootWorkflowContext.__internal__property_inheritance_handlers) {
			for (const [propertyKey, transformer] of rootWorkflowContext.__internal__property_inheritance_handlers) if (propertyKey in specificDescriptors) {
				const originalDescriptor = specificDescriptors[propertyKey];
				if (originalDescriptor) {
					const newDescriptor = transformer(workflowContext, originalDescriptor);
					specificDescriptors[propertyKey] = newDescriptor;
				}
			}
		}
		Object.defineProperties(workflowContext, specificDescriptors);
		handlerContextAsyncLocalStorage.run(handlerContext, () => {
			const cbs = [...new Set([...getSubscribers(rootWorkflowContext.__internal__call_context), ...getSubscribers(workflowContext.__internal__call_context)])];
			_executorAsyncLocalStorage.run(workflowContext, () => {
				let i$1 = 0;
				const next = (context) => {
					if (i$1 === cbs.length) {
						let result;
						try {
							result = context.handler(workflowContext, ...context.inputs);
						} catch (error) {
							if (handlerAbortController ?? rootAbortController) (handlerAbortController ?? rootAbortController).abort(error);
							else {
								console.error("unhandled error in handler", error);
								throw error;
							}
						}
						if (isPromiseLike(result)) {
							handlerContext.async = true;
							handlerContext.pending = result.then((event) => {
								if (isEventData(event)) workflowContext.sendEvent(event);
								return event;
							});
						} else if (isEventData(result)) workflowContext.sendEvent(result);
					}
					const cb = cbs[i$1];
					if (cb) {
						i$1++;
						cb(context, next);
					}
				};
				next(handlerContext);
			});
		});
	};
	const queueUpdateCallback = (handlerContext) => {
		const queueSnapshot = [...queue];
		[...listeners].filter(([events]) => {
			const inputs = flattenEvents(events, queueSnapshot);
			return inputs.length === events.length;
		}).map(([events, handlers]) => {
			const inputs = flattenEvents(events, queueSnapshot);
			inputs.forEach((input) => {
				queue.splice(queue.indexOf(input), 1);
			});
			for (const handler of handlers) runHandler(handler, events, inputs, handlerContext);
		});
	};
	const createWorkflowContext = (handlerContext) => {
		let lazyLoadStream = null;
		return {
			get stream() {
				if (!lazyLoadStream) {
					const subscribable = createSubscribable();
					rootWorkflowContext.__internal__call_send_event.subscribe((newEvent) => {
						let currentEventContext = eventContextWeakMap.get(newEvent);
						while (currentEventContext) {
							if (currentEventContext === handlerContext) {
								subscribable.publish(newEvent);
								break;
							}
							currentEventContext = currentEventContext.prev;
						}
					});
					lazyLoadStream = new WorkflowStream(subscribable, null);
				}
				return lazyLoadStream;
			},
			get signal() {
				return handlerContext.abortController.signal;
			},
			sendEvent: (...events) => {
				events.forEach((event) => {
					eventContextWeakMap.set(event, handlerContext);
					handlerContext.outputs.push(event);
					queue.push(event);
					rootWorkflowContext.__internal__call_send_event.publish(event, handlerContext);
					queueUpdateCallback(handlerContext);
				});
			},
			__internal__call_context: createSubscribable(),
			__internal__call_send_event: createSubscribable()
		};
	};
	let rootAbortController = new AbortController();
	const handlerRootContext = {
		get abortController() {
			if (!rootAbortController) rootAbortController = new AbortController();
			return rootAbortController;
		},
		async: false,
		pending: null,
		inputEvents: [],
		inputs: [],
		outputs: [],
		handler: null,
		prev: null,
		next: /* @__PURE__ */ new Set(),
		get root() {
			return handlerRootContext;
		}
	};
	rootWorkflowContext = createWorkflowContext(handlerRootContext);
	return rootWorkflowContext;
};

//#endregion
//#region src/core/workflow.ts
/**
* Creates a new workflow instance.
*
* This is the primary factory function for creating workflows. Each workflow
* maintains its own registry of event handlers and can create multiple
* independent execution contexts.
*
* @returns A new workflow instance
*
* @example
* ```typescript
* // Create a simple workflow
* const workflow = createWorkflow();
*
* // Register handlers
* workflow.handle([InputEvent], async (context, event) => {
*   const processed = await processInput(event.data);
*   return OutputEvent.with(processed);
* });
*
* // Use the workflow
* const context = workflow.createContext();
* const input = InputEvent.with({ text: 'Hello World' });
* await context.send(input);
* ```
*
* @category Workflow
* @public
*/
const createWorkflow = () => {
	const config = { steps: /* @__PURE__ */ new Map() };
	return {
		handle: (accept, handler) => {
			if (config.steps.has(accept)) {
				const set = config.steps.get(accept);
				set.add(handler);
			} else {
				const set = /* @__PURE__ */ new Set();
				set.add(handler);
				config.steps.set(accept, set);
			}
		},
		createContext() {
			return createContext({ listeners: config.steps });
		}
	};
};

//#endregion
export { WorkflowStream, createWorkflow, eventSource, extendContext, getContext, isWorkflowEvent, isWorkflowEventData, or, workflowEvent };
//# sourceMappingURL=index.js.map