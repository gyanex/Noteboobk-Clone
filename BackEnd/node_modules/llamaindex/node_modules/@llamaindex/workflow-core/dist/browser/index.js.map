{"version":3,"file":"index.js","names":["i","j","v","d","b","__assign","o","AsyncStack_1","AsyncStack_1","_lib_1","AsyncStack_1","_lib_1","event","AsyncStack_1","runInFork_1","AsyncVariable_1","AsyncContext","config?: WorkflowEventConfig<DebugLabel>","instance: WorkflowEventData<any>","data: Data","callback: Callback","instance: unknown","eventData: unknown","data: any","uniqueId: string","data: unknown","value: unknown","acceptEventTypes: WorkflowEvent<any>[]","inputEventData: WorkflowEventData<any>[]","acceptance: WorkflowEventData<any>[]","i","subscribable: Subscribable<Args, R>","callback: (...args: any) => any","results: unknown[]","event: WorkflowEventData<any>","controller: TransformStreamDefaultController<string>","eventMap: Record<string, WorkflowEvent<any>>","data: string","controller: TransformStreamDefaultController<WorkflowEventData<any>>","#eventMap","eventMap","event: WorkflowEvent<T>","handler: (event: WorkflowEventData<T>) => void","#subscribable","subscribable: Subscribable<[R], void> | null","rootStream: ReadableStream<R> | null","#stream","unsubscribe: () => void","stream: ReadableStream<WorkflowEventData<any>>","response: Response","init?: ResponseInit","reason?: any","transform: ReadableWritablePair<T, R>","options?: StreamPipeOptions","destination: WritableStream<R>","callback: (item: R) => void","item: R","callback: (item: R) => T","options?: ReadableStreamIteratorOptions","limit: number","predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | ((event: R) => boolean)\n      | R","predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | R\n      | ((item: R) => boolean)","events: R[]","AsyncContext","context: WorkflowContext","properties: Record<string, any>","inheritanceTransformers?: Record<string, InheritanceTransformer>","queue: WorkflowEventData<any>[]","rootWorkflowContext: WorkflowContext","handler: Handler<WorkflowEvent<any>[], any>","inputEvents: WorkflowEvent<any>[]","inputs: WorkflowEventData<any>[]","parentContext: HandlerContext","handlerAbortController: AbortController","handlerContext: HandlerContext","i","context: HandlerContext","result: any","lazyLoadStream: WorkflowStream | null","newEvent: WorkflowEventData<any>","handlerRootContext: HandlerContext","accept: AcceptEvents","handler: Handler<AcceptEvents, Result>"],"sources":["../../../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/AsyncStack.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/_lib.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Promise.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Events.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/polyfill/Polyfill.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/utils/runInFork.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncVariable.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncSnapshot.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/lib/AsyncContext.js","../../../../node_modules/.pnpm/simple-async-context@1.0.4/node_modules/simple-async-context/build/index.js","../../src/async-context/index.browser.ts","../../src/core/event.ts","../../src/core/utils.ts","../../src/core/stream.ts","../../src/core/context.ts","../../src/core/workflow.ts"],"sourcesContent":["/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncStack = void 0;\nconst GlobalSymbol = Symbol(\"Global\");\nclass AsyncStack {\n    static getCurrent() {\n        const current = this.current;\n        return current;\n    }\n    static set(ctx) {\n        this.current = ctx;\n    }\n    static fork() {\n        const origin = AsyncStack.getCurrent();\n        const fork = new AsyncStack(origin);\n        fork.start();\n        return fork;\n    }\n    constructor(origin) {\n        // @ts-expect-error\n        if (origin !== GlobalSymbol) {\n            this.origin = origin;\n        }\n    }\n    start() {\n        AsyncStack.set(this);\n    }\n    // private yielded = false\n    yield() {\n        // if (!this.yielded) return;\n        // this.yielded = true;\n        AsyncStack.set(this.origin);\n    }\n}\nexports.AsyncStack = AsyncStack;\n// @ts-expect-error\nAsyncStack.Global = new AsyncStack(GlobalSymbol);\nAsyncStack.current = AsyncStack.Global;\nAsyncStack.NO_DATA = Symbol(\"NO_DATA\");\n//# sourceMappingURL=AsyncStack.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.runInStack = exports.withContext = exports.createAsyncResolver = void 0;\nexports.callWithContext = callWithContext;\nconst AsyncStack_1 = require(\"./AsyncStack\");\nconst createAsyncResolver = (stack, callback, onlyOnce = true) => {\n    let called = false;\n    return function (...args) {\n        if (onlyOnce && called)\n            return;\n        called = true;\n        stack.yield();\n        // Note: Is this fork neecessary? All tests are passing without it.\n        // const fork = AsyncStack.fork()\n        const result = callback.call(this, ...args);\n        // fork.yield()\n        return result;\n    };\n};\nexports.createAsyncResolver = createAsyncResolver;\nfunction callWithContext(originalCallback, args) {\n    const fork = AsyncStack_1.AsyncStack.fork();\n    const patchedArgs = args.map((arg) => {\n        if (typeof arg === \"function\") {\n            return (0, exports.createAsyncResolver)(fork, arg);\n        }\n        return arg;\n    });\n    const result = originalCallback.call(this, ...patchedArgs);\n    fork.yield();\n    return result;\n}\n// This function ensure that the context is passed to the callback\n// That is called by the higher order function\nconst withContext = (originalCallback, onlyOnce = true) => {\n    if (typeof originalCallback === \"undefined\")\n        return undefined;\n    return function (...args) {\n        return callWithContext.call(this, originalCallback, args);\n    };\n};\nexports.withContext = withContext;\nconst runInStack = (stackToUse, callback) => {\n    const currentStack = AsyncStack_1.AsyncStack.getCurrent();\n    stackToUse.start();\n    try {\n        const result = callback();\n        currentStack.start();\n        return result;\n    }\n    catch (err) {\n        currentStack.start();\n        throw err;\n    }\n};\nexports.runInStack = runInStack;\n//# sourceMappingURL=_lib.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromiseWithContext = exports.OriginalPromise = void 0;\nconst AsyncStack_1 = require(\"./AsyncStack\");\nconst _lib_1 = require(\"./_lib\");\nexports.OriginalPromise = Promise;\nclass PromiseWithContext extends exports.OriginalPromise {\n    constructor(callback) {\n        super((resolve, reject) => {\n            const fork = AsyncStack_1.AsyncStack.fork();\n            const wrapResolve = (0, _lib_1.createAsyncResolver)(fork, resolve);\n            const wrapReject = (0, _lib_1.createAsyncResolver)(fork, reject);\n            callback(wrapResolve, wrapReject);\n            fork.yield();\n        });\n    }\n    then(...args) {\n        return _lib_1.callWithContext.call(this, super.then, args);\n    }\n    catch(...args) {\n        return _lib_1.callWithContext.call(this, super.catch, args);\n    }\n    finally(...args) {\n        return _lib_1.callWithContext.call(this, super.finally, args);\n    }\n}\nexports.PromiseWithContext = PromiseWithContext;\n// Ensure that all methods of the original Promise\n// are available on the new PromiseWithContext\nObject.getOwnPropertyNames(Promise).forEach((method) => {\n    if (typeof Promise[method] === \"function\") {\n        PromiseWithContext[method] =\n            exports.OriginalPromise[method].bind(PromiseWithContext);\n    }\n});\n//# sourceMappingURL=Promise.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addEventListenerWithContext = exports.dispatchWithContext = void 0;\nconst AsyncStack_1 = require(\"./AsyncStack\");\nconst _lib_1 = require(\"./_lib\");\nconst originalAddEventListerner = EventTarget.prototype.addEventListener;\nconst originalDispatchEvent = EventTarget.prototype.dispatchEvent;\nconst stackByEvent = new WeakMap();\nconst dispatchWithContext = function (event) {\n    const stack = AsyncStack_1.AsyncStack.getCurrent();\n    stackByEvent.set(event, stack);\n    return originalDispatchEvent.call(this, event);\n};\nexports.dispatchWithContext = dispatchWithContext;\nconst addEventListenerWithContext = function (event, callback, options) {\n    const wrappedCallback = function (event) {\n        const stackWhenDispatched = stackByEvent.get(event) || AsyncStack_1.AsyncStack.Global;\n        return (0, _lib_1.runInStack)(stackWhenDispatched, () => {\n            // @ts-ignore\n            return callback.call(this, event);\n        });\n    };\n    return originalAddEventListerner.call(this, event, wrappedCallback, options);\n};\nexports.addEventListenerWithContext = addEventListenerWithContext;\n//# sourceMappingURL=Events.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polyfill = void 0;\nconst Promise_1 = require(\"./Promise\");\nconst Events_1 = require(\"./Events\");\nconst _lib_1 = require(\"./_lib\");\nconst root = (typeof global !== \"undefined\" && global) ||\n    (typeof window !== \"undefined\" && window);\nclass Polyfill {\n    static ensureEnabled() {\n        if (Polyfill.enabled)\n            return;\n        Polyfill.enabled = true;\n        // Polyfill Promise\n        root.Promise = Promise_1.PromiseWithContext;\n        // Polyfill Timers\n        root.setTimeout = (0, _lib_1.withContext)(root.setTimeout);\n        root.setInterval = (0, _lib_1.withContext)(root.setInterval);\n        root.setImmediate = (0, _lib_1.withContext)(root.setImmediate);\n        EventTarget.prototype.addEventListener = Events_1.addEventListenerWithContext;\n        EventTarget.prototype.dispatchEvent = Events_1.dispatchWithContext;\n    }\n}\nexports.Polyfill = Polyfill;\nPolyfill.originalSetTimeout = setTimeout;\nPolyfill.OriginalPromise = Promise_1.OriginalPromise;\nPolyfill.enabled = false;\n//# sourceMappingURL=Polyfill.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.runInFork = void 0;\nconst runInFork = (callback) => {\n    let result;\n    let error;\n    new Promise((resolve) => {\n        try {\n            result = callback();\n            resolve(result);\n        }\n        catch (err) {\n            error = err;\n        }\n    });\n    if (error) {\n        throw error;\n    }\n    return result;\n};\nexports.runInFork = runInFork;\n//# sourceMappingURL=runInFork.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncVariable = void 0;\nconst AsyncStack_1 = require(\"../polyfill/AsyncStack\");\nconst runInFork_1 = require(\"./utils/runInFork\");\nclass AsyncVariable {\n    constructor() {\n        this.data = new WeakMap();\n    }\n    static registerVariable(variable, stack) {\n        if (!AsyncVariable.variableByStack.has(stack)) {\n            AsyncVariable.variableByStack.set(stack, new Set());\n        }\n        AsyncVariable.variableByStack.get(stack).add(variable);\n    }\n    getBox(stack) {\n        if (!stack)\n            return undefined;\n        const currentBox = this.data.get(stack);\n        if (currentBox)\n            return currentBox;\n        const canWalkOrigin = AsyncVariable.stopWalkAt.has(stack);\n        if (canWalkOrigin)\n            return undefined;\n        const parentBox = this.getBox(stack.origin);\n        if (parentBox)\n            this.setBox(stack, parentBox);\n        return parentBox;\n    }\n    setBox(stack, box) {\n        AsyncVariable.registerVariable(this, stack);\n        this.data.set(stack, box);\n    }\n    set(stack, data) {\n        this.setBox(stack, {\n            value: data,\n        });\n    }\n    get() {\n        var _a;\n        const current = AsyncStack_1.AsyncStack.getCurrent();\n        return (_a = this.getBox(current)) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    run(data, callback) {\n        return (0, runInFork_1.runInFork)(() => {\n            const current = AsyncStack_1.AsyncStack.getCurrent();\n            this.set(current, data);\n            return callback();\n        });\n    }\n    wrap(data, callback) {\n        // @ts-ignore\n        return (...args) => this.run(data, () => callback(...args));\n    }\n}\nexports.AsyncVariable = AsyncVariable;\nAsyncVariable.stopWalkAt = new WeakSet();\nAsyncVariable.variableByStack = new WeakMap();\n//# sourceMappingURL=AsyncVariable.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncSnapshot = void 0;\nconst AsyncStack_1 = require(\"../polyfill/AsyncStack\");\nconst AsyncVariable_1 = require(\"./AsyncVariable\");\nconst runInFork_1 = require(\"./utils/runInFork\");\nclass AsyncSnapshot {\n    capture() {\n        let current = AsyncStack_1.AsyncStack.getCurrent();\n        while (current) {\n            const variables = AsyncVariable_1.AsyncVariable.variableByStack.get(current);\n            variables === null || variables === void 0 ? void 0 : variables.forEach((variable) => {\n                const alreadyHasVariable = this.dataByVariable.has(variable);\n                if (!alreadyHasVariable) {\n                    const value = variable.get();\n                    this.dataByVariable.set(variable, value);\n                }\n            });\n            current = current.origin;\n        }\n    }\n    constructor() {\n        this.dataByVariable = new Map();\n        this.capture();\n    }\n    static create() {\n        const snapshot = new AsyncSnapshot();\n        return snapshot;\n    }\n    run(callback) {\n        return (0, runInFork_1.runInFork)(() => {\n            const current = AsyncStack_1.AsyncStack.getCurrent();\n            AsyncVariable_1.AsyncVariable.stopWalkAt.add(current);\n            this.dataByVariable.forEach((data, variable) => {\n                variable.set(current, data);\n            });\n            return callback();\n        });\n    }\n    wrap(callback) {\n        return (...args) => this.run(() => callback(...args));\n    }\n    static wrap(callback) {\n        return (0, runInFork_1.runInFork)(() => {\n            const snapshot = AsyncSnapshot.create();\n            return snapshot.wrap(callback);\n        });\n    }\n}\nexports.AsyncSnapshot = AsyncSnapshot;\n//# sourceMappingURL=AsyncSnapshot.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncContext = void 0;\nconst AsyncVariable_1 = require(\"./AsyncVariable\");\nconst AsyncSnapshot_1 = require(\"./AsyncSnapshot\");\nclass AsyncContext {\n}\nexports.AsyncContext = AsyncContext;\nAsyncContext.Variable = AsyncVariable_1.AsyncVariable;\nAsyncContext.Snapshot = AsyncSnapshot_1.AsyncSnapshot;\n//# sourceMappingURL=AsyncContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst Polyfill_1 = require(\"./polyfill/Polyfill\");\nPolyfill_1.Polyfill.ensureEnabled();\ntslib_1.__exportStar(require(\"./lib/AsyncContext\"), exports);\n//# sourceMappingURL=index.js.map","import { AsyncContext } from \"simple-async-context\";\n\nexport { AsyncContext };\n","declare const opaqueSymbol: unique symbol;\n\ntype Callback = (evd: WorkflowEventData<any>) => void;\n\ntype Cleanup = () => void;\n\nconst eventMap = new WeakMap<WorkflowEvent<any>, WeakSet<object>>();\nconst refMap = new WeakMap<WorkflowEventData<any>, WorkflowEvent<any>>();\nconst initCallbackMap = new WeakMap<WorkflowEvent<any>, Set<Callback>>();\nlet i = 0;\nlet j = 0;\n\nexport type InferWorkflowEventData<T> = T extends WorkflowEventData<infer U>\n  ? U\n  : T extends WorkflowEvent<infer U>\n    ? U\n    : never;\n\n/**\n * Represents event data flowing through a workflow.\n *\n * Event data is created when an event is instantiated with the `.with()` method.\n * It carries the actual payload and can be processed by event handlers.\n *\n * @typeParam Data - The type of data this event carries\n * @typeParam DebugLabel - Optional debug label for development/debugging\n *\n * @category Events\n * @public\n */\nexport type WorkflowEventData<Data, DebugLabel extends string = string> = {\n  get data(): Data;\n} & { readonly [opaqueSymbol]: DebugLabel };\n\n/**\n * Represents a workflow event type that can be instantiated with data.\n *\n * Events are the core building blocks of workflows. They define the structure\n * of data that flows through the system and can be used to trigger handlers.\n *\n * @typeParam Data - The type of data this event can carry\n * @typeParam DebugLabel - Optional debug label for development/debugging\n *\n * @example\n * ```typescript\n * // Create an event type\n * const UserLoginEvent = workflowEvent<{ userId: string; timestamp: Date }>();\n *\n * // Create event data\n * const loginData = UserLoginEvent.with({\n *   userId: 'user123',\n *   timestamp: new Date()\n * });\n *\n * // Check if data belongs to this event type\n * if (UserLoginEvent.include(someEventData)) {\n *   console.log('User ID:', someEventData.data.userId);\n * }\n * ```\n *\n * @category Events\n * @public\n */\nexport type WorkflowEvent<Data, DebugLabel extends string = string> = {\n  /**\n   * Optional label used for debugging and logging purposes.\n   */\n  debugLabel?: DebugLabel;\n  /**\n   * Unique identifier for the event type, used for serialization and network communication.\n   */\n  readonly uniqueId: string;\n\n  /**\n   * Creates event data with the provided payload.\n   *\n   * @param data - The data payload for this event instance\n   * @returns Event data that can be sent through workflow contexts\n   */\n  with(data: Data): WorkflowEventData<Data, DebugLabel>;\n\n  /**\n   * Type guard to check if unknown event data belongs to this event type.\n   *\n   * @param event - Unknown event data to check\n   * @returns True if the event data is of this event type\n   */\n  include(event: unknown): event is WorkflowEventData<Data, DebugLabel>;\n\n  /**\n   * Registers a callback to be called when this event type is instantiated.\n   *\n   * @param callback - Function to call when event is created\n   * @returns Cleanup function to remove the callback\n   */\n  onInit(callback: Callback): Cleanup;\n} & { readonly [opaqueSymbol]: DebugLabel };\n\n/**\n * Configuration options for creating workflow events.\n *\n * @typeParam DebugLabel - Optional debug label type\n *\n * @category Events\n * @public\n */\nexport type WorkflowEventConfig<DebugLabel extends string = string> = {\n  /** Optional debug label for development and logging */\n  debugLabel?: DebugLabel;\n  /** Optional unique identifier for the event type */\n  uniqueId?: string;\n};\n\n/**\n * Creates a new workflow event type.\n *\n * This is the primary factory function for creating event types that can be used\n * in workflows. Each event type can carry specific data and be used to trigger\n * handlers throughout the workflow system.\n *\n * @typeParam Data - The type of data this event will carry (defaults to void)\n * @typeParam DebugLabel - Optional debug label type for development\n *\n * @param config - Optional configuration for the event type\n * @returns A new workflow event type that can be instantiated with data\n *\n * @example\n * ```typescript\n * // Create a simple event with no data\n * const StartEvent = workflowEvent();\n *\n * // Create an event that carries user data\n * const UserEvent = workflowEvent<{ name: string; email: string }>({\n *   debugLabel: 'UserEvent'\n * });\n *\n * // Create event instances\n * const start = StartEvent.with();\n * const user = UserEvent.with({ name: 'John', email: 'john@example.com' });\n * ```\n *\n * @category Events\n * @public\n */\nexport const workflowEvent = <Data = void, DebugLabel extends string = string>(\n  config?: WorkflowEventConfig<DebugLabel>,\n): WorkflowEvent<Data, DebugLabel> => {\n  const l1 = `${i++}`;\n  const cb = new Set<Callback>();\n  const event = {\n    debugLabel: config?.debugLabel ?? l1,\n    include: (\n      instance: WorkflowEventData<any>,\n    ): instance is WorkflowEventData<Data> => s.has(instance),\n    with: (data: Data) => {\n      const l2 = `${j++}`;\n      const ref = {\n        [Symbol.toStringTag]:\n          config?.debugLabel ?? `WorkflowEvent(${l1}.${l2})`,\n        toString: () =>\n          config?.debugLabel ? config.debugLabel : `WorkflowEvent(${l1}.${l2})`,\n        toJSON: () => {\n          return {\n            type: config?.debugLabel ? config.debugLabel : l1,\n            data,\n          };\n        },\n        get data() {\n          return data;\n        },\n      } as unknown as WorkflowEventData<Data, DebugLabel>;\n      s.add(ref);\n      refMap.set(ref, event);\n      cb.forEach((c) => c(ref));\n      return ref;\n    },\n    onInit: (callback: Callback) => {\n      cb.add(callback);\n      return () => {\n        cb.delete(callback);\n      };\n    },\n  } as unknown as WorkflowEvent<Data, DebugLabel>;\n\n  const s = new WeakSet();\n  eventMap.set(event, s);\n\n  initCallbackMap.set(event, cb);\n\n  Object.defineProperty(event, Symbol.toStringTag, {\n    get: () => event?.debugLabel ?? `WorkflowEvent<${l1}>`,\n  });\n\n  Object.defineProperty(event, \"displayName\", {\n    value: event?.debugLabel ?? `WorkflowEvent<${l1}>`,\n  });\n\n  let uniqueId = config?.uniqueId;\n\n  Object.defineProperty(event, \"uniqueId\", {\n    get: () => {\n      if (!uniqueId) {\n        uniqueId = l1;\n      }\n      return uniqueId;\n    },\n    set: () => {\n      throw new Error(\"uniqueId is readonly\");\n    },\n  });\n\n  event.toString = () => config?.debugLabel ?? `WorkflowEvent<${l1}>`;\n  return event;\n};\n\n// utils\nexport const isWorkflowEvent = (\n  instance: unknown,\n): instance is WorkflowEvent<any> =>\n  typeof instance === \"object\" && instance !== null\n    ? eventMap.has(instance as any)\n    : false;\nexport const isWorkflowEventData = (\n  instance: unknown,\n): instance is WorkflowEventData<any> =>\n  typeof instance === \"object\" && instance !== null\n    ? refMap.has(instance as any)\n    : false;\nexport const eventSource = (\n  instance: unknown,\n): WorkflowEvent<any> | undefined =>\n  typeof instance === \"object\" && instance !== null\n    ? refMap.get(instance as any)\n    : undefined;\n\n// OR Event Implementation\n\nexport type OrEvent<Events extends WorkflowEvent<any>[]> =\n  WorkflowEvent<any> & {\n    _type: \"or\";\n    events: Events;\n  };\n\nexport const or = <const Events extends WorkflowEvent<any>[]>(\n  ...events: Events\n): OrEvent<Events> => {\n  const debugLabel = `or(${events.map((e) => e.debugLabel || e.uniqueId).join(\", \")})`;\n  const l1 = `or_${i++}`;\n\n  const orEvent = {\n    _type: \"or\" as const,\n    events,\n    debugLabel,\n    include: (eventData: unknown): eventData is WorkflowEventData<any> => {\n      // Accept events from any constituent event OR events created by this OR event\n      return (\n        events.some((event) => event.include(eventData)) ||\n        s.has(eventData as any)\n      );\n    },\n    with: (data: any) => {\n      const ref = {\n        [Symbol.toStringTag]: debugLabel,\n        toString: () => debugLabel,\n        toJSON: () => ({\n          type: debugLabel,\n          data,\n        }),\n        get data() {\n          return data;\n        },\n      } as unknown as WorkflowEventData<any>;\n      s.add(ref);\n      refMap.set(ref, orEvent);\n      return ref;\n    },\n  } as unknown as OrEvent<Events>;\n\n  const s = new WeakSet();\n  eventMap.set(orEvent as any, s);\n\n  let uniqueId: string;\n  Object.defineProperty(orEvent, \"uniqueId\", {\n    get: () => {\n      if (!uniqueId) {\n        uniqueId = l1;\n      }\n      return uniqueId;\n    },\n    set: () => {\n      throw new Error(\"uniqueId is readonly\");\n    },\n  });\n\n  Object.defineProperty(orEvent, Symbol.toStringTag, {\n    get: () => debugLabel,\n  });\n\n  Object.defineProperty(orEvent, \"displayName\", {\n    value: debugLabel,\n  });\n\n  (orEvent as any).toString = () => debugLabel;\n\n  return orEvent;\n};\n","import type { WorkflowEvent, WorkflowEventData } from \"./event\";\n\nexport const isEventData = (data: unknown): data is WorkflowEventData<any> =>\n  data != null && typeof data === \"object\" && \"data\" in data;\n\nexport const isPromiseLike = (value: unknown): value is PromiseLike<unknown> =>\n  value != null && typeof (value as PromiseLike<unknown>).then === \"function\";\n\nexport function flattenEvents(\n  acceptEventTypes: WorkflowEvent<any>[],\n  inputEventData: WorkflowEventData<any>[],\n): WorkflowEventData<any>[] {\n  const acceptance: WorkflowEventData<any>[] = new Array(\n    acceptEventTypes.length,\n  );\n  for (const eventData of inputEventData) {\n    for (let i = 0; i < acceptEventTypes.length; i++) {\n      if (acceptance[i]) {\n        continue;\n      }\n      if (acceptEventTypes[i]!.include(eventData)) {\n        acceptance[i] = eventData;\n        break;\n      }\n    }\n  }\n  return acceptance.filter(Boolean);\n}\n\nexport type Subscribable<Args extends any[], R> = {\n  subscribe: (callback: (...args: Args) => R) => () => void;\n  publish: (...args: Args) => unknown[];\n};\n\nconst __internal__subscribesSourcemap = new WeakMap<\n  Subscribable<any, any>,\n  Set<(...args: any[]) => any>\n>();\n\n/**\n * @internal\n */\nexport function getSubscribers<Args extends any[], R>(\n  subscribable: Subscribable<Args, R>,\n): Set<(...args: Args) => R> {\n  return __internal__subscribesSourcemap.get(subscribable)!;\n}\n\n/**\n * @internal\n */\nexport function createSubscribable<\n  FnOrArgs extends ((...args: any[]) => any) | any[],\n  R = unknown,\n>(): FnOrArgs extends (...args: any[]) => any\n  ? Subscribable<Parameters<FnOrArgs>, ReturnType<FnOrArgs>>\n  : FnOrArgs extends any[]\n    ? Subscribable<FnOrArgs, R>\n    : never {\n  const subscribers = new Set<(...args: any) => any>();\n  const obj = {\n    subscribe: (callback: (...args: any) => any) => {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    publish: (...args: any) => {\n      const results: unknown[] = [];\n      for (const callback of subscribers) {\n        results.push(callback(...args));\n      }\n      return results;\n    },\n  };\n  __internal__subscribesSourcemap.set(obj, subscribers);\n  return obj as any;\n}\n","import {\n  eventSource,\n  type InferWorkflowEventData,\n  isWorkflowEvent,\n  type WorkflowEvent,\n  type WorkflowEventData,\n} from \"./event\";\nimport { createSubscribable, type Subscribable } from \"./utils\";\n\nclass JsonEncodeTransform extends TransformStream<\n  WorkflowEventData<any>,\n  string\n> {\n  constructor() {\n    super({\n      transform: (\n        event: WorkflowEventData<any>,\n        controller: TransformStreamDefaultController<string>,\n      ) => {\n        if (eventSource(event)) {\n          controller.enqueue(\n            JSON.stringify({\n              data: (event as WorkflowEventData<any>).data,\n              uniqueId: eventSource(event)!.uniqueId,\n            }) + \"\\n\",\n          );\n        }\n      },\n    });\n  }\n}\n\nclass JsonDecodeTransform extends TransformStream<\n  string,\n  WorkflowEventData<any>\n> {\n  #eventMap: Record<string, WorkflowEvent<any>>;\n\n  constructor(eventMap: Record<string, WorkflowEvent<any>>) {\n    super({\n      transform: (\n        data: string,\n        controller: TransformStreamDefaultController<WorkflowEventData<any>>,\n      ) => {\n        const lines = data\n          .split(\"\\n\")\n          .map((line) => line.trim())\n          .filter((line) => line.length > 0);\n        lines.forEach((line) => {\n          const eventData = JSON.parse(line) as {\n            data: ReturnType<WorkflowEvent<any>[\"with\"]>;\n            uniqueId: string;\n          };\n          const targetEvent = Object.values(this.#eventMap).find(\n            (e) => e.uniqueId === eventData.uniqueId,\n          );\n          if (targetEvent) {\n            const ev = targetEvent.with(\n              eventData.data,\n            ) as WorkflowEventData<any>;\n            controller.enqueue(ev);\n          } else {\n            console.warn(`Unknown event: ${eventData.uniqueId}`);\n          }\n        });\n      },\n    });\n    this.#eventMap = eventMap;\n  }\n}\n\n/**\n * A reactive stream for processing workflow events.\n *\n * WorkflowStream extends the standard ReadableStream to provide specialized\n * methods for filtering, transforming, and consuming workflow events.\n * It supports reactive patterns and can be used to build complex event\n * processing pipelines.\n *\n * @typeParam R - The type of data flowing through the stream\n *\n * @example\n * ```typescript\n * // Get stream from workflow context\n * const stream = context.stream;\n *\n * // Filter for specific events\n * const userEvents = stream.filter(UserEvent);\n *\n * // Transform events\n * const processed = stream.map(event => ({\n *   type: event.constructor.name,\n *   timestamp: Date.now(),\n *   data: event.data\n * }));\n *\n * // Consume events\n * for await (const event of stream.take(10)) {\n *   console.log('Received:', event);\n * }\n * ```\n *\n * @category Streaming\n * @public\n */\nexport class WorkflowStream<R = any>\n  extends ReadableStream<R>\n  implements AsyncIterable<R>\n{\n  #stream: ReadableStream<R>;\n  #subscribable: Subscribable<[data: R], void>;\n\n  /**\n   * Subscribe to specific workflow events.\n   *\n   * @param event - The event type to listen for\n   * @param handler - Function to handle the event\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = stream.on(UserEvent, (event) => {\n   *   console.log('User event:', event.data);\n   * });\n   *\n   * // Later...\n   * unsubscribe();\n   * ```\n   */\n  on<T>(\n    event: WorkflowEvent<T>,\n    handler: (event: WorkflowEventData<T>) => void,\n  ): () => void {\n    return this.#subscribable.subscribe((ev) => {\n      if (event.include(ev)) {\n        handler(ev);\n      }\n    });\n  }\n\n  constructor(\n    subscribable: Subscribable<[R], void>,\n    rootStream: ReadableStream<R>,\n  );\n  constructor(subscribable: Subscribable<[R], void>, rootStream: null);\n  constructor(subscribable: null, rootStream: ReadableStream<R> | null);\n  constructor(\n    subscribable: Subscribable<[R], void> | null,\n    rootStream: ReadableStream<R> | null,\n  ) {\n    if (!subscribable && !rootStream) {\n      throw new TypeError(\n        \"Either subscribable or root stream must be provided\",\n      );\n    }\n    super();\n    if (!subscribable) {\n      this.#subscribable = createSubscribable<[data: R], void>();\n      this.#stream = rootStream!.pipeThrough(\n        new TransformStream({\n          transform: (ev, controller) => {\n            this.#subscribable.publish(ev);\n            controller.enqueue(ev);\n          },\n        }),\n      );\n      return;\n    } else {\n      this.#subscribable = subscribable;\n      let unsubscribe: () => void;\n      this.#stream =\n        rootStream ??\n        new ReadableStream<R>({\n          start: (controller) => {\n            unsubscribe = subscribable.subscribe((event) => {\n              controller.enqueue(event);\n            });\n          },\n          cancel: () => {\n            unsubscribe();\n          },\n        });\n    }\n  }\n\n  /**\n   * Create a WorkflowStream from a standard ReadableStream.\n   *\n   * @param stream - The ReadableStream to wrap\n   * @returns A new WorkflowStream instance\n   */\n  static fromReadableStream<T = any>(\n    stream: ReadableStream<WorkflowEventData<any>>,\n  ): WorkflowStream<T> {\n    return new WorkflowStream(\n      null,\n      stream.pipeThrough(\n        new TransformStream<WorkflowEventData<any>>({\n          transform: (event, controller) => {\n            controller.enqueue(event);\n          },\n        }),\n      ),\n    );\n  }\n\n  /**\n   * Create a WorkflowStream from an HTTP Response.\n   *\n   * @param response - The HTTP Response containing workflow events\n   * @param eventMap - Map of event unique IDs to event constructors\n   * @returns A new WorkflowStream instance\n   */\n  static fromResponse(\n    response: Response,\n    eventMap: Record<string, WorkflowEvent<any>>,\n  ): WorkflowStream<WorkflowEventData<any>> {\n    const body = response.body;\n    if (!body) {\n      throw new Error(\"Response body is not readable\");\n    }\n    return new WorkflowStream(\n      null,\n      body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new JsonDecodeTransform(eventMap)),\n    );\n  }\n\n  /**\n   * Convert the stream to an HTTP Response.\n   *\n   * @param init - Optional ResponseInit parameters\n   * @param transformer - Optional custom transformer (defaults to JSON encoding)\n   * @returns HTTP Response containing the stream data\n   */\n  toResponse(\n    init?: ResponseInit,\n    transformer = new JsonEncodeTransform(),\n  ): R extends WorkflowEventData<any> ? Response : never {\n    return new Response(\n      (this.#stream as ReadableStream<WorkflowEventData<any>>)\n        .pipeThrough<string>(transformer)\n        .pipeThrough(new TextEncoderStream()),\n      init,\n    ) as any;\n  }\n\n  // ReadableStream compatibility methods - marked as internal to hide from main API docs\n  /** @internal */\n  get locked() {\n    return this.#stream.locked;\n  }\n\n  /** @internal */\n  [Symbol.asyncIterator](): ReadableStreamAsyncIterator<R> {\n    return this.#stream[Symbol.asyncIterator]();\n  }\n\n  /** @internal */\n  cancel(reason?: any): Promise<void> {\n    return this.#stream.cancel(reason);\n  }\n\n  /** @internal */\n  getReader(options: { mode: \"byob\" }): ReadableStreamBYOBReader;\n  /** @internal */\n  getReader(): ReadableStreamDefaultReader<R>;\n  /** @internal */\n  getReader(options?: ReadableStreamGetReaderOptions): ReadableStreamReader<R>;\n  getReader(): any {\n    return this.#stream.getReader();\n  }\n\n  /** @internal */\n  pipeThrough<T>(\n    transform: ReadableWritablePair<T, R>,\n    options?: StreamPipeOptions,\n  ): WorkflowStream<T> {\n    const stream = this.#stream.pipeThrough(transform, options) as any;\n    return new WorkflowStream<T>(null, stream);\n  }\n\n  /** @internal */\n  pipeTo(\n    destination: WritableStream<R>,\n    options?: StreamPipeOptions,\n  ): Promise<void> {\n    return this.#stream.pipeTo(destination, options);\n  }\n\n  /** @internal */\n  tee(): [WorkflowStream<R>, WorkflowStream<R>] {\n    const [l, r] = this.#stream.tee();\n    return [\n      new WorkflowStream(this.#subscribable, l),\n      new WorkflowStream(this.#subscribable, r),\n    ];\n  }\n\n  /**\n   * Process each item in the stream with a callback function.\n   *\n   * @param callback - Function to call for each item\n   * @returns Promise that resolves when all items are processed\n   *\n   * @example\n   * ```typescript\n   * await stream.forEach(event => {\n   *   console.log('Processing:', event);\n   * });\n   * ```\n   */\n  forEach(callback: (item: R) => void): Promise<void> {\n    return this.#stream.pipeTo(\n      new WritableStream({\n        write: (item: R) => {\n          callback(item);\n        },\n      }),\n    );\n  }\n\n  /**\n   * Transform each item in the stream.\n   *\n   * @param callback - Function to transform each item\n   * @returns A new WorkflowStream with transformed items\n   *\n   * @example\n   * ```typescript\n   * const timestamps = stream.map(event => ({\n   *   ...event,\n   *   timestamp: Date.now()\n   * }));\n   * ```\n   */\n  map<T>(callback: (item: R) => T): WorkflowStream<T> {\n    return this.pipeThrough<T>(\n      new TransformStream({\n        transform: (item, controller) => {\n          controller.enqueue(callback(item));\n        },\n      }),\n    );\n  }\n\n  /** @internal */\n  values(\n    options?: ReadableStreamIteratorOptions,\n  ): ReadableStreamAsyncIterator<R> {\n    return this.#stream.values(options);\n  }\n\n  /**\n   * Take only the first N items from the stream.\n   *\n   * @param limit - Maximum number of items to take\n   * @returns A new WorkflowStream limited to the specified number of items\n   *\n   * @example\n   * ```typescript\n   * const firstTen = stream.take(10);\n   * for await (const event of firstTen) {\n   *   console.log(event);\n   * }\n   * ```\n   */\n  take(limit: number): WorkflowStream<R> {\n    let count = 0;\n    return this.pipeThrough(\n      new TransformStream({\n        transform: (ev, controller) => {\n          if (count < limit) {\n            controller.enqueue(ev);\n            count++;\n          }\n          if (count >= limit) {\n            controller.terminate();\n          }\n        },\n      }),\n    );\n  }\n\n  /**\n   * Filter the stream to include only items matching the predicate.\n   *\n   * @param predicate - Event type, function, or value to filter by\n   * @returns A new WorkflowStream containing only matching items\n   *\n   * @example\n   * ```typescript\n   * // Filter by event type\n   * const userEvents = stream.filter(UserEvent);\n   *\n   * // Filter by function\n   * const importantEvents = stream.filter(event => event.priority === 'high');\n   *\n   * // Filter by specific value\n   * const specificEvent = stream.filter(myEventInstance);\n   * ```\n   */\n  filter(\n    predicate: R extends WorkflowEventData<any>\n      ? WorkflowEvent<InferWorkflowEventData<R>>\n      : never,\n  ): WorkflowStream<R>;\n  filter(predicate: R): WorkflowStream<R>;\n  filter(predicate: (event: R) => boolean): WorkflowStream<R>;\n  filter(\n    predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | ((event: R) => boolean)\n      | R,\n  ): WorkflowStream<R> {\n    return this.pipeThrough(\n      new TransformStream({\n        transform: (ev, controller) => {\n          if (\n            typeof predicate === \"function\"\n              ? (predicate as (event: R) => boolean)(ev)\n              : isWorkflowEvent(predicate)\n                ? predicate.include(ev)\n                : predicate === ev\n          ) {\n            controller.enqueue(ev);\n          }\n        },\n      }),\n    );\n  }\n\n  /**\n   * Continue the stream until the predicate is met, then terminate.\n   *\n   * @param predicate - Event type, function, or value to stop at\n   * @returns A new WorkflowStream that terminates when the predicate is met\n   *\n   * @example\n   * ```typescript\n   * // Stop at completion event\n   * const processingEvents = stream.until(CompletionEvent);\n   *\n   * // Stop when condition is met\n   * const beforeError = stream.until(event => event.type === 'error');\n   *\n   * // Stop at specific event instance\n   * const beforeSpecific = stream.until(myEventInstance);\n   * ```\n   */\n  until(\n    predicate: R extends WorkflowEventData<any>\n      ? WorkflowEvent<InferWorkflowEventData<R>>\n      : never,\n  ): WorkflowStream<R>;\n  until(predicate: (item: R) => boolean): WorkflowStream<R>;\n  until(item: R): WorkflowStream<R>;\n  until(\n    predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | R\n      | ((item: R) => boolean),\n  ): WorkflowStream<R> {\n    return this.pipeThrough(\n      new TransformStream({\n        transform: (ev, controller) => {\n          controller.enqueue(ev);\n          if (\n            typeof predicate === \"function\"\n              ? (predicate as (event: R) => boolean)(ev)\n              : isWorkflowEvent(predicate)\n                ? predicate.include(ev)\n                : predicate === ev\n          ) {\n            controller.terminate();\n          }\n        },\n      }),\n    );\n  }\n\n  /**\n   * Continue the stream until a matching event is found, then return that event.\n   *\n   * @param predicate - Event type, function, or value to wait for\n   * @returns Promise resolving to the matching event\n   *\n   * @example\n   * ```typescript\n   * // Wait for completion event and return it directly\n   * const result = await stream.untilEvent(CompletionEvent);\n   * console.log('Final result:', result.data);\n   *\n   * // Wait for condition and return matching event\n   * const errorEvent = await stream.untilEvent(event => event.type === 'error');\n   * ```\n   */\n  async untilEvent(\n    predicate: R extends WorkflowEventData<any>\n      ? WorkflowEvent<InferWorkflowEventData<R>>\n      : never,\n  ): Promise<R>;\n  async untilEvent(predicate: (item: R) => boolean): Promise<R>;\n  async untilEvent(item: R): Promise<R>;\n  async untilEvent(\n    predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | R\n      | ((item: R) => boolean),\n  ): Promise<R> {\n    const events = await this.until(predicate as any).toArray();\n    const lastEvent = events[events.length - 1];\n    if (!lastEvent) {\n      throw new Error(\"Stream ended without matching event\");\n    }\n\n    // Check if the last event actually matches the predicate\n    const matches =\n      typeof predicate === \"function\"\n        ? (predicate as (event: R) => boolean)(lastEvent)\n        : isWorkflowEvent(predicate)\n          ? predicate.include(lastEvent)\n          : predicate === lastEvent;\n\n    if (!matches) {\n      throw new Error(\"Stream ended without matching event\");\n    }\n\n    return lastEvent;\n  }\n\n  /**\n   * Collect all items from the stream into an array.\n   *\n   * @returns Promise resolving to an array of all stream items\n   *\n   * @example\n   * ```typescript\n   * const events = await stream.take(5).toArray();\n   * console.log('Collected events:', events);\n   * ```\n   */\n  async toArray(): Promise<R[]> {\n    const events: R[] = [];\n    await this.pipeTo(\n      new WritableStream({\n        write: (event) => {\n          events.push(event);\n        },\n      }),\n    );\n    return events;\n  }\n}\n","import type {\n  WorkflowEvent,\n  WorkflowEventData,\n} from \"@llamaindex/workflow-core\";\nimport { AsyncContext } from \"@llamaindex/workflow-core/async-context\";\nimport { WorkflowStream } from \"./stream\";\nimport {\n  createSubscribable,\n  flattenEvents,\n  getSubscribers,\n  isEventData,\n  isPromiseLike,\n  type Subscribable,\n} from \"./utils\";\n\nexport type Handler<\n  AcceptEvents extends WorkflowEvent<any>[],\n  Result extends WorkflowEventData<any> | void,\n  Context extends WorkflowContext = WorkflowContext,\n> = (\n  context: Context,\n  ...events: {\n    [K in keyof AcceptEvents]: ReturnType<AcceptEvents[K][\"with\"]>;\n  }\n) => Result | Promise<Result>;\n\ntype BaseHandlerContext = {\n  abortController: AbortController;\n  handler: Handler<WorkflowEvent<any>[], any>;\n  // events that are accepted by the handler\n  inputEvents: WorkflowEvent<any>[];\n  // events data that are accepted by the handler\n  inputs: WorkflowEventData<any>[];\n  // events data that are emitted by the handler\n  outputs: WorkflowEventData<any>[];\n\n  //#region linked list data structure\n  prev: HandlerContext;\n  next: Set<HandlerContext>;\n  root: HandlerContext;\n  //#endregion\n};\n\ntype SyncHandlerContext = BaseHandlerContext & {\n  async: false;\n  pending: null;\n};\n\ntype AsyncHandlerContext = BaseHandlerContext & {\n  async: true;\n  pending: Promise<WorkflowEventData<any> | void> | null;\n};\n\nexport type HandlerContext = AsyncHandlerContext | SyncHandlerContext;\n\nexport type ContextNext = (\n  context: HandlerContext,\n  next: (context: HandlerContext) => void,\n) => void;\n\n/**\n * Execution context for workflow event processing.\n *\n * The workflow context provides the runtime environment for executing handlers\n * and managing event flow. It offers access to the event stream, abort signals,\n * and methods for sending events within the workflow.\n *\n * @example\n * ```typescript\n * // Use the current context (first parameter inside a handler)\n * const { sendEvent, stream, signal } = context;\n *\n * // Send events\n * sendEvent(\n *   ProcessEvent.with({ step: 'validation' }),\n *   LogEvent.with({ message: 'Processing started' })\n * );\n *\n * // Access the event stream\n * await stream.filter(CompletionEvent).take(1).toArray();\n *\n * // Check for cancellation\n * if (signal.aborted) {\n *   throw new Error('Operation cancelled');\n * }\n * ```\n *\n * @category Context\n * @public\n */\nexport type WorkflowContext = {\n  /**\n   * Stream of all events flowing through this workflow context.\n   * Can be used to listen for specific events or create reactive processing chains.\n   */\n  get stream(): WorkflowStream<WorkflowEventData<any>>;\n\n  /**\n   * Abort signal that indicates if the workflow has been cancelled.\n   * Handlers should check this periodically for long-running operations.\n   */\n  get signal(): AbortSignal;\n\n  /**\n   * Sends one or more events into the workflow for processing.\n   * Events will be delivered to all matching handlers asynchronously.\n   *\n   * @param events - Event data instances to send\n   */\n  sendEvent: (...events: WorkflowEventData<any>[]) => void;\n\n  /**\n   * @internal\n   */\n  __internal__call_context: Subscribable<\n    Parameters<ContextNext>,\n    ReturnType<ContextNext>\n  >;\n  __internal__call_send_event: Subscribable<\n    [event: WorkflowEventData<any>, handlerContext: HandlerContext],\n    void\n  >;\n  __internal__property_inheritance_handlers?: Map<\n    string,\n    InheritanceTransformer\n  >;\n};\n\nexport type InheritanceTransformer = (\n  handlerContext: WorkflowContext,\n  originalDescriptor: PropertyDescriptor,\n) => PropertyDescriptor;\n\nexport const _executorAsyncLocalStorage =\n  new AsyncContext.Variable<WorkflowContext>();\n\n/**\n * @deprecated Use the context parameter directly from workflow handlers instead.\n * The context passed to handlers already includes all state properties.\n *\n * @example\n * ```ts\n * workflow.handle([startEvent], (context, event) => {\n *   const { sendEvent } = context;\n *   sendEvent(processEvent.with());\n * });\n * ```\n */\nexport function getContext(): WorkflowContext {\n  const context = _executorAsyncLocalStorage.get();\n  if (!context) {\n    throw new Error(\"No current context found\");\n  }\n  return context;\n}\n\n/**\n * Use this function to add or extend properties of the root context.\n * Called by middleware's createContext to update the root context.\n * Handler-scoped contexts will automatically inherit these properties from the root context.\n * Never create a new object (e.g., using a spread `{...context}`) in your middleware's createContext.\n *\n * @param context The context to extend\n * @param properties The properties to add to the context\n * @param inheritanceTransformers The inheritance transformers to apply to existing properties (optional)\n */\nexport function extendContext(\n  context: WorkflowContext,\n  properties: Record<string, any>,\n  inheritanceTransformers?: Record<string, InheritanceTransformer>,\n): void {\n  // Add simple properties directly to the context (these inherit normally via prototype chain)\n  Object.assign(context, properties);\n\n  // Register inheritance transformers for properties that need custom inheritance behavior\n  if (inheritanceTransformers) {\n    if (!context.__internal__property_inheritance_handlers) {\n      context.__internal__property_inheritance_handlers = new Map();\n    }\n\n    for (const [propertyKey, transformer] of Object.entries(\n      inheritanceTransformers,\n    )) {\n      context.__internal__property_inheritance_handlers.set(\n        propertyKey,\n        transformer,\n      );\n\n      // Apply the transformer to the root context immediately\n      const rootDescriptor = Object.getOwnPropertyDescriptor(\n        context,\n        propertyKey,\n      );\n      if (rootDescriptor) {\n        const newDescriptor = transformer(context, rootDescriptor);\n        Object.defineProperty(context, propertyKey, newDescriptor);\n      }\n    }\n  }\n}\n\nconst handlerContextAsyncLocalStorage =\n  new AsyncContext.Variable<HandlerContext>();\n\nconst eventContextWeakMap = new WeakMap<\n  WorkflowEventData<any>,\n  HandlerContext\n>();\n\nexport type ExecutorParams = {\n  listeners: ReadonlyMap<\n    WorkflowEvent<any>[],\n    Set<Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>>\n  >;\n};\n\nexport const createContext = ({\n  listeners,\n}: ExecutorParams): WorkflowContext => {\n  const queue: WorkflowEventData<any>[] = [];\n  // eslint-disable-next-line prefer-const\n  let rootWorkflowContext: WorkflowContext;\n  const runHandler = (\n    handler: Handler<WorkflowEvent<any>[], any>,\n    inputEvents: WorkflowEvent<any>[],\n    inputs: WorkflowEventData<any>[],\n    parentContext: HandlerContext,\n  ): void => {\n    let handlerAbortController: AbortController;\n    const handlerContext: HandlerContext = {\n      get abortController() {\n        if (!handlerAbortController) {\n          handlerAbortController = new AbortController();\n        }\n        return handlerAbortController;\n      },\n      async:\n        \"constructor\" in handler\n          ? handler.constructor.name === \"AsyncFunction\"\n          : false,\n      pending: null,\n      handler,\n      inputEvents,\n      inputs,\n      outputs: [],\n      prev: parentContext,\n      next: new Set(),\n      get root() {\n        return handlerRootContext;\n      },\n    };\n    handlerContext.prev.next.add(handlerContext);\n    // Use prototype chain to inherit the properties of the root workflow context for the specific context for the handler\n    const specificContext = createWorkflowContext(handlerContext);\n    const workflowContext = Object.create(rootWorkflowContext);\n    const specificDescriptors =\n      Object.getOwnPropertyDescriptors(specificContext);\n\n    // Apply inheritance transformers if available\n    if (rootWorkflowContext.__internal__property_inheritance_handlers) {\n      for (const [\n        propertyKey,\n        transformer,\n      ] of rootWorkflowContext.__internal__property_inheritance_handlers) {\n        if (propertyKey in specificDescriptors) {\n          const originalDescriptor = specificDescriptors[propertyKey];\n          if (originalDescriptor) {\n            const newDescriptor = transformer(\n              workflowContext,\n              originalDescriptor,\n            );\n            specificDescriptors[propertyKey] = newDescriptor;\n          }\n        }\n      }\n    }\n\n    Object.defineProperties(workflowContext, specificDescriptors);\n    handlerContextAsyncLocalStorage.run(handlerContext, () => {\n      const cbs = [\n        ...new Set([\n          ...getSubscribers(rootWorkflowContext.__internal__call_context),\n          ...getSubscribers(workflowContext.__internal__call_context),\n        ]),\n      ];\n      _executorAsyncLocalStorage.run(workflowContext, () => {\n        //#region middleware\n        let i = 0;\n        const next = (context: HandlerContext) => {\n          if (i === cbs.length) {\n            let result: any;\n            try {\n              result = context.handler(workflowContext, ...context.inputs);\n            } catch (error) {\n              if (handlerAbortController ?? rootAbortController) {\n                (handlerAbortController ?? rootAbortController).abort(error);\n              } else {\n                console.error(\"unhandled error in handler\", error);\n                throw error;\n              }\n            }\n            // return value is a special event\n            if (isPromiseLike(result)) {\n              (handlerContext as any).async = true;\n              (handlerContext as any).pending = result.then((event) => {\n                if (isEventData(event)) {\n                  workflowContext.sendEvent(event);\n                }\n                return event;\n              });\n            } else if (isEventData(result)) {\n              workflowContext.sendEvent(result);\n            }\n          }\n          const cb = cbs[i];\n          if (cb) {\n            i++;\n            cb(context, next);\n          }\n        };\n        next(handlerContext);\n        //#endregion\n      });\n    });\n  };\n  const queueUpdateCallback = (handlerContext: HandlerContext) => {\n    const queueSnapshot = [...queue];\n    [...listeners]\n      .filter(([events]) => {\n        const inputs = flattenEvents(events, queueSnapshot);\n        return inputs.length === events.length;\n      })\n      .map(([events, handlers]) => {\n        const inputs = flattenEvents(events, queueSnapshot);\n        inputs.forEach((input) => {\n          queue.splice(queue.indexOf(input), 1);\n        });\n        for (const handler of handlers) {\n          runHandler(handler, events, inputs, handlerContext);\n        }\n      });\n  };\n  const createWorkflowContext = (\n    handlerContext: HandlerContext,\n  ): WorkflowContext => {\n    let lazyLoadStream: WorkflowStream | null = null;\n    return {\n      get stream() {\n        if (!lazyLoadStream) {\n          const subscribable = createSubscribable<\n            [event: WorkflowEventData<any>],\n            void\n          >();\n          rootWorkflowContext.__internal__call_send_event.subscribe(\n            (newEvent: WorkflowEventData<any>) => {\n              let currentEventContext = eventContextWeakMap.get(newEvent);\n              while (currentEventContext) {\n                if (currentEventContext === handlerContext) {\n                  subscribable.publish(newEvent);\n                  break;\n                }\n                currentEventContext = currentEventContext.prev;\n              }\n            },\n          );\n          lazyLoadStream = new WorkflowStream(subscribable, null);\n        }\n        return lazyLoadStream;\n      },\n      get signal() {\n        return handlerContext.abortController.signal;\n      },\n      sendEvent: (...events) => {\n        events.forEach((event) => {\n          eventContextWeakMap.set(event, handlerContext);\n          handlerContext.outputs.push(event);\n          queue.push(event);\n          rootWorkflowContext.__internal__call_send_event.publish(\n            event,\n            handlerContext,\n          );\n          queueUpdateCallback(handlerContext);\n        });\n      },\n      __internal__call_context: createSubscribable(),\n      __internal__call_send_event: createSubscribable(),\n    };\n  };\n\n  let rootAbortController = new AbortController();\n  const handlerRootContext: HandlerContext = {\n    get abortController() {\n      if (!rootAbortController) {\n        rootAbortController = new AbortController();\n      }\n      return rootAbortController;\n    },\n    async: false,\n    pending: null,\n    inputEvents: [],\n    inputs: [],\n    outputs: [],\n    handler: null!,\n    prev: null!,\n    next: new Set(),\n    get root() {\n      return handlerRootContext;\n    },\n  };\n\n  rootWorkflowContext = createWorkflowContext(handlerRootContext);\n  return rootWorkflowContext;\n};\n","import { createContext, type Handler, type WorkflowContext } from \"./context\";\nimport type { WorkflowEvent, WorkflowEventData } from \"./event\";\n\n/**\n * Represents a workflow that processes events through registered handlers.\n *\n * A workflow is the central orchestrator for event-driven processing, allowing\n * you to register handlers for specific events and create execution contexts\n * to process those events.\n *\n * @example\n * ```typescript\n * const workflow = createWorkflow();\n *\n * // Register a handler for user events\n * workflow.handle([UserEvent], async (context, event) => {\n *   console.log('Processing user:', event.data.name);\n *   return ProcessedEvent.with({ status: 'complete' });\n * });\n *\n * // Create context and process events\n * const context = workflow.createContext();\n * await context.send(UserEvent.with({ name: 'John' }));\n * ```\n *\n * @category Workflow\n * @public\n */\nexport type Workflow = {\n  /**\n   * Registers a handler function for one or more workflow events.\n   *\n   * The handler will be invoked whenever any of the accepted events are sent\n   * through a workflow context. Handlers can process events and optionally\n   * return new events to continue the workflow.\n   *\n   * @typeParam AcceptEvents - Array of event types this handler accepts\n   * @typeParam Result - Return type of the handler (event data or void)\n   *\n   * @param accept - Array of event types that trigger this handler\n   * @param handler - Function to execute when matching events are received\n   *\n   * @example\n   * ```typescript\n   * // Handle multiple event types\n   * workflow.handle([StartEvent, RestartEvent], async (context, event) => {\n   *   if (StartEvent.include(event)) {\n   *     return ProcessEvent.with({ action: 'start' });\n   *   } else {\n   *     return ProcessEvent.with({ action: 'restart' });\n   *   }\n   * });\n   * ```\n   */\n  handle<\n    const AcceptEvents extends WorkflowEvent<any>[],\n    Result extends ReturnType<WorkflowEvent<any>[\"with\"]> | void,\n  >(accept: AcceptEvents, handler: Handler<AcceptEvents, Result>): void;\n\n  /**\n   * Creates a new workflow context for event processing.\n   *\n   * The context provides the runtime environment for executing handlers\n   * and managing event flow. Each context maintains its own execution\n   * state and event queue.\n   *\n   * @returns A new workflow context instance\n   *\n   * @example\n   * ```typescript\n   * const context = workflow.createContext();\n   *\n   * // Send events through the context\n   * await context.send(MyEvent.with({ data: 'hello' }));\n   *\n   * // Listen for specific events\n   * const result = await context.waitFor(CompletionEvent);\n   * ```\n   */\n  createContext(): WorkflowContext;\n};\n\n/**\n * Creates a new workflow instance.\n *\n * This is the primary factory function for creating workflows. Each workflow\n * maintains its own registry of event handlers and can create multiple\n * independent execution contexts.\n *\n * @returns A new workflow instance\n *\n * @example\n * ```typescript\n * // Create a simple workflow\n * const workflow = createWorkflow();\n *\n * // Register handlers\n * workflow.handle([InputEvent], async (context, event) => {\n *   const processed = await processInput(event.data);\n *   return OutputEvent.with(processed);\n * });\n *\n * // Use the workflow\n * const context = workflow.createContext();\n * const input = InputEvent.with({ text: 'Hello World' });\n * await context.send(input);\n * ```\n *\n * @category Workflow\n * @public\n */\nexport const createWorkflow = (): Workflow => {\n  const config = {\n    steps: new Map<\n      WorkflowEvent<any>[],\n      Set<Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>>\n    >(),\n  };\n\n  return {\n    handle: <\n      const AcceptEvents extends WorkflowEvent<any>[],\n      Result extends ReturnType<WorkflowEvent<any>[\"with\"]> | void,\n    >(\n      accept: AcceptEvents,\n      handler: Handler<AcceptEvents, Result>,\n    ): void => {\n      if (config.steps.has(accept)) {\n        const set = config.steps.get(accept) as Set<\n          Handler<AcceptEvents, Result>\n        >;\n        set.add(handler);\n      } else {\n        const set = new Set<Handler<AcceptEvents, Result>>();\n        set.add(handler);\n        config.steps.set(\n          accept,\n          set as Set<\n            Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>\n          >,\n        );\n      }\n    },\n    createContext() {\n      return createContext({\n        listeners: config.steps,\n      });\n    },\n  };\n};\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10],"mappings":"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"}