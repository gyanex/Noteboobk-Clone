//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i$1 = 0, n = keys.length, key; i$1 < n; i$1++) {
		key = keys[i$1];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const __llamaindex_workflow_core_async_context = __toESM(require("@llamaindex/workflow-core/async-context"));

//#region src/core/event.ts
const eventMap = /* @__PURE__ */ new WeakMap();
const refMap = /* @__PURE__ */ new WeakMap();
const initCallbackMap = /* @__PURE__ */ new WeakMap();
let i = 0;
let j = 0;
/**
* Creates a new workflow event type.
*
* This is the primary factory function for creating event types that can be used
* in workflows. Each event type can carry specific data and be used to trigger
* handlers throughout the workflow system.
*
* @typeParam Data - The type of data this event will carry (defaults to void)
* @typeParam DebugLabel - Optional debug label type for development
*
* @param config - Optional configuration for the event type
* @returns A new workflow event type that can be instantiated with data
*
* @example
* ```typescript
* // Create a simple event with no data
* const StartEvent = workflowEvent();
*
* // Create an event that carries user data
* const UserEvent = workflowEvent<{ name: string; email: string }>({
*   debugLabel: 'UserEvent'
* });
*
* // Create event instances
* const start = StartEvent.with();
* const user = UserEvent.with({ name: 'John', email: 'john@example.com' });
* ```
*
* @category Events
* @public
*/
const workflowEvent = (config) => {
	const l1 = `${i++}`;
	const cb = /* @__PURE__ */ new Set();
	const event = {
		debugLabel: config?.debugLabel ?? l1,
		include: (instance) => s.has(instance),
		with: (data) => {
			const l2 = `${j++}`;
			const ref = {
				[Symbol.toStringTag]: config?.debugLabel ?? `WorkflowEvent(${l1}.${l2})`,
				toString: () => config?.debugLabel ? config.debugLabel : `WorkflowEvent(${l1}.${l2})`,
				toJSON: () => {
					return {
						type: config?.debugLabel ? config.debugLabel : l1,
						data
					};
				},
				get data() {
					return data;
				}
			};
			s.add(ref);
			refMap.set(ref, event);
			cb.forEach((c) => c(ref));
			return ref;
		},
		onInit: (callback) => {
			cb.add(callback);
			return () => {
				cb.delete(callback);
			};
		}
	};
	const s = /* @__PURE__ */ new WeakSet();
	eventMap.set(event, s);
	initCallbackMap.set(event, cb);
	Object.defineProperty(event, Symbol.toStringTag, { get: () => event?.debugLabel ?? `WorkflowEvent<${l1}>` });
	Object.defineProperty(event, "displayName", { value: event?.debugLabel ?? `WorkflowEvent<${l1}>` });
	let uniqueId = config?.uniqueId;
	Object.defineProperty(event, "uniqueId", {
		get: () => {
			if (!uniqueId) uniqueId = l1;
			return uniqueId;
		},
		set: () => {
			throw new Error("uniqueId is readonly");
		}
	});
	event.toString = () => config?.debugLabel ?? `WorkflowEvent<${l1}>`;
	return event;
};
const isWorkflowEvent = (instance) => typeof instance === "object" && instance !== null ? eventMap.has(instance) : false;
const isWorkflowEventData = (instance) => typeof instance === "object" && instance !== null ? refMap.has(instance) : false;
const eventSource = (instance) => typeof instance === "object" && instance !== null ? refMap.get(instance) : void 0;
const or = (...events) => {
	const debugLabel = `or(${events.map((e) => e.debugLabel || e.uniqueId).join(", ")})`;
	const l1 = `or_${i++}`;
	const orEvent = {
		_type: "or",
		events,
		debugLabel,
		include: (eventData) => {
			return events.some((event) => event.include(eventData)) || s.has(eventData);
		},
		with: (data) => {
			const ref = {
				[Symbol.toStringTag]: debugLabel,
				toString: () => debugLabel,
				toJSON: () => ({
					type: debugLabel,
					data
				}),
				get data() {
					return data;
				}
			};
			s.add(ref);
			refMap.set(ref, orEvent);
			return ref;
		}
	};
	const s = /* @__PURE__ */ new WeakSet();
	eventMap.set(orEvent, s);
	let uniqueId;
	Object.defineProperty(orEvent, "uniqueId", {
		get: () => {
			if (!uniqueId) uniqueId = l1;
			return uniqueId;
		},
		set: () => {
			throw new Error("uniqueId is readonly");
		}
	});
	Object.defineProperty(orEvent, Symbol.toStringTag, { get: () => debugLabel });
	Object.defineProperty(orEvent, "displayName", { value: debugLabel });
	orEvent.toString = () => debugLabel;
	return orEvent;
};

//#endregion
//#region src/core/utils.ts
const isEventData = (data) => data != null && typeof data === "object" && "data" in data;
const isPromiseLike = (value) => value != null && typeof value.then === "function";
function flattenEvents(acceptEventTypes, inputEventData) {
	const acceptance = new Array(acceptEventTypes.length);
	for (const eventData of inputEventData) for (let i$1 = 0; i$1 < acceptEventTypes.length; i$1++) {
		if (acceptance[i$1]) continue;
		if (acceptEventTypes[i$1].include(eventData)) {
			acceptance[i$1] = eventData;
			break;
		}
	}
	return acceptance.filter(Boolean);
}
const __internal__subscribesSourcemap = /* @__PURE__ */ new WeakMap();
/**
* @internal
*/
function getSubscribers(subscribable) {
	return __internal__subscribesSourcemap.get(subscribable);
}
/**
* @internal
*/
function createSubscribable() {
	const subscribers = /* @__PURE__ */ new Set();
	const obj = {
		subscribe: (callback) => {
			subscribers.add(callback);
			return () => {
				subscribers.delete(callback);
			};
		},
		publish: (...args) => {
			const results = [];
			for (const callback of subscribers) results.push(callback(...args));
			return results;
		}
	};
	__internal__subscribesSourcemap.set(obj, subscribers);
	return obj;
}

//#endregion
//#region src/core/stream.ts
var JsonEncodeTransform = class extends TransformStream {
	constructor() {
		super({ transform: (event, controller) => {
			if (eventSource(event)) controller.enqueue(JSON.stringify({
				data: event.data,
				uniqueId: eventSource(event).uniqueId
			}) + "\n");
		} });
	}
};
var JsonDecodeTransform = class extends TransformStream {
	#eventMap;
	constructor(eventMap$1) {
		super({ transform: (data, controller) => {
			const lines = data.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
			lines.forEach((line) => {
				const eventData = JSON.parse(line);
				const targetEvent = Object.values(this.#eventMap).find((e) => e.uniqueId === eventData.uniqueId);
				if (targetEvent) {
					const ev = targetEvent.with(eventData.data);
					controller.enqueue(ev);
				} else console.warn(`Unknown event: ${eventData.uniqueId}`);
			});
		} });
		this.#eventMap = eventMap$1;
	}
};
/**
* A reactive stream for processing workflow events.
*
* WorkflowStream extends the standard ReadableStream to provide specialized
* methods for filtering, transforming, and consuming workflow events.
* It supports reactive patterns and can be used to build complex event
* processing pipelines.
*
* @typeParam R - The type of data flowing through the stream
*
* @example
* ```typescript
* // Get stream from workflow context
* const stream = context.stream;
*
* // Filter for specific events
* const userEvents = stream.filter(UserEvent);
*
* // Transform events
* const processed = stream.map(event => ({
*   type: event.constructor.name,
*   timestamp: Date.now(),
*   data: event.data
* }));
*
* // Consume events
* for await (const event of stream.take(10)) {
*   console.log('Received:', event);
* }
* ```
*
* @category Streaming
* @public
*/
var WorkflowStream = class WorkflowStream extends ReadableStream {
	#stream;
	#subscribable;
	/**
	* Subscribe to specific workflow events.
	*
	* @param event - The event type to listen for
	* @param handler - Function to handle the event
	* @returns Unsubscribe function
	*
	* @example
	* ```typescript
	* const unsubscribe = stream.on(UserEvent, (event) => {
	*   console.log('User event:', event.data);
	* });
	*
	* // Later...
	* unsubscribe();
	* ```
	*/
	on(event, handler) {
		return this.#subscribable.subscribe((ev) => {
			if (event.include(ev)) handler(ev);
		});
	}
	constructor(subscribable, rootStream) {
		if (!subscribable && !rootStream) throw new TypeError("Either subscribable or root stream must be provided");
		super();
		if (!subscribable) {
			this.#subscribable = createSubscribable();
			this.#stream = rootStream.pipeThrough(new TransformStream({ transform: (ev, controller) => {
				this.#subscribable.publish(ev);
				controller.enqueue(ev);
			} }));
			return;
		} else {
			this.#subscribable = subscribable;
			let unsubscribe;
			this.#stream = rootStream ?? new ReadableStream({
				start: (controller) => {
					unsubscribe = subscribable.subscribe((event) => {
						controller.enqueue(event);
					});
				},
				cancel: () => {
					unsubscribe();
				}
			});
		}
	}
	/**
	* Create a WorkflowStream from a standard ReadableStream.
	*
	* @param stream - The ReadableStream to wrap
	* @returns A new WorkflowStream instance
	*/
	static fromReadableStream(stream) {
		return new WorkflowStream(null, stream.pipeThrough(new TransformStream({ transform: (event, controller) => {
			controller.enqueue(event);
		} })));
	}
	/**
	* Create a WorkflowStream from an HTTP Response.
	*
	* @param response - The HTTP Response containing workflow events
	* @param eventMap - Map of event unique IDs to event constructors
	* @returns A new WorkflowStream instance
	*/
	static fromResponse(response, eventMap$1) {
		const body = response.body;
		if (!body) throw new Error("Response body is not readable");
		return new WorkflowStream(null, body.pipeThrough(new TextDecoderStream()).pipeThrough(new JsonDecodeTransform(eventMap$1)));
	}
	/**
	* Convert the stream to an HTTP Response.
	*
	* @param init - Optional ResponseInit parameters
	* @param transformer - Optional custom transformer (defaults to JSON encoding)
	* @returns HTTP Response containing the stream data
	*/
	toResponse(init, transformer = new JsonEncodeTransform()) {
		return new Response(this.#stream.pipeThrough(transformer).pipeThrough(new TextEncoderStream()), init);
	}
	/** @internal */
	get locked() {
		return this.#stream.locked;
	}
	/** @internal */
	[Symbol.asyncIterator]() {
		return this.#stream[Symbol.asyncIterator]();
	}
	/** @internal */
	cancel(reason) {
		return this.#stream.cancel(reason);
	}
	getReader() {
		return this.#stream.getReader();
	}
	/** @internal */
	pipeThrough(transform, options) {
		const stream = this.#stream.pipeThrough(transform, options);
		return new WorkflowStream(null, stream);
	}
	/** @internal */
	pipeTo(destination, options) {
		return this.#stream.pipeTo(destination, options);
	}
	/** @internal */
	tee() {
		const [l, r] = this.#stream.tee();
		return [new WorkflowStream(this.#subscribable, l), new WorkflowStream(this.#subscribable, r)];
	}
	/**
	* Process each item in the stream with a callback function.
	*
	* @param callback - Function to call for each item
	* @returns Promise that resolves when all items are processed
	*
	* @example
	* ```typescript
	* await stream.forEach(event => {
	*   console.log('Processing:', event);
	* });
	* ```
	*/
	forEach(callback) {
		return this.#stream.pipeTo(new WritableStream({ write: (item) => {
			callback(item);
		} }));
	}
	/**
	* Transform each item in the stream.
	*
	* @param callback - Function to transform each item
	* @returns A new WorkflowStream with transformed items
	*
	* @example
	* ```typescript
	* const timestamps = stream.map(event => ({
	*   ...event,
	*   timestamp: Date.now()
	* }));
	* ```
	*/
	map(callback) {
		return this.pipeThrough(new TransformStream({ transform: (item, controller) => {
			controller.enqueue(callback(item));
		} }));
	}
	/** @internal */
	values(options) {
		return this.#stream.values(options);
	}
	/**
	* Take only the first N items from the stream.
	*
	* @param limit - Maximum number of items to take
	* @returns A new WorkflowStream limited to the specified number of items
	*
	* @example
	* ```typescript
	* const firstTen = stream.take(10);
	* for await (const event of firstTen) {
	*   console.log(event);
	* }
	* ```
	*/
	take(limit) {
		let count = 0;
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			if (count < limit) {
				controller.enqueue(ev);
				count++;
			}
			if (count >= limit) controller.terminate();
		} }));
	}
	filter(predicate) {
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			if (typeof predicate === "function" ? predicate(ev) : isWorkflowEvent(predicate) ? predicate.include(ev) : predicate === ev) controller.enqueue(ev);
		} }));
	}
	until(predicate) {
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			controller.enqueue(ev);
			if (typeof predicate === "function" ? predicate(ev) : isWorkflowEvent(predicate) ? predicate.include(ev) : predicate === ev) controller.terminate();
		} }));
	}
	async untilEvent(predicate) {
		const events = await this.until(predicate).toArray();
		const lastEvent = events[events.length - 1];
		if (!lastEvent) throw new Error("Stream ended without matching event");
		const matches = typeof predicate === "function" ? predicate(lastEvent) : isWorkflowEvent(predicate) ? predicate.include(lastEvent) : predicate === lastEvent;
		if (!matches) throw new Error("Stream ended without matching event");
		return lastEvent;
	}
	/**
	* Collect all items from the stream into an array.
	*
	* @returns Promise resolving to an array of all stream items
	*
	* @example
	* ```typescript
	* const events = await stream.take(5).toArray();
	* console.log('Collected events:', events);
	* ```
	*/
	async toArray() {
		const events = [];
		await this.pipeTo(new WritableStream({ write: (event) => {
			events.push(event);
		} }));
		return events;
	}
};

//#endregion
//#region src/core/context.ts
const _executorAsyncLocalStorage = new __llamaindex_workflow_core_async_context.AsyncContext.Variable();
/**
* @deprecated Use the context parameter directly from workflow handlers instead.
* The context passed to handlers already includes all state properties.
*
* @example
* ```ts
* workflow.handle([startEvent], (context, event) => {
*   const { sendEvent } = context;
*   sendEvent(processEvent.with());
* });
* ```
*/
function getContext() {
	const context = _executorAsyncLocalStorage.get();
	if (!context) throw new Error("No current context found");
	return context;
}
/**
* Use this function to add or extend properties of the root context.
* Called by middleware's createContext to update the root context.
* Handler-scoped contexts will automatically inherit these properties from the root context.
* Never create a new object (e.g., using a spread `{...context}`) in your middleware's createContext.
*
* @param context The context to extend
* @param properties The properties to add to the context
* @param inheritanceTransformers The inheritance transformers to apply to existing properties (optional)
*/
function extendContext(context, properties, inheritanceTransformers) {
	Object.assign(context, properties);
	if (inheritanceTransformers) {
		if (!context.__internal__property_inheritance_handlers) context.__internal__property_inheritance_handlers = /* @__PURE__ */ new Map();
		for (const [propertyKey, transformer] of Object.entries(inheritanceTransformers)) {
			context.__internal__property_inheritance_handlers.set(propertyKey, transformer);
			const rootDescriptor = Object.getOwnPropertyDescriptor(context, propertyKey);
			if (rootDescriptor) {
				const newDescriptor = transformer(context, rootDescriptor);
				Object.defineProperty(context, propertyKey, newDescriptor);
			}
		}
	}
}
const handlerContextAsyncLocalStorage = new __llamaindex_workflow_core_async_context.AsyncContext.Variable();
const eventContextWeakMap = /* @__PURE__ */ new WeakMap();
const createContext = ({ listeners }) => {
	const queue = [];
	let rootWorkflowContext;
	const runHandler = (handler, inputEvents, inputs, parentContext) => {
		let handlerAbortController;
		const handlerContext = {
			get abortController() {
				if (!handlerAbortController) handlerAbortController = new AbortController();
				return handlerAbortController;
			},
			async: "constructor" in handler ? handler.constructor.name === "AsyncFunction" : false,
			pending: null,
			handler,
			inputEvents,
			inputs,
			outputs: [],
			prev: parentContext,
			next: /* @__PURE__ */ new Set(),
			get root() {
				return handlerRootContext;
			}
		};
		handlerContext.prev.next.add(handlerContext);
		const specificContext = createWorkflowContext(handlerContext);
		const workflowContext = Object.create(rootWorkflowContext);
		const specificDescriptors = Object.getOwnPropertyDescriptors(specificContext);
		if (rootWorkflowContext.__internal__property_inheritance_handlers) {
			for (const [propertyKey, transformer] of rootWorkflowContext.__internal__property_inheritance_handlers) if (propertyKey in specificDescriptors) {
				const originalDescriptor = specificDescriptors[propertyKey];
				if (originalDescriptor) {
					const newDescriptor = transformer(workflowContext, originalDescriptor);
					specificDescriptors[propertyKey] = newDescriptor;
				}
			}
		}
		Object.defineProperties(workflowContext, specificDescriptors);
		handlerContextAsyncLocalStorage.run(handlerContext, () => {
			const cbs = [...new Set([...getSubscribers(rootWorkflowContext.__internal__call_context), ...getSubscribers(workflowContext.__internal__call_context)])];
			_executorAsyncLocalStorage.run(workflowContext, () => {
				let i$1 = 0;
				const next = (context) => {
					if (i$1 === cbs.length) {
						let result;
						try {
							result = context.handler(workflowContext, ...context.inputs);
						} catch (error) {
							if (handlerAbortController ?? rootAbortController) (handlerAbortController ?? rootAbortController).abort(error);
							else {
								console.error("unhandled error in handler", error);
								throw error;
							}
						}
						if (isPromiseLike(result)) {
							handlerContext.async = true;
							handlerContext.pending = result.then((event) => {
								if (isEventData(event)) workflowContext.sendEvent(event);
								return event;
							});
						} else if (isEventData(result)) workflowContext.sendEvent(result);
					}
					const cb = cbs[i$1];
					if (cb) {
						i$1++;
						cb(context, next);
					}
				};
				next(handlerContext);
			});
		});
	};
	const queueUpdateCallback = (handlerContext) => {
		const queueSnapshot = [...queue];
		[...listeners].filter(([events]) => {
			const inputs = flattenEvents(events, queueSnapshot);
			return inputs.length === events.length;
		}).map(([events, handlers]) => {
			const inputs = flattenEvents(events, queueSnapshot);
			inputs.forEach((input) => {
				queue.splice(queue.indexOf(input), 1);
			});
			for (const handler of handlers) runHandler(handler, events, inputs, handlerContext);
		});
	};
	const createWorkflowContext = (handlerContext) => {
		let lazyLoadStream = null;
		return {
			get stream() {
				if (!lazyLoadStream) {
					const subscribable = createSubscribable();
					rootWorkflowContext.__internal__call_send_event.subscribe((newEvent) => {
						let currentEventContext = eventContextWeakMap.get(newEvent);
						while (currentEventContext) {
							if (currentEventContext === handlerContext) {
								subscribable.publish(newEvent);
								break;
							}
							currentEventContext = currentEventContext.prev;
						}
					});
					lazyLoadStream = new WorkflowStream(subscribable, null);
				}
				return lazyLoadStream;
			},
			get signal() {
				return handlerContext.abortController.signal;
			},
			sendEvent: (...events) => {
				events.forEach((event) => {
					eventContextWeakMap.set(event, handlerContext);
					handlerContext.outputs.push(event);
					queue.push(event);
					rootWorkflowContext.__internal__call_send_event.publish(event, handlerContext);
					queueUpdateCallback(handlerContext);
				});
			},
			__internal__call_context: createSubscribable(),
			__internal__call_send_event: createSubscribable()
		};
	};
	let rootAbortController = new AbortController();
	const handlerRootContext = {
		get abortController() {
			if (!rootAbortController) rootAbortController = new AbortController();
			return rootAbortController;
		},
		async: false,
		pending: null,
		inputEvents: [],
		inputs: [],
		outputs: [],
		handler: null,
		prev: null,
		next: /* @__PURE__ */ new Set(),
		get root() {
			return handlerRootContext;
		}
	};
	rootWorkflowContext = createWorkflowContext(handlerRootContext);
	return rootWorkflowContext;
};

//#endregion
//#region src/core/workflow.ts
/**
* Creates a new workflow instance.
*
* This is the primary factory function for creating workflows. Each workflow
* maintains its own registry of event handlers and can create multiple
* independent execution contexts.
*
* @returns A new workflow instance
*
* @example
* ```typescript
* // Create a simple workflow
* const workflow = createWorkflow();
*
* // Register handlers
* workflow.handle([InputEvent], async (context, event) => {
*   const processed = await processInput(event.data);
*   return OutputEvent.with(processed);
* });
*
* // Use the workflow
* const context = workflow.createContext();
* const input = InputEvent.with({ text: 'Hello World' });
* await context.send(input);
* ```
*
* @category Workflow
* @public
*/
const createWorkflow = () => {
	const config = { steps: /* @__PURE__ */ new Map() };
	return {
		handle: (accept, handler) => {
			if (config.steps.has(accept)) {
				const set = config.steps.get(accept);
				set.add(handler);
			} else {
				const set = /* @__PURE__ */ new Set();
				set.add(handler);
				config.steps.set(accept, set);
			}
		},
		createContext() {
			return createContext({ listeners: config.steps });
		}
	};
};

//#endregion
exports.WorkflowStream = WorkflowStream;
exports.createWorkflow = createWorkflow;
exports.eventSource = eventSource;
exports.extendContext = extendContext;
exports.getContext = getContext;
exports.isWorkflowEvent = isWorkflowEvent;
exports.isWorkflowEventData = isWorkflowEventData;
exports.or = or;
exports.workflowEvent = workflowEvent;
//# sourceMappingURL=index.cjs.map