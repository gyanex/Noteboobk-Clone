{"version":3,"file":"index.js","names":["config?: WorkflowEventConfig<DebugLabel>","instance: WorkflowEventData<any>","data: Data","callback: Callback","instance: unknown","eventData: unknown","data: any","uniqueId: string","data: unknown","value: unknown","acceptEventTypes: WorkflowEvent<any>[]","inputEventData: WorkflowEventData<any>[]","acceptance: WorkflowEventData<any>[]","i","subscribable: Subscribable<Args, R>","callback: (...args: any) => any","results: unknown[]","event: WorkflowEventData<any>","controller: TransformStreamDefaultController<string>","eventMap: Record<string, WorkflowEvent<any>>","data: string","controller: TransformStreamDefaultController<WorkflowEventData<any>>","#eventMap","eventMap","event: WorkflowEvent<T>","handler: (event: WorkflowEventData<T>) => void","#subscribable","subscribable: Subscribable<[R], void> | null","rootStream: ReadableStream<R> | null","#stream","unsubscribe: () => void","stream: ReadableStream<WorkflowEventData<any>>","response: Response","init?: ResponseInit","reason?: any","transform: ReadableWritablePair<T, R>","options?: StreamPipeOptions","destination: WritableStream<R>","callback: (item: R) => void","item: R","callback: (item: R) => T","options?: ReadableStreamIteratorOptions","limit: number","predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | ((event: R) => boolean)\n      | R","predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | R\n      | ((item: R) => boolean)","events: R[]","context: WorkflowContext","properties: Record<string, any>","inheritanceTransformers?: Record<string, InheritanceTransformer>","queue: WorkflowEventData<any>[]","rootWorkflowContext: WorkflowContext","handler: Handler<WorkflowEvent<any>[], any>","inputEvents: WorkflowEvent<any>[]","inputs: WorkflowEventData<any>[]","parentContext: HandlerContext","handlerAbortController: AbortController","handlerContext: HandlerContext","i","context: HandlerContext","result: any","lazyLoadStream: WorkflowStream | null","newEvent: WorkflowEventData<any>","handlerRootContext: HandlerContext","accept: AcceptEvents","handler: Handler<AcceptEvents, Result>"],"sources":["../src/core/event.ts","../src/core/utils.ts","../src/core/stream.ts","../src/core/context.ts","../src/core/workflow.ts"],"sourcesContent":["declare const opaqueSymbol: unique symbol;\n\ntype Callback = (evd: WorkflowEventData<any>) => void;\n\ntype Cleanup = () => void;\n\nconst eventMap = new WeakMap<WorkflowEvent<any>, WeakSet<object>>();\nconst refMap = new WeakMap<WorkflowEventData<any>, WorkflowEvent<any>>();\nconst initCallbackMap = new WeakMap<WorkflowEvent<any>, Set<Callback>>();\nlet i = 0;\nlet j = 0;\n\nexport type InferWorkflowEventData<T> = T extends WorkflowEventData<infer U>\n  ? U\n  : T extends WorkflowEvent<infer U>\n    ? U\n    : never;\n\n/**\n * Represents event data flowing through a workflow.\n *\n * Event data is created when an event is instantiated with the `.with()` method.\n * It carries the actual payload and can be processed by event handlers.\n *\n * @typeParam Data - The type of data this event carries\n * @typeParam DebugLabel - Optional debug label for development/debugging\n *\n * @category Events\n * @public\n */\nexport type WorkflowEventData<Data, DebugLabel extends string = string> = {\n  get data(): Data;\n} & { readonly [opaqueSymbol]: DebugLabel };\n\n/**\n * Represents a workflow event type that can be instantiated with data.\n *\n * Events are the core building blocks of workflows. They define the structure\n * of data that flows through the system and can be used to trigger handlers.\n *\n * @typeParam Data - The type of data this event can carry\n * @typeParam DebugLabel - Optional debug label for development/debugging\n *\n * @example\n * ```typescript\n * // Create an event type\n * const UserLoginEvent = workflowEvent<{ userId: string; timestamp: Date }>();\n *\n * // Create event data\n * const loginData = UserLoginEvent.with({\n *   userId: 'user123',\n *   timestamp: new Date()\n * });\n *\n * // Check if data belongs to this event type\n * if (UserLoginEvent.include(someEventData)) {\n *   console.log('User ID:', someEventData.data.userId);\n * }\n * ```\n *\n * @category Events\n * @public\n */\nexport type WorkflowEvent<Data, DebugLabel extends string = string> = {\n  /**\n   * Optional label used for debugging and logging purposes.\n   */\n  debugLabel?: DebugLabel;\n  /**\n   * Unique identifier for the event type, used for serialization and network communication.\n   */\n  readonly uniqueId: string;\n\n  /**\n   * Creates event data with the provided payload.\n   *\n   * @param data - The data payload for this event instance\n   * @returns Event data that can be sent through workflow contexts\n   */\n  with(data: Data): WorkflowEventData<Data, DebugLabel>;\n\n  /**\n   * Type guard to check if unknown event data belongs to this event type.\n   *\n   * @param event - Unknown event data to check\n   * @returns True if the event data is of this event type\n   */\n  include(event: unknown): event is WorkflowEventData<Data, DebugLabel>;\n\n  /**\n   * Registers a callback to be called when this event type is instantiated.\n   *\n   * @param callback - Function to call when event is created\n   * @returns Cleanup function to remove the callback\n   */\n  onInit(callback: Callback): Cleanup;\n} & { readonly [opaqueSymbol]: DebugLabel };\n\n/**\n * Configuration options for creating workflow events.\n *\n * @typeParam DebugLabel - Optional debug label type\n *\n * @category Events\n * @public\n */\nexport type WorkflowEventConfig<DebugLabel extends string = string> = {\n  /** Optional debug label for development and logging */\n  debugLabel?: DebugLabel;\n  /** Optional unique identifier for the event type */\n  uniqueId?: string;\n};\n\n/**\n * Creates a new workflow event type.\n *\n * This is the primary factory function for creating event types that can be used\n * in workflows. Each event type can carry specific data and be used to trigger\n * handlers throughout the workflow system.\n *\n * @typeParam Data - The type of data this event will carry (defaults to void)\n * @typeParam DebugLabel - Optional debug label type for development\n *\n * @param config - Optional configuration for the event type\n * @returns A new workflow event type that can be instantiated with data\n *\n * @example\n * ```typescript\n * // Create a simple event with no data\n * const StartEvent = workflowEvent();\n *\n * // Create an event that carries user data\n * const UserEvent = workflowEvent<{ name: string; email: string }>({\n *   debugLabel: 'UserEvent'\n * });\n *\n * // Create event instances\n * const start = StartEvent.with();\n * const user = UserEvent.with({ name: 'John', email: 'john@example.com' });\n * ```\n *\n * @category Events\n * @public\n */\nexport const workflowEvent = <Data = void, DebugLabel extends string = string>(\n  config?: WorkflowEventConfig<DebugLabel>,\n): WorkflowEvent<Data, DebugLabel> => {\n  const l1 = `${i++}`;\n  const cb = new Set<Callback>();\n  const event = {\n    debugLabel: config?.debugLabel ?? l1,\n    include: (\n      instance: WorkflowEventData<any>,\n    ): instance is WorkflowEventData<Data> => s.has(instance),\n    with: (data: Data) => {\n      const l2 = `${j++}`;\n      const ref = {\n        [Symbol.toStringTag]:\n          config?.debugLabel ?? `WorkflowEvent(${l1}.${l2})`,\n        toString: () =>\n          config?.debugLabel ? config.debugLabel : `WorkflowEvent(${l1}.${l2})`,\n        toJSON: () => {\n          return {\n            type: config?.debugLabel ? config.debugLabel : l1,\n            data,\n          };\n        },\n        get data() {\n          return data;\n        },\n      } as unknown as WorkflowEventData<Data, DebugLabel>;\n      s.add(ref);\n      refMap.set(ref, event);\n      cb.forEach((c) => c(ref));\n      return ref;\n    },\n    onInit: (callback: Callback) => {\n      cb.add(callback);\n      return () => {\n        cb.delete(callback);\n      };\n    },\n  } as unknown as WorkflowEvent<Data, DebugLabel>;\n\n  const s = new WeakSet();\n  eventMap.set(event, s);\n\n  initCallbackMap.set(event, cb);\n\n  Object.defineProperty(event, Symbol.toStringTag, {\n    get: () => event?.debugLabel ?? `WorkflowEvent<${l1}>`,\n  });\n\n  Object.defineProperty(event, \"displayName\", {\n    value: event?.debugLabel ?? `WorkflowEvent<${l1}>`,\n  });\n\n  let uniqueId = config?.uniqueId;\n\n  Object.defineProperty(event, \"uniqueId\", {\n    get: () => {\n      if (!uniqueId) {\n        uniqueId = l1;\n      }\n      return uniqueId;\n    },\n    set: () => {\n      throw new Error(\"uniqueId is readonly\");\n    },\n  });\n\n  event.toString = () => config?.debugLabel ?? `WorkflowEvent<${l1}>`;\n  return event;\n};\n\n// utils\nexport const isWorkflowEvent = (\n  instance: unknown,\n): instance is WorkflowEvent<any> =>\n  typeof instance === \"object\" && instance !== null\n    ? eventMap.has(instance as any)\n    : false;\nexport const isWorkflowEventData = (\n  instance: unknown,\n): instance is WorkflowEventData<any> =>\n  typeof instance === \"object\" && instance !== null\n    ? refMap.has(instance as any)\n    : false;\nexport const eventSource = (\n  instance: unknown,\n): WorkflowEvent<any> | undefined =>\n  typeof instance === \"object\" && instance !== null\n    ? refMap.get(instance as any)\n    : undefined;\n\n// OR Event Implementation\n\nexport type OrEvent<Events extends WorkflowEvent<any>[]> =\n  WorkflowEvent<any> & {\n    _type: \"or\";\n    events: Events;\n  };\n\nexport const or = <const Events extends WorkflowEvent<any>[]>(\n  ...events: Events\n): OrEvent<Events> => {\n  const debugLabel = `or(${events.map((e) => e.debugLabel || e.uniqueId).join(\", \")})`;\n  const l1 = `or_${i++}`;\n\n  const orEvent = {\n    _type: \"or\" as const,\n    events,\n    debugLabel,\n    include: (eventData: unknown): eventData is WorkflowEventData<any> => {\n      // Accept events from any constituent event OR events created by this OR event\n      return (\n        events.some((event) => event.include(eventData)) ||\n        s.has(eventData as any)\n      );\n    },\n    with: (data: any) => {\n      const ref = {\n        [Symbol.toStringTag]: debugLabel,\n        toString: () => debugLabel,\n        toJSON: () => ({\n          type: debugLabel,\n          data,\n        }),\n        get data() {\n          return data;\n        },\n      } as unknown as WorkflowEventData<any>;\n      s.add(ref);\n      refMap.set(ref, orEvent);\n      return ref;\n    },\n  } as unknown as OrEvent<Events>;\n\n  const s = new WeakSet();\n  eventMap.set(orEvent as any, s);\n\n  let uniqueId: string;\n  Object.defineProperty(orEvent, \"uniqueId\", {\n    get: () => {\n      if (!uniqueId) {\n        uniqueId = l1;\n      }\n      return uniqueId;\n    },\n    set: () => {\n      throw new Error(\"uniqueId is readonly\");\n    },\n  });\n\n  Object.defineProperty(orEvent, Symbol.toStringTag, {\n    get: () => debugLabel,\n  });\n\n  Object.defineProperty(orEvent, \"displayName\", {\n    value: debugLabel,\n  });\n\n  (orEvent as any).toString = () => debugLabel;\n\n  return orEvent;\n};\n","import type { WorkflowEvent, WorkflowEventData } from \"./event\";\n\nexport const isEventData = (data: unknown): data is WorkflowEventData<any> =>\n  data != null && typeof data === \"object\" && \"data\" in data;\n\nexport const isPromiseLike = (value: unknown): value is PromiseLike<unknown> =>\n  value != null && typeof (value as PromiseLike<unknown>).then === \"function\";\n\nexport function flattenEvents(\n  acceptEventTypes: WorkflowEvent<any>[],\n  inputEventData: WorkflowEventData<any>[],\n): WorkflowEventData<any>[] {\n  const acceptance: WorkflowEventData<any>[] = new Array(\n    acceptEventTypes.length,\n  );\n  for (const eventData of inputEventData) {\n    for (let i = 0; i < acceptEventTypes.length; i++) {\n      if (acceptance[i]) {\n        continue;\n      }\n      if (acceptEventTypes[i]!.include(eventData)) {\n        acceptance[i] = eventData;\n        break;\n      }\n    }\n  }\n  return acceptance.filter(Boolean);\n}\n\nexport type Subscribable<Args extends any[], R> = {\n  subscribe: (callback: (...args: Args) => R) => () => void;\n  publish: (...args: Args) => unknown[];\n};\n\nconst __internal__subscribesSourcemap = new WeakMap<\n  Subscribable<any, any>,\n  Set<(...args: any[]) => any>\n>();\n\n/**\n * @internal\n */\nexport function getSubscribers<Args extends any[], R>(\n  subscribable: Subscribable<Args, R>,\n): Set<(...args: Args) => R> {\n  return __internal__subscribesSourcemap.get(subscribable)!;\n}\n\n/**\n * @internal\n */\nexport function createSubscribable<\n  FnOrArgs extends ((...args: any[]) => any) | any[],\n  R = unknown,\n>(): FnOrArgs extends (...args: any[]) => any\n  ? Subscribable<Parameters<FnOrArgs>, ReturnType<FnOrArgs>>\n  : FnOrArgs extends any[]\n    ? Subscribable<FnOrArgs, R>\n    : never {\n  const subscribers = new Set<(...args: any) => any>();\n  const obj = {\n    subscribe: (callback: (...args: any) => any) => {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    publish: (...args: any) => {\n      const results: unknown[] = [];\n      for (const callback of subscribers) {\n        results.push(callback(...args));\n      }\n      return results;\n    },\n  };\n  __internal__subscribesSourcemap.set(obj, subscribers);\n  return obj as any;\n}\n","import {\n  eventSource,\n  type InferWorkflowEventData,\n  isWorkflowEvent,\n  type WorkflowEvent,\n  type WorkflowEventData,\n} from \"./event\";\nimport { createSubscribable, type Subscribable } from \"./utils\";\n\nclass JsonEncodeTransform extends TransformStream<\n  WorkflowEventData<any>,\n  string\n> {\n  constructor() {\n    super({\n      transform: (\n        event: WorkflowEventData<any>,\n        controller: TransformStreamDefaultController<string>,\n      ) => {\n        if (eventSource(event)) {\n          controller.enqueue(\n            JSON.stringify({\n              data: (event as WorkflowEventData<any>).data,\n              uniqueId: eventSource(event)!.uniqueId,\n            }) + \"\\n\",\n          );\n        }\n      },\n    });\n  }\n}\n\nclass JsonDecodeTransform extends TransformStream<\n  string,\n  WorkflowEventData<any>\n> {\n  #eventMap: Record<string, WorkflowEvent<any>>;\n\n  constructor(eventMap: Record<string, WorkflowEvent<any>>) {\n    super({\n      transform: (\n        data: string,\n        controller: TransformStreamDefaultController<WorkflowEventData<any>>,\n      ) => {\n        const lines = data\n          .split(\"\\n\")\n          .map((line) => line.trim())\n          .filter((line) => line.length > 0);\n        lines.forEach((line) => {\n          const eventData = JSON.parse(line) as {\n            data: ReturnType<WorkflowEvent<any>[\"with\"]>;\n            uniqueId: string;\n          };\n          const targetEvent = Object.values(this.#eventMap).find(\n            (e) => e.uniqueId === eventData.uniqueId,\n          );\n          if (targetEvent) {\n            const ev = targetEvent.with(\n              eventData.data,\n            ) as WorkflowEventData<any>;\n            controller.enqueue(ev);\n          } else {\n            console.warn(`Unknown event: ${eventData.uniqueId}`);\n          }\n        });\n      },\n    });\n    this.#eventMap = eventMap;\n  }\n}\n\n/**\n * A reactive stream for processing workflow events.\n *\n * WorkflowStream extends the standard ReadableStream to provide specialized\n * methods for filtering, transforming, and consuming workflow events.\n * It supports reactive patterns and can be used to build complex event\n * processing pipelines.\n *\n * @typeParam R - The type of data flowing through the stream\n *\n * @example\n * ```typescript\n * // Get stream from workflow context\n * const stream = context.stream;\n *\n * // Filter for specific events\n * const userEvents = stream.filter(UserEvent);\n *\n * // Transform events\n * const processed = stream.map(event => ({\n *   type: event.constructor.name,\n *   timestamp: Date.now(),\n *   data: event.data\n * }));\n *\n * // Consume events\n * for await (const event of stream.take(10)) {\n *   console.log('Received:', event);\n * }\n * ```\n *\n * @category Streaming\n * @public\n */\nexport class WorkflowStream<R = any>\n  extends ReadableStream<R>\n  implements AsyncIterable<R>\n{\n  #stream: ReadableStream<R>;\n  #subscribable: Subscribable<[data: R], void>;\n\n  /**\n   * Subscribe to specific workflow events.\n   *\n   * @param event - The event type to listen for\n   * @param handler - Function to handle the event\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = stream.on(UserEvent, (event) => {\n   *   console.log('User event:', event.data);\n   * });\n   *\n   * // Later...\n   * unsubscribe();\n   * ```\n   */\n  on<T>(\n    event: WorkflowEvent<T>,\n    handler: (event: WorkflowEventData<T>) => void,\n  ): () => void {\n    return this.#subscribable.subscribe((ev) => {\n      if (event.include(ev)) {\n        handler(ev);\n      }\n    });\n  }\n\n  constructor(\n    subscribable: Subscribable<[R], void>,\n    rootStream: ReadableStream<R>,\n  );\n  constructor(subscribable: Subscribable<[R], void>, rootStream: null);\n  constructor(subscribable: null, rootStream: ReadableStream<R> | null);\n  constructor(\n    subscribable: Subscribable<[R], void> | null,\n    rootStream: ReadableStream<R> | null,\n  ) {\n    if (!subscribable && !rootStream) {\n      throw new TypeError(\n        \"Either subscribable or root stream must be provided\",\n      );\n    }\n    super();\n    if (!subscribable) {\n      this.#subscribable = createSubscribable<[data: R], void>();\n      this.#stream = rootStream!.pipeThrough(\n        new TransformStream({\n          transform: (ev, controller) => {\n            this.#subscribable.publish(ev);\n            controller.enqueue(ev);\n          },\n        }),\n      );\n      return;\n    } else {\n      this.#subscribable = subscribable;\n      let unsubscribe: () => void;\n      this.#stream =\n        rootStream ??\n        new ReadableStream<R>({\n          start: (controller) => {\n            unsubscribe = subscribable.subscribe((event) => {\n              controller.enqueue(event);\n            });\n          },\n          cancel: () => {\n            unsubscribe();\n          },\n        });\n    }\n  }\n\n  /**\n   * Create a WorkflowStream from a standard ReadableStream.\n   *\n   * @param stream - The ReadableStream to wrap\n   * @returns A new WorkflowStream instance\n   */\n  static fromReadableStream<T = any>(\n    stream: ReadableStream<WorkflowEventData<any>>,\n  ): WorkflowStream<T> {\n    return new WorkflowStream(\n      null,\n      stream.pipeThrough(\n        new TransformStream<WorkflowEventData<any>>({\n          transform: (event, controller) => {\n            controller.enqueue(event);\n          },\n        }),\n      ),\n    );\n  }\n\n  /**\n   * Create a WorkflowStream from an HTTP Response.\n   *\n   * @param response - The HTTP Response containing workflow events\n   * @param eventMap - Map of event unique IDs to event constructors\n   * @returns A new WorkflowStream instance\n   */\n  static fromResponse(\n    response: Response,\n    eventMap: Record<string, WorkflowEvent<any>>,\n  ): WorkflowStream<WorkflowEventData<any>> {\n    const body = response.body;\n    if (!body) {\n      throw new Error(\"Response body is not readable\");\n    }\n    return new WorkflowStream(\n      null,\n      body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new JsonDecodeTransform(eventMap)),\n    );\n  }\n\n  /**\n   * Convert the stream to an HTTP Response.\n   *\n   * @param init - Optional ResponseInit parameters\n   * @param transformer - Optional custom transformer (defaults to JSON encoding)\n   * @returns HTTP Response containing the stream data\n   */\n  toResponse(\n    init?: ResponseInit,\n    transformer = new JsonEncodeTransform(),\n  ): R extends WorkflowEventData<any> ? Response : never {\n    return new Response(\n      (this.#stream as ReadableStream<WorkflowEventData<any>>)\n        .pipeThrough<string>(transformer)\n        .pipeThrough(new TextEncoderStream()),\n      init,\n    ) as any;\n  }\n\n  // ReadableStream compatibility methods - marked as internal to hide from main API docs\n  /** @internal */\n  get locked() {\n    return this.#stream.locked;\n  }\n\n  /** @internal */\n  [Symbol.asyncIterator](): ReadableStreamAsyncIterator<R> {\n    return this.#stream[Symbol.asyncIterator]();\n  }\n\n  /** @internal */\n  cancel(reason?: any): Promise<void> {\n    return this.#stream.cancel(reason);\n  }\n\n  /** @internal */\n  getReader(options: { mode: \"byob\" }): ReadableStreamBYOBReader;\n  /** @internal */\n  getReader(): ReadableStreamDefaultReader<R>;\n  /** @internal */\n  getReader(options?: ReadableStreamGetReaderOptions): ReadableStreamReader<R>;\n  getReader(): any {\n    return this.#stream.getReader();\n  }\n\n  /** @internal */\n  pipeThrough<T>(\n    transform: ReadableWritablePair<T, R>,\n    options?: StreamPipeOptions,\n  ): WorkflowStream<T> {\n    const stream = this.#stream.pipeThrough(transform, options) as any;\n    return new WorkflowStream<T>(null, stream);\n  }\n\n  /** @internal */\n  pipeTo(\n    destination: WritableStream<R>,\n    options?: StreamPipeOptions,\n  ): Promise<void> {\n    return this.#stream.pipeTo(destination, options);\n  }\n\n  /** @internal */\n  tee(): [WorkflowStream<R>, WorkflowStream<R>] {\n    const [l, r] = this.#stream.tee();\n    return [\n      new WorkflowStream(this.#subscribable, l),\n      new WorkflowStream(this.#subscribable, r),\n    ];\n  }\n\n  /**\n   * Process each item in the stream with a callback function.\n   *\n   * @param callback - Function to call for each item\n   * @returns Promise that resolves when all items are processed\n   *\n   * @example\n   * ```typescript\n   * await stream.forEach(event => {\n   *   console.log('Processing:', event);\n   * });\n   * ```\n   */\n  forEach(callback: (item: R) => void): Promise<void> {\n    return this.#stream.pipeTo(\n      new WritableStream({\n        write: (item: R) => {\n          callback(item);\n        },\n      }),\n    );\n  }\n\n  /**\n   * Transform each item in the stream.\n   *\n   * @param callback - Function to transform each item\n   * @returns A new WorkflowStream with transformed items\n   *\n   * @example\n   * ```typescript\n   * const timestamps = stream.map(event => ({\n   *   ...event,\n   *   timestamp: Date.now()\n   * }));\n   * ```\n   */\n  map<T>(callback: (item: R) => T): WorkflowStream<T> {\n    return this.pipeThrough<T>(\n      new TransformStream({\n        transform: (item, controller) => {\n          controller.enqueue(callback(item));\n        },\n      }),\n    );\n  }\n\n  /** @internal */\n  values(\n    options?: ReadableStreamIteratorOptions,\n  ): ReadableStreamAsyncIterator<R> {\n    return this.#stream.values(options);\n  }\n\n  /**\n   * Take only the first N items from the stream.\n   *\n   * @param limit - Maximum number of items to take\n   * @returns A new WorkflowStream limited to the specified number of items\n   *\n   * @example\n   * ```typescript\n   * const firstTen = stream.take(10);\n   * for await (const event of firstTen) {\n   *   console.log(event);\n   * }\n   * ```\n   */\n  take(limit: number): WorkflowStream<R> {\n    let count = 0;\n    return this.pipeThrough(\n      new TransformStream({\n        transform: (ev, controller) => {\n          if (count < limit) {\n            controller.enqueue(ev);\n            count++;\n          }\n          if (count >= limit) {\n            controller.terminate();\n          }\n        },\n      }),\n    );\n  }\n\n  /**\n   * Filter the stream to include only items matching the predicate.\n   *\n   * @param predicate - Event type, function, or value to filter by\n   * @returns A new WorkflowStream containing only matching items\n   *\n   * @example\n   * ```typescript\n   * // Filter by event type\n   * const userEvents = stream.filter(UserEvent);\n   *\n   * // Filter by function\n   * const importantEvents = stream.filter(event => event.priority === 'high');\n   *\n   * // Filter by specific value\n   * const specificEvent = stream.filter(myEventInstance);\n   * ```\n   */\n  filter(\n    predicate: R extends WorkflowEventData<any>\n      ? WorkflowEvent<InferWorkflowEventData<R>>\n      : never,\n  ): WorkflowStream<R>;\n  filter(predicate: R): WorkflowStream<R>;\n  filter(predicate: (event: R) => boolean): WorkflowStream<R>;\n  filter(\n    predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | ((event: R) => boolean)\n      | R,\n  ): WorkflowStream<R> {\n    return this.pipeThrough(\n      new TransformStream({\n        transform: (ev, controller) => {\n          if (\n            typeof predicate === \"function\"\n              ? (predicate as (event: R) => boolean)(ev)\n              : isWorkflowEvent(predicate)\n                ? predicate.include(ev)\n                : predicate === ev\n          ) {\n            controller.enqueue(ev);\n          }\n        },\n      }),\n    );\n  }\n\n  /**\n   * Continue the stream until the predicate is met, then terminate.\n   *\n   * @param predicate - Event type, function, or value to stop at\n   * @returns A new WorkflowStream that terminates when the predicate is met\n   *\n   * @example\n   * ```typescript\n   * // Stop at completion event\n   * const processingEvents = stream.until(CompletionEvent);\n   *\n   * // Stop when condition is met\n   * const beforeError = stream.until(event => event.type === 'error');\n   *\n   * // Stop at specific event instance\n   * const beforeSpecific = stream.until(myEventInstance);\n   * ```\n   */\n  until(\n    predicate: R extends WorkflowEventData<any>\n      ? WorkflowEvent<InferWorkflowEventData<R>>\n      : never,\n  ): WorkflowStream<R>;\n  until(predicate: (item: R) => boolean): WorkflowStream<R>;\n  until(item: R): WorkflowStream<R>;\n  until(\n    predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | R\n      | ((item: R) => boolean),\n  ): WorkflowStream<R> {\n    return this.pipeThrough(\n      new TransformStream({\n        transform: (ev, controller) => {\n          controller.enqueue(ev);\n          if (\n            typeof predicate === \"function\"\n              ? (predicate as (event: R) => boolean)(ev)\n              : isWorkflowEvent(predicate)\n                ? predicate.include(ev)\n                : predicate === ev\n          ) {\n            controller.terminate();\n          }\n        },\n      }),\n    );\n  }\n\n  /**\n   * Continue the stream until a matching event is found, then return that event.\n   *\n   * @param predicate - Event type, function, or value to wait for\n   * @returns Promise resolving to the matching event\n   *\n   * @example\n   * ```typescript\n   * // Wait for completion event and return it directly\n   * const result = await stream.untilEvent(CompletionEvent);\n   * console.log('Final result:', result.data);\n   *\n   * // Wait for condition and return matching event\n   * const errorEvent = await stream.untilEvent(event => event.type === 'error');\n   * ```\n   */\n  async untilEvent(\n    predicate: R extends WorkflowEventData<any>\n      ? WorkflowEvent<InferWorkflowEventData<R>>\n      : never,\n  ): Promise<R>;\n  async untilEvent(predicate: (item: R) => boolean): Promise<R>;\n  async untilEvent(item: R): Promise<R>;\n  async untilEvent(\n    predicate:\n      | WorkflowEvent<InferWorkflowEventData<R>>\n      | R\n      | ((item: R) => boolean),\n  ): Promise<R> {\n    const events = await this.until(predicate as any).toArray();\n    const lastEvent = events[events.length - 1];\n    if (!lastEvent) {\n      throw new Error(\"Stream ended without matching event\");\n    }\n\n    // Check if the last event actually matches the predicate\n    const matches =\n      typeof predicate === \"function\"\n        ? (predicate as (event: R) => boolean)(lastEvent)\n        : isWorkflowEvent(predicate)\n          ? predicate.include(lastEvent)\n          : predicate === lastEvent;\n\n    if (!matches) {\n      throw new Error(\"Stream ended without matching event\");\n    }\n\n    return lastEvent;\n  }\n\n  /**\n   * Collect all items from the stream into an array.\n   *\n   * @returns Promise resolving to an array of all stream items\n   *\n   * @example\n   * ```typescript\n   * const events = await stream.take(5).toArray();\n   * console.log('Collected events:', events);\n   * ```\n   */\n  async toArray(): Promise<R[]> {\n    const events: R[] = [];\n    await this.pipeTo(\n      new WritableStream({\n        write: (event) => {\n          events.push(event);\n        },\n      }),\n    );\n    return events;\n  }\n}\n","import type {\n  WorkflowEvent,\n  WorkflowEventData,\n} from \"@llamaindex/workflow-core\";\nimport { AsyncContext } from \"@llamaindex/workflow-core/async-context\";\nimport { WorkflowStream } from \"./stream\";\nimport {\n  createSubscribable,\n  flattenEvents,\n  getSubscribers,\n  isEventData,\n  isPromiseLike,\n  type Subscribable,\n} from \"./utils\";\n\nexport type Handler<\n  AcceptEvents extends WorkflowEvent<any>[],\n  Result extends WorkflowEventData<any> | void,\n  Context extends WorkflowContext = WorkflowContext,\n> = (\n  context: Context,\n  ...events: {\n    [K in keyof AcceptEvents]: ReturnType<AcceptEvents[K][\"with\"]>;\n  }\n) => Result | Promise<Result>;\n\ntype BaseHandlerContext = {\n  abortController: AbortController;\n  handler: Handler<WorkflowEvent<any>[], any>;\n  // events that are accepted by the handler\n  inputEvents: WorkflowEvent<any>[];\n  // events data that are accepted by the handler\n  inputs: WorkflowEventData<any>[];\n  // events data that are emitted by the handler\n  outputs: WorkflowEventData<any>[];\n\n  //#region linked list data structure\n  prev: HandlerContext;\n  next: Set<HandlerContext>;\n  root: HandlerContext;\n  //#endregion\n};\n\ntype SyncHandlerContext = BaseHandlerContext & {\n  async: false;\n  pending: null;\n};\n\ntype AsyncHandlerContext = BaseHandlerContext & {\n  async: true;\n  pending: Promise<WorkflowEventData<any> | void> | null;\n};\n\nexport type HandlerContext = AsyncHandlerContext | SyncHandlerContext;\n\nexport type ContextNext = (\n  context: HandlerContext,\n  next: (context: HandlerContext) => void,\n) => void;\n\n/**\n * Execution context for workflow event processing.\n *\n * The workflow context provides the runtime environment for executing handlers\n * and managing event flow. It offers access to the event stream, abort signals,\n * and methods for sending events within the workflow.\n *\n * @example\n * ```typescript\n * // Use the current context (first parameter inside a handler)\n * const { sendEvent, stream, signal } = context;\n *\n * // Send events\n * sendEvent(\n *   ProcessEvent.with({ step: 'validation' }),\n *   LogEvent.with({ message: 'Processing started' })\n * );\n *\n * // Access the event stream\n * await stream.filter(CompletionEvent).take(1).toArray();\n *\n * // Check for cancellation\n * if (signal.aborted) {\n *   throw new Error('Operation cancelled');\n * }\n * ```\n *\n * @category Context\n * @public\n */\nexport type WorkflowContext = {\n  /**\n   * Stream of all events flowing through this workflow context.\n   * Can be used to listen for specific events or create reactive processing chains.\n   */\n  get stream(): WorkflowStream<WorkflowEventData<any>>;\n\n  /**\n   * Abort signal that indicates if the workflow has been cancelled.\n   * Handlers should check this periodically for long-running operations.\n   */\n  get signal(): AbortSignal;\n\n  /**\n   * Sends one or more events into the workflow for processing.\n   * Events will be delivered to all matching handlers asynchronously.\n   *\n   * @param events - Event data instances to send\n   */\n  sendEvent: (...events: WorkflowEventData<any>[]) => void;\n\n  /**\n   * @internal\n   */\n  __internal__call_context: Subscribable<\n    Parameters<ContextNext>,\n    ReturnType<ContextNext>\n  >;\n  __internal__call_send_event: Subscribable<\n    [event: WorkflowEventData<any>, handlerContext: HandlerContext],\n    void\n  >;\n  __internal__property_inheritance_handlers?: Map<\n    string,\n    InheritanceTransformer\n  >;\n};\n\nexport type InheritanceTransformer = (\n  handlerContext: WorkflowContext,\n  originalDescriptor: PropertyDescriptor,\n) => PropertyDescriptor;\n\nexport const _executorAsyncLocalStorage =\n  new AsyncContext.Variable<WorkflowContext>();\n\n/**\n * @deprecated Use the context parameter directly from workflow handlers instead.\n * The context passed to handlers already includes all state properties.\n *\n * @example\n * ```ts\n * workflow.handle([startEvent], (context, event) => {\n *   const { sendEvent } = context;\n *   sendEvent(processEvent.with());\n * });\n * ```\n */\nexport function getContext(): WorkflowContext {\n  const context = _executorAsyncLocalStorage.get();\n  if (!context) {\n    throw new Error(\"No current context found\");\n  }\n  return context;\n}\n\n/**\n * Use this function to add or extend properties of the root context.\n * Called by middleware's createContext to update the root context.\n * Handler-scoped contexts will automatically inherit these properties from the root context.\n * Never create a new object (e.g., using a spread `{...context}`) in your middleware's createContext.\n *\n * @param context The context to extend\n * @param properties The properties to add to the context\n * @param inheritanceTransformers The inheritance transformers to apply to existing properties (optional)\n */\nexport function extendContext(\n  context: WorkflowContext,\n  properties: Record<string, any>,\n  inheritanceTransformers?: Record<string, InheritanceTransformer>,\n): void {\n  // Add simple properties directly to the context (these inherit normally via prototype chain)\n  Object.assign(context, properties);\n\n  // Register inheritance transformers for properties that need custom inheritance behavior\n  if (inheritanceTransformers) {\n    if (!context.__internal__property_inheritance_handlers) {\n      context.__internal__property_inheritance_handlers = new Map();\n    }\n\n    for (const [propertyKey, transformer] of Object.entries(\n      inheritanceTransformers,\n    )) {\n      context.__internal__property_inheritance_handlers.set(\n        propertyKey,\n        transformer,\n      );\n\n      // Apply the transformer to the root context immediately\n      const rootDescriptor = Object.getOwnPropertyDescriptor(\n        context,\n        propertyKey,\n      );\n      if (rootDescriptor) {\n        const newDescriptor = transformer(context, rootDescriptor);\n        Object.defineProperty(context, propertyKey, newDescriptor);\n      }\n    }\n  }\n}\n\nconst handlerContextAsyncLocalStorage =\n  new AsyncContext.Variable<HandlerContext>();\n\nconst eventContextWeakMap = new WeakMap<\n  WorkflowEventData<any>,\n  HandlerContext\n>();\n\nexport type ExecutorParams = {\n  listeners: ReadonlyMap<\n    WorkflowEvent<any>[],\n    Set<Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>>\n  >;\n};\n\nexport const createContext = ({\n  listeners,\n}: ExecutorParams): WorkflowContext => {\n  const queue: WorkflowEventData<any>[] = [];\n  // eslint-disable-next-line prefer-const\n  let rootWorkflowContext: WorkflowContext;\n  const runHandler = (\n    handler: Handler<WorkflowEvent<any>[], any>,\n    inputEvents: WorkflowEvent<any>[],\n    inputs: WorkflowEventData<any>[],\n    parentContext: HandlerContext,\n  ): void => {\n    let handlerAbortController: AbortController;\n    const handlerContext: HandlerContext = {\n      get abortController() {\n        if (!handlerAbortController) {\n          handlerAbortController = new AbortController();\n        }\n        return handlerAbortController;\n      },\n      async:\n        \"constructor\" in handler\n          ? handler.constructor.name === \"AsyncFunction\"\n          : false,\n      pending: null,\n      handler,\n      inputEvents,\n      inputs,\n      outputs: [],\n      prev: parentContext,\n      next: new Set(),\n      get root() {\n        return handlerRootContext;\n      },\n    };\n    handlerContext.prev.next.add(handlerContext);\n    // Use prototype chain to inherit the properties of the root workflow context for the specific context for the handler\n    const specificContext = createWorkflowContext(handlerContext);\n    const workflowContext = Object.create(rootWorkflowContext);\n    const specificDescriptors =\n      Object.getOwnPropertyDescriptors(specificContext);\n\n    // Apply inheritance transformers if available\n    if (rootWorkflowContext.__internal__property_inheritance_handlers) {\n      for (const [\n        propertyKey,\n        transformer,\n      ] of rootWorkflowContext.__internal__property_inheritance_handlers) {\n        if (propertyKey in specificDescriptors) {\n          const originalDescriptor = specificDescriptors[propertyKey];\n          if (originalDescriptor) {\n            const newDescriptor = transformer(\n              workflowContext,\n              originalDescriptor,\n            );\n            specificDescriptors[propertyKey] = newDescriptor;\n          }\n        }\n      }\n    }\n\n    Object.defineProperties(workflowContext, specificDescriptors);\n    handlerContextAsyncLocalStorage.run(handlerContext, () => {\n      const cbs = [\n        ...new Set([\n          ...getSubscribers(rootWorkflowContext.__internal__call_context),\n          ...getSubscribers(workflowContext.__internal__call_context),\n        ]),\n      ];\n      _executorAsyncLocalStorage.run(workflowContext, () => {\n        //#region middleware\n        let i = 0;\n        const next = (context: HandlerContext) => {\n          if (i === cbs.length) {\n            let result: any;\n            try {\n              result = context.handler(workflowContext, ...context.inputs);\n            } catch (error) {\n              if (handlerAbortController ?? rootAbortController) {\n                (handlerAbortController ?? rootAbortController).abort(error);\n              } else {\n                console.error(\"unhandled error in handler\", error);\n                throw error;\n              }\n            }\n            // return value is a special event\n            if (isPromiseLike(result)) {\n              (handlerContext as any).async = true;\n              (handlerContext as any).pending = result.then((event) => {\n                if (isEventData(event)) {\n                  workflowContext.sendEvent(event);\n                }\n                return event;\n              });\n            } else if (isEventData(result)) {\n              workflowContext.sendEvent(result);\n            }\n          }\n          const cb = cbs[i];\n          if (cb) {\n            i++;\n            cb(context, next);\n          }\n        };\n        next(handlerContext);\n        //#endregion\n      });\n    });\n  };\n  const queueUpdateCallback = (handlerContext: HandlerContext) => {\n    const queueSnapshot = [...queue];\n    [...listeners]\n      .filter(([events]) => {\n        const inputs = flattenEvents(events, queueSnapshot);\n        return inputs.length === events.length;\n      })\n      .map(([events, handlers]) => {\n        const inputs = flattenEvents(events, queueSnapshot);\n        inputs.forEach((input) => {\n          queue.splice(queue.indexOf(input), 1);\n        });\n        for (const handler of handlers) {\n          runHandler(handler, events, inputs, handlerContext);\n        }\n      });\n  };\n  const createWorkflowContext = (\n    handlerContext: HandlerContext,\n  ): WorkflowContext => {\n    let lazyLoadStream: WorkflowStream | null = null;\n    return {\n      get stream() {\n        if (!lazyLoadStream) {\n          const subscribable = createSubscribable<\n            [event: WorkflowEventData<any>],\n            void\n          >();\n          rootWorkflowContext.__internal__call_send_event.subscribe(\n            (newEvent: WorkflowEventData<any>) => {\n              let currentEventContext = eventContextWeakMap.get(newEvent);\n              while (currentEventContext) {\n                if (currentEventContext === handlerContext) {\n                  subscribable.publish(newEvent);\n                  break;\n                }\n                currentEventContext = currentEventContext.prev;\n              }\n            },\n          );\n          lazyLoadStream = new WorkflowStream(subscribable, null);\n        }\n        return lazyLoadStream;\n      },\n      get signal() {\n        return handlerContext.abortController.signal;\n      },\n      sendEvent: (...events) => {\n        events.forEach((event) => {\n          eventContextWeakMap.set(event, handlerContext);\n          handlerContext.outputs.push(event);\n          queue.push(event);\n          rootWorkflowContext.__internal__call_send_event.publish(\n            event,\n            handlerContext,\n          );\n          queueUpdateCallback(handlerContext);\n        });\n      },\n      __internal__call_context: createSubscribable(),\n      __internal__call_send_event: createSubscribable(),\n    };\n  };\n\n  let rootAbortController = new AbortController();\n  const handlerRootContext: HandlerContext = {\n    get abortController() {\n      if (!rootAbortController) {\n        rootAbortController = new AbortController();\n      }\n      return rootAbortController;\n    },\n    async: false,\n    pending: null,\n    inputEvents: [],\n    inputs: [],\n    outputs: [],\n    handler: null!,\n    prev: null!,\n    next: new Set(),\n    get root() {\n      return handlerRootContext;\n    },\n  };\n\n  rootWorkflowContext = createWorkflowContext(handlerRootContext);\n  return rootWorkflowContext;\n};\n","import { createContext, type Handler, type WorkflowContext } from \"./context\";\nimport type { WorkflowEvent, WorkflowEventData } from \"./event\";\n\n/**\n * Represents a workflow that processes events through registered handlers.\n *\n * A workflow is the central orchestrator for event-driven processing, allowing\n * you to register handlers for specific events and create execution contexts\n * to process those events.\n *\n * @example\n * ```typescript\n * const workflow = createWorkflow();\n *\n * // Register a handler for user events\n * workflow.handle([UserEvent], async (context, event) => {\n *   console.log('Processing user:', event.data.name);\n *   return ProcessedEvent.with({ status: 'complete' });\n * });\n *\n * // Create context and process events\n * const context = workflow.createContext();\n * await context.send(UserEvent.with({ name: 'John' }));\n * ```\n *\n * @category Workflow\n * @public\n */\nexport type Workflow = {\n  /**\n   * Registers a handler function for one or more workflow events.\n   *\n   * The handler will be invoked whenever any of the accepted events are sent\n   * through a workflow context. Handlers can process events and optionally\n   * return new events to continue the workflow.\n   *\n   * @typeParam AcceptEvents - Array of event types this handler accepts\n   * @typeParam Result - Return type of the handler (event data or void)\n   *\n   * @param accept - Array of event types that trigger this handler\n   * @param handler - Function to execute when matching events are received\n   *\n   * @example\n   * ```typescript\n   * // Handle multiple event types\n   * workflow.handle([StartEvent, RestartEvent], async (context, event) => {\n   *   if (StartEvent.include(event)) {\n   *     return ProcessEvent.with({ action: 'start' });\n   *   } else {\n   *     return ProcessEvent.with({ action: 'restart' });\n   *   }\n   * });\n   * ```\n   */\n  handle<\n    const AcceptEvents extends WorkflowEvent<any>[],\n    Result extends ReturnType<WorkflowEvent<any>[\"with\"]> | void,\n  >(accept: AcceptEvents, handler: Handler<AcceptEvents, Result>): void;\n\n  /**\n   * Creates a new workflow context for event processing.\n   *\n   * The context provides the runtime environment for executing handlers\n   * and managing event flow. Each context maintains its own execution\n   * state and event queue.\n   *\n   * @returns A new workflow context instance\n   *\n   * @example\n   * ```typescript\n   * const context = workflow.createContext();\n   *\n   * // Send events through the context\n   * await context.send(MyEvent.with({ data: 'hello' }));\n   *\n   * // Listen for specific events\n   * const result = await context.waitFor(CompletionEvent);\n   * ```\n   */\n  createContext(): WorkflowContext;\n};\n\n/**\n * Creates a new workflow instance.\n *\n * This is the primary factory function for creating workflows. Each workflow\n * maintains its own registry of event handlers and can create multiple\n * independent execution contexts.\n *\n * @returns A new workflow instance\n *\n * @example\n * ```typescript\n * // Create a simple workflow\n * const workflow = createWorkflow();\n *\n * // Register handlers\n * workflow.handle([InputEvent], async (context, event) => {\n *   const processed = await processInput(event.data);\n *   return OutputEvent.with(processed);\n * });\n *\n * // Use the workflow\n * const context = workflow.createContext();\n * const input = InputEvent.with({ text: 'Hello World' });\n * await context.send(input);\n * ```\n *\n * @category Workflow\n * @public\n */\nexport const createWorkflow = (): Workflow => {\n  const config = {\n    steps: new Map<\n      WorkflowEvent<any>[],\n      Set<Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>>\n    >(),\n  };\n\n  return {\n    handle: <\n      const AcceptEvents extends WorkflowEvent<any>[],\n      Result extends ReturnType<WorkflowEvent<any>[\"with\"]> | void,\n    >(\n      accept: AcceptEvents,\n      handler: Handler<AcceptEvents, Result>,\n    ): void => {\n      if (config.steps.has(accept)) {\n        const set = config.steps.get(accept) as Set<\n          Handler<AcceptEvents, Result>\n        >;\n        set.add(handler);\n      } else {\n        const set = new Set<Handler<AcceptEvents, Result>>();\n        set.add(handler);\n        config.steps.set(\n          accept,\n          set as Set<\n            Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>\n          >,\n        );\n      }\n    },\n    createContext() {\n      return createContext({\n        listeners: config.steps,\n      });\n    },\n  };\n};\n"],"mappings":"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"}