import { WorkflowEvent, WorkflowEventData } from "@llamaindex/workflow-core";

//#region src/core/event.d.ts
declare const opaqueSymbol: unique symbol;
type Callback = (evd: WorkflowEventData$1<any>) => void;
type Cleanup = () => void;
type InferWorkflowEventData<T> = T extends WorkflowEventData$1<infer U> ? U : T extends WorkflowEvent$1<infer U> ? U : never;
/**
 * Represents event data flowing through a workflow.
 *
 * Event data is created when an event is instantiated with the `.with()` method.
 * It carries the actual payload and can be processed by event handlers.
 *
 * @typeParam Data - The type of data this event carries
 * @typeParam DebugLabel - Optional debug label for development/debugging
 *
 * @category Events
 * @public
 */
type WorkflowEventData$1<Data, DebugLabel extends string = string> = {
  get data(): Data;
} & {
  readonly [opaqueSymbol]: DebugLabel;
};
/**
 * Represents a workflow event type that can be instantiated with data.
 *
 * Events are the core building blocks of workflows. They define the structure
 * of data that flows through the system and can be used to trigger handlers.
 *
 * @typeParam Data - The type of data this event can carry
 * @typeParam DebugLabel - Optional debug label for development/debugging
 *
 * @example
 * ```typescript
 * // Create an event type
 * const UserLoginEvent = workflowEvent<{ userId: string; timestamp: Date }>();
 *
 * // Create event data
 * const loginData = UserLoginEvent.with({
 *   userId: 'user123',
 *   timestamp: new Date()
 * });
 *
 * // Check if data belongs to this event type
 * if (UserLoginEvent.include(someEventData)) {
 *   console.log('User ID:', someEventData.data.userId);
 * }
 * ```
 *
 * @category Events
 * @public
 */
type WorkflowEvent$1<Data, DebugLabel extends string = string> = {
  /**
   * Optional label used for debugging and logging purposes.
   */
  debugLabel?: DebugLabel;
  /**
   * Unique identifier for the event type, used for serialization and network communication.
   */
  readonly uniqueId: string;
  /**
   * Creates event data with the provided payload.
   *
   * @param data - The data payload for this event instance
   * @returns Event data that can be sent through workflow contexts
   */
  with(data: Data): WorkflowEventData$1<Data, DebugLabel>;
  /**
   * Type guard to check if unknown event data belongs to this event type.
   *
   * @param event - Unknown event data to check
   * @returns True if the event data is of this event type
   */
  include(event: unknown): event is WorkflowEventData$1<Data, DebugLabel>;
  /**
   * Registers a callback to be called when this event type is instantiated.
   *
   * @param callback - Function to call when event is created
   * @returns Cleanup function to remove the callback
   */
  onInit(callback: Callback): Cleanup;
} & {
  readonly [opaqueSymbol]: DebugLabel;
};
/**
 * Configuration options for creating workflow events.
 *
 * @typeParam DebugLabel - Optional debug label type
 *
 * @category Events
 * @public
 */
//#endregion
//#region src/core/utils.d.ts
type Subscribable<Args extends any[], R> = {
  subscribe: (callback: (...args: Args) => R) => () => void;
  publish: (...args: Args) => unknown[];
};
//#endregion
//#region src/core/stream.d.ts
declare class JsonEncodeTransform extends TransformStream<WorkflowEventData$1<any>, string> {
  constructor();
}
/**
 * A reactive stream for processing workflow events.
 *
 * WorkflowStream extends the standard ReadableStream to provide specialized
 * methods for filtering, transforming, and consuming workflow events.
 * It supports reactive patterns and can be used to build complex event
 * processing pipelines.
 *
 * @typeParam R - The type of data flowing through the stream
 *
 * @example
 * ```typescript
 * // Get stream from workflow context
 * const stream = context.stream;
 *
 * // Filter for specific events
 * const userEvents = stream.filter(UserEvent);
 *
 * // Transform events
 * const processed = stream.map(event => ({
 *   type: event.constructor.name,
 *   timestamp: Date.now(),
 *   data: event.data
 * }));
 *
 * // Consume events
 * for await (const event of stream.take(10)) {
 *   console.log('Received:', event);
 * }
 * ```
 *
 * @category Streaming
 * @public
 */
declare class WorkflowStream$1<R = any> extends ReadableStream<R> implements AsyncIterable<R> {
  #private;
  /**
   * Subscribe to specific workflow events.
   *
   * @param event - The event type to listen for
   * @param handler - Function to handle the event
   * @returns Unsubscribe function
   *
   * @example
   * ```typescript
   * const unsubscribe = stream.on(UserEvent, (event) => {
   *   console.log('User event:', event.data);
   * });
   *
   * // Later...
   * unsubscribe();
   * ```
   */
  on<T>(event: WorkflowEvent$1<T>, handler: (event: WorkflowEventData$1<T>) => void): () => void;
  constructor(subscribable: Subscribable<[R], void>, rootStream: ReadableStream<R>);
  constructor(subscribable: Subscribable<[R], void>, rootStream: null);
  constructor(subscribable: null, rootStream: ReadableStream<R> | null);
  /**
   * Create a WorkflowStream from a standard ReadableStream.
   *
   * @param stream - The ReadableStream to wrap
   * @returns A new WorkflowStream instance
   */
  static fromReadableStream<T = any>(stream: ReadableStream<WorkflowEventData$1<any>>): WorkflowStream$1<T>;
  /**
   * Create a WorkflowStream from an HTTP Response.
   *
   * @param response - The HTTP Response containing workflow events
   * @param eventMap - Map of event unique IDs to event constructors
   * @returns A new WorkflowStream instance
   */
  static fromResponse(response: Response, eventMap: Record<string, WorkflowEvent$1<any>>): WorkflowStream$1<WorkflowEventData$1<any>>;
  /**
   * Convert the stream to an HTTP Response.
   *
   * @param init - Optional ResponseInit parameters
   * @param transformer - Optional custom transformer (defaults to JSON encoding)
   * @returns HTTP Response containing the stream data
   */
  toResponse(init?: ResponseInit, transformer?: JsonEncodeTransform): R extends WorkflowEventData$1<any> ? Response : never;
  /**
   * Process each item in the stream with a callback function.
   *
   * @param callback - Function to call for each item
   * @returns Promise that resolves when all items are processed
   *
   * @example
   * ```typescript
   * await stream.forEach(event => {
   *   console.log('Processing:', event);
   * });
   * ```
   */
  forEach(callback: (item: R) => void): Promise<void>;
  /**
   * Transform each item in the stream.
   *
   * @param callback - Function to transform each item
   * @returns A new WorkflowStream with transformed items
   *
   * @example
   * ```typescript
   * const timestamps = stream.map(event => ({
   *   ...event,
   *   timestamp: Date.now()
   * }));
   * ```
   */
  map<T>(callback: (item: R) => T): WorkflowStream$1<T>;
  /**
   * Take only the first N items from the stream.
   *
   * @param limit - Maximum number of items to take
   * @returns A new WorkflowStream limited to the specified number of items
   *
   * @example
   * ```typescript
   * const firstTen = stream.take(10);
   * for await (const event of firstTen) {
   *   console.log(event);
   * }
   * ```
   */
  take(limit: number): WorkflowStream$1<R>;
  /**
   * Filter the stream to include only items matching the predicate.
   *
   * @param predicate - Event type, function, or value to filter by
   * @returns A new WorkflowStream containing only matching items
   *
   * @example
   * ```typescript
   * // Filter by event type
   * const userEvents = stream.filter(UserEvent);
   *
   * // Filter by function
   * const importantEvents = stream.filter(event => event.priority === 'high');
   *
   * // Filter by specific value
   * const specificEvent = stream.filter(myEventInstance);
   * ```
   */
  filter(predicate: R extends WorkflowEventData$1<any> ? WorkflowEvent$1<InferWorkflowEventData<R>> : never): WorkflowStream$1<R>;
  filter(predicate: R): WorkflowStream$1<R>;
  filter(predicate: (event: R) => boolean): WorkflowStream$1<R>;
  /**
   * Continue the stream until the predicate is met, then terminate.
   *
   * @param predicate - Event type, function, or value to stop at
   * @returns A new WorkflowStream that terminates when the predicate is met
   *
   * @example
   * ```typescript
   * // Stop at completion event
   * const processingEvents = stream.until(CompletionEvent);
   *
   * // Stop when condition is met
   * const beforeError = stream.until(event => event.type === 'error');
   *
   * // Stop at specific event instance
   * const beforeSpecific = stream.until(myEventInstance);
   * ```
   */
  until(predicate: R extends WorkflowEventData$1<any> ? WorkflowEvent$1<InferWorkflowEventData<R>> : never): WorkflowStream$1<R>;
  until(predicate: (item: R) => boolean): WorkflowStream$1<R>;
  until(item: R): WorkflowStream$1<R>;
  /**
   * Continue the stream until a matching event is found, then return that event.
   *
   * @param predicate - Event type, function, or value to wait for
   * @returns Promise resolving to the matching event
   *
   * @example
   * ```typescript
   * // Wait for completion event and return it directly
   * const result = await stream.untilEvent(CompletionEvent);
   * console.log('Final result:', result.data);
   *
   * // Wait for condition and return matching event
   * const errorEvent = await stream.untilEvent(event => event.type === 'error');
   * ```
   */
  untilEvent(predicate: R extends WorkflowEventData$1<any> ? WorkflowEvent$1<InferWorkflowEventData<R>> : never): Promise<R>;
  untilEvent(predicate: (item: R) => boolean): Promise<R>;
  untilEvent(item: R): Promise<R>;
  /**
   * Collect all items from the stream into an array.
   *
   * @returns Promise resolving to an array of all stream items
   *
   * @example
   * ```typescript
   * const events = await stream.take(5).toArray();
   * console.log('Collected events:', events);
   * ```
   */
  toArray(): Promise<R[]>;
}
//#endregion
//#region src/core/context.d.ts
type Handler$1<AcceptEvents extends WorkflowEvent<any>[], Result extends WorkflowEventData<any> | void, Context extends WorkflowContext$1 = WorkflowContext$1> = (context: Context, ...events: { [K in keyof AcceptEvents]: ReturnType<AcceptEvents[K]["with"]> }) => Result | Promise<Result>;
type BaseHandlerContext = {
  abortController: AbortController;
  handler: Handler$1<WorkflowEvent<any>[], any>;
  inputEvents: WorkflowEvent<any>[];
  inputs: WorkflowEventData<any>[];
  outputs: WorkflowEventData<any>[];
  prev: HandlerContext;
  next: Set<HandlerContext>;
  root: HandlerContext;
};
type SyncHandlerContext = BaseHandlerContext & {
  async: false;
  pending: null;
};
type AsyncHandlerContext = BaseHandlerContext & {
  async: true;
  pending: Promise<WorkflowEventData<any> | void> | null;
};
type HandlerContext = AsyncHandlerContext | SyncHandlerContext;
/**
 * Execution context for workflow event processing.
 *
 * The workflow context provides the runtime environment for executing handlers
 * and managing event flow. It offers access to the event stream, abort signals,
 * and methods for sending events within the workflow.
 *
 * @example
 * ```typescript
 * // Use the current context (first parameter inside a handler)
 * const { sendEvent, stream, signal } = context;
 *
 * // Send events
 * sendEvent(
 *   ProcessEvent.with({ step: 'validation' }),
 *   LogEvent.with({ message: 'Processing started' })
 * );
 *
 * // Access the event stream
 * await stream.filter(CompletionEvent).take(1).toArray();
 *
 * // Check for cancellation
 * if (signal.aborted) {
 *   throw new Error('Operation cancelled');
 * }
 * ```
 *
 * @category Context
 * @public
 */
type WorkflowContext$1 = {
  /**
   * Stream of all events flowing through this workflow context.
   * Can be used to listen for specific events or create reactive processing chains.
   */
  get stream(): WorkflowStream$1<WorkflowEventData<any>>;
  /**
   * Abort signal that indicates if the workflow has been cancelled.
   * Handlers should check this periodically for long-running operations.
   */
  get signal(): AbortSignal;
  /**
   * Sends one or more events into the workflow for processing.
   * Events will be delivered to all matching handlers asynchronously.
   *
   * @param events - Event data instances to send
   */
  sendEvent: (...events: WorkflowEventData<any>[]) => void;
  __internal__call_send_event: Subscribable<[event: WorkflowEventData<any>, handlerContext: HandlerContext], void>;
  __internal__property_inheritance_handlers?: Map<string, InheritanceTransformer>;
};
type InheritanceTransformer = (handlerContext: WorkflowContext$1, originalDescriptor: PropertyDescriptor) => PropertyDescriptor;
//#endregion
export { Handler$1 as Handler, HandlerContext, WorkflowEvent$1 as WorkflowEvent };
//# sourceMappingURL=context-_dsnyzqi.d.ts.map