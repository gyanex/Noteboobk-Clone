const require_chunk = require('./chunk-CUT6urMc.cjs');
const require_utils = require('./utils-7Ahw9gTU.cjs');
const __llamaindex_workflow_core = require_chunk.__toESM(require("@llamaindex/workflow-core"));
const __llamaindex_workflow_core_async_context = require_chunk.__toESM(require("@llamaindex/workflow-core/async-context"));

//#region src/core/event.ts
const eventMap = /* @__PURE__ */ new WeakMap();
const refMap = /* @__PURE__ */ new WeakMap();
const isWorkflowEvent = (instance) => typeof instance === "object" && instance !== null ? eventMap.has(instance) : false;
const eventSource$1 = (instance) => typeof instance === "object" && instance !== null ? refMap.get(instance) : void 0;

//#endregion
//#region src/core/stream.ts
var JsonEncodeTransform = class extends TransformStream {
	constructor() {
		super({ transform: (event, controller) => {
			if (eventSource$1(event)) controller.enqueue(JSON.stringify({
				data: event.data,
				uniqueId: eventSource$1(event).uniqueId
			}) + "\n");
		} });
	}
};
var JsonDecodeTransform = class extends TransformStream {
	#eventMap;
	constructor(eventMap$1) {
		super({ transform: (data, controller) => {
			const lines = data.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
			lines.forEach((line) => {
				const eventData = JSON.parse(line);
				const targetEvent = Object.values(this.#eventMap).find((e) => e.uniqueId === eventData.uniqueId);
				if (targetEvent) {
					const ev = targetEvent.with(eventData.data);
					controller.enqueue(ev);
				} else console.warn(`Unknown event: ${eventData.uniqueId}`);
			});
		} });
		this.#eventMap = eventMap$1;
	}
};
/**
* A reactive stream for processing workflow events.
*
* WorkflowStream extends the standard ReadableStream to provide specialized
* methods for filtering, transforming, and consuming workflow events.
* It supports reactive patterns and can be used to build complex event
* processing pipelines.
*
* @typeParam R - The type of data flowing through the stream
*
* @example
* ```typescript
* // Get stream from workflow context
* const stream = context.stream;
*
* // Filter for specific events
* const userEvents = stream.filter(UserEvent);
*
* // Transform events
* const processed = stream.map(event => ({
*   type: event.constructor.name,
*   timestamp: Date.now(),
*   data: event.data
* }));
*
* // Consume events
* for await (const event of stream.take(10)) {
*   console.log('Received:', event);
* }
* ```
*
* @category Streaming
* @public
*/
var WorkflowStream = class WorkflowStream extends ReadableStream {
	#stream;
	#subscribable;
	/**
	* Subscribe to specific workflow events.
	*
	* @param event - The event type to listen for
	* @param handler - Function to handle the event
	* @returns Unsubscribe function
	*
	* @example
	* ```typescript
	* const unsubscribe = stream.on(UserEvent, (event) => {
	*   console.log('User event:', event.data);
	* });
	*
	* // Later...
	* unsubscribe();
	* ```
	*/
	on(event, handler) {
		return this.#subscribable.subscribe((ev) => {
			if (event.include(ev)) handler(ev);
		});
	}
	constructor(subscribable, rootStream) {
		if (!subscribable && !rootStream) throw new TypeError("Either subscribable or root stream must be provided");
		super();
		if (!subscribable) {
			this.#subscribable = require_utils.createSubscribable();
			this.#stream = rootStream.pipeThrough(new TransformStream({ transform: (ev, controller) => {
				this.#subscribable.publish(ev);
				controller.enqueue(ev);
			} }));
			return;
		} else {
			this.#subscribable = subscribable;
			let unsubscribe;
			this.#stream = rootStream ?? new ReadableStream({
				start: (controller) => {
					unsubscribe = subscribable.subscribe((event) => {
						controller.enqueue(event);
					});
				},
				cancel: () => {
					unsubscribe();
				}
			});
		}
	}
	/**
	* Create a WorkflowStream from a standard ReadableStream.
	*
	* @param stream - The ReadableStream to wrap
	* @returns A new WorkflowStream instance
	*/
	static fromReadableStream(stream) {
		return new WorkflowStream(null, stream.pipeThrough(new TransformStream({ transform: (event, controller) => {
			controller.enqueue(event);
		} })));
	}
	/**
	* Create a WorkflowStream from an HTTP Response.
	*
	* @param response - The HTTP Response containing workflow events
	* @param eventMap - Map of event unique IDs to event constructors
	* @returns A new WorkflowStream instance
	*/
	static fromResponse(response, eventMap$1) {
		const body = response.body;
		if (!body) throw new Error("Response body is not readable");
		return new WorkflowStream(null, body.pipeThrough(new TextDecoderStream()).pipeThrough(new JsonDecodeTransform(eventMap$1)));
	}
	/**
	* Convert the stream to an HTTP Response.
	*
	* @param init - Optional ResponseInit parameters
	* @param transformer - Optional custom transformer (defaults to JSON encoding)
	* @returns HTTP Response containing the stream data
	*/
	toResponse(init, transformer = new JsonEncodeTransform()) {
		return new Response(this.#stream.pipeThrough(transformer).pipeThrough(new TextEncoderStream()), init);
	}
	/** @internal */
	get locked() {
		return this.#stream.locked;
	}
	/** @internal */
	[Symbol.asyncIterator]() {
		return this.#stream[Symbol.asyncIterator]();
	}
	/** @internal */
	cancel(reason) {
		return this.#stream.cancel(reason);
	}
	getReader() {
		return this.#stream.getReader();
	}
	/** @internal */
	pipeThrough(transform, options) {
		const stream = this.#stream.pipeThrough(transform, options);
		return new WorkflowStream(null, stream);
	}
	/** @internal */
	pipeTo(destination, options) {
		return this.#stream.pipeTo(destination, options);
	}
	/** @internal */
	tee() {
		const [l, r] = this.#stream.tee();
		return [new WorkflowStream(this.#subscribable, l), new WorkflowStream(this.#subscribable, r)];
	}
	/**
	* Process each item in the stream with a callback function.
	*
	* @param callback - Function to call for each item
	* @returns Promise that resolves when all items are processed
	*
	* @example
	* ```typescript
	* await stream.forEach(event => {
	*   console.log('Processing:', event);
	* });
	* ```
	*/
	forEach(callback) {
		return this.#stream.pipeTo(new WritableStream({ write: (item) => {
			callback(item);
		} }));
	}
	/**
	* Transform each item in the stream.
	*
	* @param callback - Function to transform each item
	* @returns A new WorkflowStream with transformed items
	*
	* @example
	* ```typescript
	* const timestamps = stream.map(event => ({
	*   ...event,
	*   timestamp: Date.now()
	* }));
	* ```
	*/
	map(callback) {
		return this.pipeThrough(new TransformStream({ transform: (item, controller) => {
			controller.enqueue(callback(item));
		} }));
	}
	/** @internal */
	values(options) {
		return this.#stream.values(options);
	}
	/**
	* Take only the first N items from the stream.
	*
	* @param limit - Maximum number of items to take
	* @returns A new WorkflowStream limited to the specified number of items
	*
	* @example
	* ```typescript
	* const firstTen = stream.take(10);
	* for await (const event of firstTen) {
	*   console.log(event);
	* }
	* ```
	*/
	take(limit) {
		let count = 0;
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			if (count < limit) {
				controller.enqueue(ev);
				count++;
			}
			if (count >= limit) controller.terminate();
		} }));
	}
	filter(predicate) {
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			if (typeof predicate === "function" ? predicate(ev) : isWorkflowEvent(predicate) ? predicate.include(ev) : predicate === ev) controller.enqueue(ev);
		} }));
	}
	until(predicate) {
		return this.pipeThrough(new TransformStream({ transform: (ev, controller) => {
			controller.enqueue(ev);
			if (typeof predicate === "function" ? predicate(ev) : isWorkflowEvent(predicate) ? predicate.include(ev) : predicate === ev) controller.terminate();
		} }));
	}
	async untilEvent(predicate) {
		const events = await this.until(predicate).toArray();
		const lastEvent = events[events.length - 1];
		if (!lastEvent) throw new Error("Stream ended without matching event");
		const matches = typeof predicate === "function" ? predicate(lastEvent) : isWorkflowEvent(predicate) ? predicate.include(lastEvent) : predicate === lastEvent;
		if (!matches) throw new Error("Stream ended without matching event");
		return lastEvent;
	}
	/**
	* Collect all items from the stream into an array.
	*
	* @returns Promise resolving to an array of all stream items
	*
	* @example
	* ```typescript
	* const events = await stream.take(5).toArray();
	* console.log('Collected events:', events);
	* ```
	*/
	async toArray() {
		const events = [];
		await this.pipeTo(new WritableStream({ write: (event) => {
			events.push(event);
		} }));
		return events;
	}
};

//#endregion
//#region src/core/context.ts
const _executorAsyncLocalStorage = new __llamaindex_workflow_core_async_context.AsyncContext.Variable();
/**
* Use this function to add or extend properties of the root context.
* Called by middleware's createContext to update the root context.
* Handler-scoped contexts will automatically inherit these properties from the root context.
* Never create a new object (e.g., using a spread `{...context}`) in your middleware's createContext.
*
* @param context The context to extend
* @param properties The properties to add to the context
* @param inheritanceTransformers The inheritance transformers to apply to existing properties (optional)
*/
function extendContext(context, properties, inheritanceTransformers) {
	Object.assign(context, properties);
	if (inheritanceTransformers) {
		if (!context.__internal__property_inheritance_handlers) context.__internal__property_inheritance_handlers = /* @__PURE__ */ new Map();
		for (const [propertyKey, transformer] of Object.entries(inheritanceTransformers)) {
			context.__internal__property_inheritance_handlers.set(propertyKey, transformer);
			const rootDescriptor = Object.getOwnPropertyDescriptor(context, propertyKey);
			if (rootDescriptor) {
				const newDescriptor = transformer(context, rootDescriptor);
				Object.defineProperty(context, propertyKey, newDescriptor);
			}
		}
	}
}
const handlerContextAsyncLocalStorage = new __llamaindex_workflow_core_async_context.AsyncContext.Variable();

//#endregion
//#region src/middleware/snapshot/stable-hash.ts
function createStableHash() {
	const table = /* @__PURE__ */ new WeakMap();
	let counter = 0;
	return function stableHash(arg) {
		const type = typeof arg;
		const constructor = arg && arg.constructor;
		const isDate = constructor == Date;
		if (Object(arg) === arg && !isDate && constructor != RegExp) {
			let result = table.get(arg);
			if (result) return result;
			result = ++counter + "~";
			table.set(arg, result);
			let index;
			if (constructor == Array) {
				result = "@";
				for (index = 0; index < arg.length; index++) result += stableHash(arg[index]) + ",";
				table.set(arg, result);
			} else if (constructor == Object) {
				result = "#";
				const keys = Object.keys(arg).sort();
				while ((index = keys.pop()) !== void 0) if (arg[index] !== void 0) result += index + ":" + stableHash(arg[index]) + ",";
				table.set(arg, result);
			}
			return result;
		}
		if (isDate) return arg.toJSON();
		if (type == "symbol") return arg.toString();
		return type == "string" ? JSON.stringify(arg) : "" + arg;
	};
}

//#endregion
//#region src/middleware/state.ts
/**
* Creates a stateful middleware that adds state management capabilities to workflows.
*
* The stateful middleware allows workflows to maintain persistent state across handler executions,
* with support for snapshots and resuming workflow execution from saved states.
*
* @typeParam State - The type of state object to maintain
* @typeParam Input - The type of input used to initialize the state (defaults to void)
* @typeParam Context - The workflow context type (defaults to WorkflowContext)
*
* @param init - Optional initialization function that creates the initial state from input
* @returns A middleware object with state management capabilities
*
* @example
* ```typescript
* import { createWorkflow, workflowEvent } from "@llamaindex/workflow-core";
* import { createStatefulMiddleware } from "@llamaindex/workflow-core/middleware/state";
*
* // Define your state type
* type MyState = {
*   counter: number;
*   messages: string[];
* };
*
* // Create the stateful middleware
* const stateful = createStatefulMiddleware<MyState>();
* const workflow = stateful.withState(createWorkflow());
*
* // Use state in handlers
* workflow.handle([inputEvent], async (context, event) => {
*   const { state, sendEvent } = context;
*   state.counter += 1;
*   state.messages.push(`Processed: ${event.data}`);
*   sendEvent(outputEvent.with({ count: state.counter }));
* });
*
* // Initialize with state
* const { sendEvent, snapshot } = workflow.createContext({
*   counter: 0,
*   messages: []
* });
* ```
*
* @category Middleware
* @public
*/
function createStatefulMiddleware(init) {
	return {
		getContext: __llamaindex_workflow_core.getContext,
		withState: (workflow) => {
			const pendingRequestSetMap = /* @__PURE__ */ new WeakMap();
			const getPendingRequestSet = (context) => {
				if (!pendingRequestSetMap.has(context)) pendingRequestSetMap.set(context, /* @__PURE__ */ new Set());
				return pendingRequestSetMap.get(context);
			};
			const stableHash = createStableHash();
			/**
			* This is to indicate the version of the snapshot
			*
			* It happens when you modify the workflow, all old snapshots should be invalidated
			*/
			const versionObj = [];
			const getVersion = () => stableHash(versionObj);
			const registeredEvents = /* @__PURE__ */ new Set();
			const isContextLockedWeakMap = /* @__PURE__ */ new WeakMap();
			const isContextLocked = (context) => {
				return isContextLockedWeakMap.get(context) === true;
			};
			const isContextSnapshotReadyWeakSet = /* @__PURE__ */ new WeakSet();
			const isContextSnapshotReady = (context) => {
				return isContextSnapshotReadyWeakSet.has(context);
			};
			const contextEventQueueWeakMap = /* @__PURE__ */ new WeakMap();
			const handlerContextSetWeakMap = /* @__PURE__ */ new WeakMap();
			const collectedEventHandlerContextWeakMap = /* @__PURE__ */ new WeakMap();
			const createSnapshotFn = (context) => {
				return async function snapshotHandler() {
					if (isContextLocked(context)) throw new Error("Context is already locked, you cannot snapshot a same context twice");
					isContextLockedWeakMap.set(context, true);
					const handlerContexts = handlerContextSetWeakMap.get(context);
					await Promise.all([...handlerContexts].filter((context$1) => context$1.async).map((context$1) => context$1.pending));
					const queue = contextEventQueueWeakMap.get(context);
					isContextSnapshotReadyWeakSet.add(context);
					const serializable = {
						queue: queue.filter((event) => eventCounterWeakMap.has((0, __llamaindex_workflow_core.eventSource)(event))).map((event) => [event.data, getEventCounter((0, __llamaindex_workflow_core.eventSource)(event))]),
						unrecoverableQueue: queue.filter((event) => !eventCounterWeakMap.has((0, __llamaindex_workflow_core.eventSource)(event))).map((event) => event.data),
						version: getVersion(),
						state: context.state ? JSON.stringify(context.state) : void 0
					};
					return serializable;
				};
			};
			let counter = 0;
			const eventCounterWeakMap = /* @__PURE__ */ new WeakMap();
			const counterEventMap = /* @__PURE__ */ new Map();
			const getEventCounter = (event) => {
				if (!eventCounterWeakMap.has(event)) eventCounterWeakMap.set(event, counter++);
				return eventCounterWeakMap.get(event);
			};
			const getCounterEvent = (counter$1) => {
				if (!counterEventMap.has(counter$1)) throw new Error(`event counter ${counter$1} not found`);
				return counterEventMap.get(counter$1);
			};
			function initContext(context) {
				handlerContextSetWeakMap.set(context, /* @__PURE__ */ new Set());
				contextEventQueueWeakMap.set(context, []);
				context.__internal__call_send_event.subscribe((eventData, handlerContext) => {
					contextEventQueueWeakMap.get(context).push(eventData);
					if (isContextLocked(context)) {
						if (isContextSnapshotReady(context)) console.warn("snapshot is already ready, sendEvent after snapshot is not allowed");
						if (!collectedEventHandlerContextWeakMap.has(eventData)) collectedEventHandlerContextWeakMap.set(eventData, /* @__PURE__ */ new Set());
						collectedEventHandlerContextWeakMap.get(eventData).add(handlerContext);
					}
				});
				context.__internal__call_context.subscribe((handlerContext, next) => {
					if (isContextLocked(context)) {
						handlerContext.handler = () => {};
						next(handlerContext);
					} else {
						const queue = contextEventQueueWeakMap.get(context);
						handlerContext.inputs.forEach((input) => {
							queue.splice(queue.indexOf(input), 1);
						});
						const originalHandler = handlerContext.handler;
						const pendingRequests = getPendingRequestSet(context);
						const isPendingTask = pendingRequests.size !== 0;
						if (isPendingTask) handlerContext.handler = async (...events) => {
							return Promise.all([...pendingRequests]).finally(() => {
								return originalHandler(...events);
							});
						};
						handlerContextSetWeakMap.get(context).add(handlerContext);
						next(handlerContext);
					}
				});
			}
			const createStatefulContext = (state) => {
				const context = workflow.createContext();
				initContext(context);
				const snapshotFn = createSnapshotFn(context);
				extendContext(context, {
					get state() {
						return state;
					},
					snapshot: snapshotFn
				});
				return context;
			};
			return {
				...workflow,
				handle: (events, handler) => {
					versionObj.push([events.map(getEventCounter), handler]);
					events.forEach((event) => {
						counterEventMap.set(getEventCounter(event), event);
					});
					events.forEach((event) => {
						registeredEvents.add(event);
					});
					return workflow.handle(events, handler);
				},
				resume(serializable) {
					const resumedState = serializable.state ? JSON.parse(serializable.state) : void 0;
					const context = createStatefulContext(resumedState);
					context.stream;
					context.sendEvent(...serializable.queue.map(([data, id]) => {
						const event = getCounterEvent(id);
						return event.with(data);
					}));
					return context;
				},
				createContext(input) {
					const state = init?.(input);
					return createStatefulContext(state);
				}
			};
		}
	};
}

//#endregion
exports.createStatefulMiddleware = createStatefulMiddleware;
//# sourceMappingURL=state.cjs.map