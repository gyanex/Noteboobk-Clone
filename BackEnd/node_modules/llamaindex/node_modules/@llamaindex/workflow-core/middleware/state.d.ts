import { Handler } from "./context-_dsnyzqi.js";
import { Workflow as Workflow$1, WorkflowContext, WorkflowEvent } from "@llamaindex/workflow-core";

//#region src/middleware/state.d.ts
interface SnapshotData {
  queue: [data: any, id: number][];
  /**
   * These events are not recoverable because they are not in any handler
   *
   * This is useful when you have `messageEvent` but you don't have any handler for it
   */
  unrecoverableQueue: any[];
  /**
   * This is the version of the snapshot
   *
   * Change any of the handlers will change the version
   */
  version: string;
  /**
   * Save the current serializable state of the workflow
   * This state will be restored when you resume the workflow
   */
  state?: string | undefined;
}
type SnapshotFn = () => Promise<SnapshotData>;
type StatefulContext<State = any, Context extends WorkflowContext = WorkflowContext> = Context & {
  get state(): State;
  snapshot: SnapshotFn;
};
type StatefulHandleFn<State> = <AcceptEvents extends WorkflowEvent<any>[], Result extends ReturnType<WorkflowEvent<any>["with"]> | void>(accept: AcceptEvents, handler: Handler<AcceptEvents, Result, StatefulContext<State>>) => void;
type ResumeFunction<State> = (serializable: Omit<SnapshotData, "unrecoverableQueue">) => StatefulContext<State>;
type WorkflowWithState<State, Input> = Input extends void | undefined ? <Workflow extends Workflow$1>(workflow: Workflow) => Omit<Workflow, "createContext" | "handle"> & {
  createContext(): StatefulContext<State>;
  handle: StatefulHandleFn<State>;
  resume: ResumeFunction<State>;
} : <Workflow extends Workflow$1>(workflow: Workflow) => Omit<Workflow, "createContext" | "handle"> & {
  createContext(input: Input): StatefulContext<State>;
  handle: StatefulHandleFn<State>;
  resume: ResumeFunction<State>;
};
type CreateState<State, Input, Context extends WorkflowContext> = {
  /**
   * @deprecated Use the context parameter directly from workflow handlers instead.
   * The context passed to handlers already includes all state properties.
   *
   * @example
   * ```ts
   * workflow.handle([startEvent], (context, event) => {
   *   const { sendEvent } = context;
   *   sendEvent(processEvent.with());
   * });
   * ```
   */
  getContext(): StatefulContext<State, Context>;
  withState: WorkflowWithState<State, Input>;
};
type InitFunc<Input, State> = (input: Input) => State;
/**
 * Creates a stateful middleware that adds state management capabilities to workflows.
 *
 * The stateful middleware allows workflows to maintain persistent state across handler executions,
 * with support for snapshots and resuming workflow execution from saved states.
 *
 * @typeParam State - The type of state object to maintain
 * @typeParam Input - The type of input used to initialize the state (defaults to void)
 * @typeParam Context - The workflow context type (defaults to WorkflowContext)
 *
 * @param init - Optional initialization function that creates the initial state from input
 * @returns A middleware object with state management capabilities
 *
 * @example
 * ```typescript
 * import { createWorkflow, workflowEvent } from "@llamaindex/workflow-core";
 * import { createStatefulMiddleware } from "@llamaindex/workflow-core/middleware/state";
 *
 * // Define your state type
 * type MyState = {
 *   counter: number;
 *   messages: string[];
 * };
 *
 * // Create the stateful middleware
 * const stateful = createStatefulMiddleware<MyState>();
 * const workflow = stateful.withState(createWorkflow());
 *
 * // Use state in handlers
 * workflow.handle([inputEvent], async (context, event) => {
 *   const { state, sendEvent } = context;
 *   state.counter += 1;
 *   state.messages.push(`Processed: ${event.data}`);
 *   sendEvent(outputEvent.with({ count: state.counter }));
 * });
 *
 * // Initialize with state
 * const { sendEvent, snapshot } = workflow.createContext({
 *   counter: 0,
 *   messages: []
 * });
 * ```
 *
 * @category Middleware
 * @public
 */
declare function createStatefulMiddleware<State, Input = void, Context extends WorkflowContext = WorkflowContext>(init?: InitFunc<Input, State>): CreateState<State, Input, Context>;
//#endregion
export { ResumeFunction, SnapshotData, SnapshotFn, StatefulContext, StatefulHandleFn, WorkflowWithState, createStatefulMiddleware };
//# sourceMappingURL=state.d.ts.map