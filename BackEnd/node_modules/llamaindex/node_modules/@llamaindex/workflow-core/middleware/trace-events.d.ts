import { Handler, HandlerContext, WorkflowEvent } from "./context-_dsnyzqi.js";
import { Handler as Handler$1, WorkflowContext, WorkflowEvent as WorkflowEvent$1, WorkflowEventData, WorkflowStream } from "@llamaindex/workflow-core";

//#region src/middleware/trace-events/create-handler-decorator.d.ts

/**
 * Creates a handler decorator that can instrument workflow handlers with custom behavior.
 *
 * Handler decorators allow you to wrap workflow handlers with additional functionality
 * such as logging, timing, error handling, or state management. They provide hooks
 * that run before and after handler execution.
 *
 * @typeParam Metadata - The type of metadata to track for each handler
 *
 * @param config - Configuration object for the decorator
 * @param config.debugLabel - Optional debug label for identifying the decorator
 * @param config.getInitialValue - Function that returns initial metadata value
 * @param config.onBeforeHandler - Hook that runs before handler execution
 * @param config.onAfterHandler - Hook that runs after handler execution
 * @returns A decorator function that can be used as a trace plugin
 *
 * @example
 * ```typescript
 * import { createWorkflow, workflowEvent } from "@llamaindex/workflow-core";
 * import {
 *   withTraceEvents,
 *   createHandlerDecorator
 * } from "@llamaindex/workflow-core/middleware/trace-events";
 *
 * // Create a timing decorator
 * type TimingMetadata = { startTime: number | null };
 * const timingDecorator = createHandlerDecorator<TimingMetadata>({
 *   debugLabel: "timing",
 *   getInitialValue: () => ({ startTime: null }),
 *   onBeforeHandler: (handler, context, metadata) => async (...args) => {
 *     metadata.startTime = Date.now();
 *     try {
 *       return await handler(...args);
 *     } finally {
 *       const duration = Date.now() - (metadata.startTime ?? 0);
 *       console.log(`Handler executed in ${duration}ms`);
 *     }
 *   },
 *   onAfterHandler: () => ({ startTime: null })
 * });
 *
 * // Use the decorator
 * const workflow = withTraceEvents(createWorkflow(), {
 *   plugins: [timingDecorator]
 * });
 * ```
 *
 * @category Middleware
 * @public
 */
declare function createHandlerDecorator<Metadata>(config: {
  debugLabel?: string;
  getInitialValue: () => Metadata;
  onBeforeHandler: (handler: Handler$1<WorkflowEvent$1<any>[], WorkflowEventData<any> | void>, handlerContext: HandlerContext, metadata: Metadata) => Handler$1<WorkflowEvent$1<any>[], WorkflowEventData<any> | void>;
  onAfterHandler: (metadata: Metadata) => Metadata;
}): <const AcceptEvents extends WorkflowEvent$1<any>[], Result extends ReturnType<WorkflowEvent$1<any>["with"]> | void, Fn extends Handler$1<AcceptEvents, Result>>(handler: Fn) => Fn;
//#endregion
//#region src/middleware/trace-events/run-once.d.ts
declare const runOnce: <const AcceptEvents extends WorkflowEvent<any>[], Result extends ReturnType<WorkflowEvent<any>["with"]> | void, Fn extends Handler<AcceptEvents, Result>>(handler: Fn) => Fn;
//#endregion
//#region src/middleware/trace-events.d.ts
declare function getEventOrigins(eventData: WorkflowEventData<any>, context?: WorkflowContext): [WorkflowEventData<any>, ...WorkflowEventData<any>[]];
type HandlerRef<AcceptEvents extends WorkflowEvent$1<any>[], Result extends ReturnType<WorkflowEvent$1<any>["with"]> | void, Fn extends Handler$1<AcceptEvents, Result>> = {
  get handler(): Fn;
};
type TracePlugin<AcceptEvents extends WorkflowEvent$1<any>[] = WorkflowEvent$1<any>[]> = (handler: Handler$1<AcceptEvents, WorkflowEventData<any> | void>) => Handler$1<AcceptEvents, WorkflowEventData<any> | void>;
type WithTraceEventsOptions = {
  /**
   * Config decorators to apply to all handlers
   */
  plugins?: TracePlugin[];
};
/**
 * Adds tracing capabilities to a workflow by wrapping handlers with trace plugins.
 *
 * This middleware enables comprehensive tracing and monitoring of workflow execution,
 * allowing you to attach plugins that can observe, measure, and instrument handler execution.
 *
 * @typeParam WorkflowLike - The workflow type to enhance with tracing
 *
 * @param workflow - The workflow instance to add tracing to
 * @param options - Configuration object containing trace plugins
 * @returns The workflow enhanced with tracing capabilities
 *
 * @example
 * ```typescript
 * import { createWorkflow, workflowEvent } from "@llamaindex/workflow-core";
 * import { withTraceEvents } from "@llamaindex/workflow-core/middleware/trace-events";
 *
 * // Define events
 * const startEvent = workflowEvent();
 * const processEvent = workflowEvent<string>();
 *
 * // Create a simple timing plugin
 * const timingPlugin = (handler) => async (...args) => {
 *   const start = Date.now();
 *   try {
 *     return await handler(...args);
 *   } finally {
 *     console.log(`Handler took ${Date.now() - start}ms`);
 *   }
 * };
 *
 * // Apply tracing to workflow
 * const workflow = withTraceEvents(createWorkflow(), {
 *   plugins: [timingPlugin]
 * });
 *
 * workflow.handle([startEvent], (context) => {
 *   context.sendEvent(processEvent.with("data"));
 * });
 * ```
 *
 * @category Middleware
 * @public
 */
declare function withTraceEvents<WorkflowLike extends {
  handle<const AcceptEvents extends WorkflowEvent$1<any>[], Result extends ReturnType<WorkflowEvent$1<any>["with"]> | void>(accept: AcceptEvents, handler: Handler$1<AcceptEvents, Result>): void;
  createContext(): WorkflowContext;
}>(workflow: WorkflowLike, options?: WithTraceEventsOptions): Omit<WorkflowLike, "handle"> & {
  handle<const AcceptEvents extends WorkflowEvent$1<any>[], Result extends ReturnType<WorkflowEvent$1<any>["with"]> | void, Fn extends Handler$1<AcceptEvents, Result>>(accept: AcceptEvents, handler: Fn): HandlerRef<AcceptEvents, Result, Fn>;
  substream<T extends WorkflowEventData<any>>(eventData: WorkflowEventData<any>, stream: WorkflowStream<T>): WorkflowStream<T>;
};
//#endregion
export { HandlerRef, TracePlugin, WithTraceEventsOptions, createHandlerDecorator, getEventOrigins, runOnce, withTraceEvents };
//# sourceMappingURL=trace-events.d.ts.map