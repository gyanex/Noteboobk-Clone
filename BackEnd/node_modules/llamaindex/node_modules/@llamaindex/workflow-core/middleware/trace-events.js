import { isPromiseLike } from "./utils-DhleAZ_l.js";
import { getContext } from "@llamaindex/workflow-core";

//#region src/middleware/trace-events/create-handler-decorator.ts
const namespace = "decorator";
let counter = 0;
const decoratorRegistry = /* @__PURE__ */ new Map();
/**
* Creates a handler decorator that can instrument workflow handlers with custom behavior.
*
* Handler decorators allow you to wrap workflow handlers with additional functionality
* such as logging, timing, error handling, or state management. They provide hooks
* that run before and after handler execution.
*
* @typeParam Metadata - The type of metadata to track for each handler
*
* @param config - Configuration object for the decorator
* @param config.debugLabel - Optional debug label for identifying the decorator
* @param config.getInitialValue - Function that returns initial metadata value
* @param config.onBeforeHandler - Hook that runs before handler execution
* @param config.onAfterHandler - Hook that runs after handler execution
* @returns A decorator function that can be used as a trace plugin
*
* @example
* ```typescript
* import { createWorkflow, workflowEvent } from "@llamaindex/workflow-core";
* import {
*   withTraceEvents,
*   createHandlerDecorator
* } from "@llamaindex/workflow-core/middleware/trace-events";
*
* // Create a timing decorator
* type TimingMetadata = { startTime: number | null };
* const timingDecorator = createHandlerDecorator<TimingMetadata>({
*   debugLabel: "timing",
*   getInitialValue: () => ({ startTime: null }),
*   onBeforeHandler: (handler, context, metadata) => async (...args) => {
*     metadata.startTime = Date.now();
*     try {
*       return await handler(...args);
*     } finally {
*       const duration = Date.now() - (metadata.startTime ?? 0);
*       console.log(`Handler executed in ${duration}ms`);
*     }
*   },
*   onAfterHandler: () => ({ startTime: null })
* });
*
* // Use the decorator
* const workflow = withTraceEvents(createWorkflow(), {
*   plugins: [timingDecorator]
* });
* ```
*
* @category Middleware
* @public
*/
function createHandlerDecorator(config) {
	const uid = `${namespace}:${counter++}`;
	decoratorRegistry.set(uid, {
		handlers: /* @__PURE__ */ new WeakSet(),
		debugLabel: config.debugLabel ?? uid,
		getInitialValue: config.getInitialValue,
		onAfterHandler: config.onAfterHandler,
		onBeforeHandler: config.onBeforeHandler
	});
	return (handler) => {
		decoratorRegistry.get(uid).handlers.add(handler);
		return handler;
	};
}

//#endregion
//#region src/middleware/trace-events/run-once.ts
const noop = function noop$1() {};
const runOnce = createHandlerDecorator({
	debugLabel: "onceHook",
	getInitialValue: () => false,
	onBeforeHandler: (handler, _, tracked) => tracked ? noop : handler,
	onAfterHandler: () => true
});

//#endregion
//#region src/middleware/trace-events.ts
const tracingWeakMap = /* @__PURE__ */ new WeakMap();
const contextTraceWeakMap = /* @__PURE__ */ new WeakMap();
const eventToHandlerContextWeakMap = /* @__PURE__ */ new WeakMap();
function getEventOrigins(eventData, context = getContext()) {
	let currentContext = eventToHandlerContextWeakMap.get(eventData);
	if (!currentContext) throw new Error("Event context not found, this should not happen. Please report this issue with a reproducible example.");
	do {
		const workflowContext = contextTraceWeakMap.get(currentContext.prev);
		if (workflowContext === context) return currentContext.inputs;
		currentContext = currentContext.prev;
	} while (currentContext.prev);
	throw new Error("Event context not found, this should not happen. Please report this issue with a reproducible example.");
}
/**
* Adds tracing capabilities to a workflow by wrapping handlers with trace plugins.
*
* This middleware enables comprehensive tracing and monitoring of workflow execution,
* allowing you to attach plugins that can observe, measure, and instrument handler execution.
*
* @typeParam WorkflowLike - The workflow type to enhance with tracing
*
* @param workflow - The workflow instance to add tracing to
* @param options - Configuration object containing trace plugins
* @returns The workflow enhanced with tracing capabilities
*
* @example
* ```typescript
* import { createWorkflow, workflowEvent } from "@llamaindex/workflow-core";
* import { withTraceEvents } from "@llamaindex/workflow-core/middleware/trace-events";
*
* // Define events
* const startEvent = workflowEvent();
* const processEvent = workflowEvent<string>();
*
* // Create a simple timing plugin
* const timingPlugin = (handler) => async (...args) => {
*   const start = Date.now();
*   try {
*     return await handler(...args);
*   } finally {
*     console.log(`Handler took ${Date.now() - start}ms`);
*   }
* };
*
* // Apply tracing to workflow
* const workflow = withTraceEvents(createWorkflow(), {
*   plugins: [timingPlugin]
* });
*
* workflow.handle([startEvent], (context) => {
*   context.sendEvent(processEvent.with("data"));
* });
* ```
*
* @category Middleware
* @public
*/
function withTraceEvents(workflow, options) {
	return {
		...workflow,
		substream: (eventData, stream) => {
			const rootContext = eventToHandlerContextWeakMap.get(eventData);
			return stream.pipeThrough(new TransformStream({ transform(eventData$1, controller) {
				let isInSameContext = false;
				let currentEventContext = eventToHandlerContextWeakMap.get(eventData$1);
				while (currentEventContext) {
					if (currentEventContext === rootContext) {
						isInSameContext = true;
						break;
					}
					currentEventContext = currentEventContext.prev;
				}
				if (isInSameContext) controller.enqueue(eventData$1);
			} }));
		},
		handle: (accept, handler) => {
			let handlerFn = handler;
			if (options?.plugins?.length) options.plugins.forEach((plugin) => {
				handlerFn = plugin(handlerFn);
			});
			workflow.handle(accept, handlerFn);
			return { get handler() {
				return handlerFn;
			} };
		},
		createContext() {
			const context = workflow.createContext();
			tracingWeakMap.set(context, /* @__PURE__ */ new WeakMap());
			context.__internal__call_send_event.subscribe((event, handlerContext) => {
				eventToHandlerContextWeakMap.set(event, handlerContext);
			});
			context.__internal__call_context.subscribe((handlerContext, next) => {
				handlerContext.inputs.forEach((input) => {
					if (!eventToHandlerContextWeakMap.has(input)) console.warn("unregistered event detected");
					eventToHandlerContextWeakMap.set(input, handlerContext);
				});
				const inputEvents = handlerContext.inputEvents;
				const handlersWeakMap = tracingWeakMap.get(context);
				if (!handlersWeakMap.has(inputEvents)) handlersWeakMap.set(inputEvents, /* @__PURE__ */ new WeakMap());
				const handlerWeakMap = handlersWeakMap.get(inputEvents);
				const originalHandler = handlerContext.handler;
				const finalHandler = originalHandler;
				let handlerMiddleware;
				if (!handlerWeakMap) throw new Error("Handler context is not defined, this should not happen. Please report this issue with a reproducible example.");
				const tracingContext = handlerWeakMap.get(originalHandler) ?? {};
				if (!handlerWeakMap.has(originalHandler)) handlerWeakMap.set(originalHandler, tracingContext);
				const onAfterHandlers = [];
				const onBeforeHandlers = [];
				handlerMiddleware = (...args) => {
					const context$1 = getContext();
					contextTraceWeakMap.set(handlerContext, context$1);
					const result = onBeforeHandlers.reduce((next$1, cb) => {
						return cb(next$1);
					}, finalHandler)(...args);
					if (isPromiseLike(result)) return result.then((result$1) => {
						onAfterHandlers.forEach((cb) => {
							cb();
						});
						return result$1;
					});
					else {
						onAfterHandlers.forEach((cb) => {
							cb();
						});
						return result;
					}
				};
				[...decoratorRegistry].filter(([, { handlers }]) => handlers.has(handlerContext.handler)).forEach(([name, { getInitialValue, onAfterHandler, onBeforeHandler }]) => {
					if (!tracingContext[name]) tracingContext[name] = getInitialValue();
					onBeforeHandlers.push((next$1) => onBeforeHandler(next$1, handlerContext, tracingContext[name]));
					onAfterHandlers.push(() => {
						tracingContext[name] = onAfterHandler(tracingContext[name]);
					});
				});
				next({
					...handlerContext,
					handler: handlerMiddleware
				});
			});
			return context;
		}
	};
}

//#endregion
export { createHandlerDecorator, getEventOrigins, runOnce, withTraceEvents };
//# sourceMappingURL=trace-events.js.map