Object.defineProperty(exports, '__esModule', { value: true });

var workflowCore = require('@llamaindex/workflow-core');
var state = require('@llamaindex/workflow-core/middleware/state');
var run = require('@llamaindex/workflow-core/stream/run');
var zod = require('@llamaindex/workflow-core/util/zod');
var agent$1 = require('@llamaindex/core/agent');
var memory = require('@llamaindex/core/memory');
var prompts = require('@llamaindex/core/prompts');
var tools = require('@llamaindex/core/tools');
var utils = require('@llamaindex/core/utils');
var zod$1 = require('@llamaindex/core/zod');
var env = require('@llamaindex/env');
var global = require('@llamaindex/core/global');

const agentToolCallEvent = workflowCore.workflowEvent();
const agentToolCallResultEvent = workflowCore.workflowEvent();
const agentInputEvent = workflowCore.workflowEvent();
const agentSetupEvent = workflowCore.workflowEvent();
const agentStreamEvent = workflowCore.workflowEvent();
const agentOutputEvent = workflowCore.workflowEvent();

const DEFAULT_SYSTEM_PROMPT = "You are a helpful assistant. Use the provided tools to answer questions.";
const STEP_HANDLER_SYSTEM_PROMPT_TPL = `
You are a part of a workflow program that is composed of multiple steps. 
Your task is to handle the step using the provided tools and finally send an output event back to the workflow and summarize the result.

## Instructions
### Follow these default instructions:
1. Provide a plan to handle the actions based on context and the user request.
2. Use the provided tools to proceed with your actions. You can call multiple tools to handle the step and send events.
3. Always return at least one result event at the end to the workflow by using the provided result tools. Identify the event to send based on the user's instructions.

### Here is the user's instructions:
{instructions}
`;
class FunctionAgent {
    constructor({ name, llm, description, tools, canHandoffTo, systemPrompt }){
        this.name = name ?? "Agent";
        this.llm = llm ?? global.Settings.llm;
        if (!this.llm.supportToolCall) {
            throw new Error("FunctionAgent requires an LLM that supports tool calls");
        }
        this.description = description ?? "A single agent that uses the provided tools or functions.";
        this.tools = tools ?? [];
        this.systemPrompt = systemPrompt ?? DEFAULT_SYSTEM_PROMPT;
        this.canHandoffTo = this.initHandOffNames(canHandoffTo ?? []);
    }
    async getStructuredOutput(responseFormat, response) {
        const { object } = await this.llm.exec({
            messages: [
                response
            ],
            responseFormat
        });
        return object ?? {};
    }
    initHandOffNames(handoffTo) {
        const handoffToNames = [];
        if (handoffTo) {
            if (Array.isArray(handoffTo)) {
                if (handoffTo.length > 0) {
                    if (typeof handoffTo[0] === "string") {
                        // string[] case
                        handoffToNames.push(...handoffTo);
                    } else if (handoffTo[0] instanceof AgentWorkflow) {
                        // AgentWorkflow[] case
                        const workflows = handoffTo;
                        workflows.forEach((workflow)=>{
                            const agentNames = workflow.getAgents().map((agent)=>agent.name);
                            handoffToNames.push(...agentNames);
                        });
                    } else {
                        // BaseWorkflowAgent[] case
                        const agents = handoffTo;
                        handoffToNames.push(...agents.map((agent)=>agent.name));
                    }
                }
            }
        }
        const uniqueHandoffAgents = new Set(handoffToNames);
        if (uniqueHandoffAgents.size !== handoffToNames.length) {
            throw new Error("Duplicate handoff agents");
        }
        return handoffToNames;
    }
    async takeStep(ctx, state, llmInput, tools) {
        // Get scratchpad from context or initialize if not present
        const scratchpad = state.scratchpad;
        const currentLLMInput = [
            ...llmInput,
            ...scratchpad
        ];
        const responseStream = await this.llm.chat({
            messages: currentLLMInput,
            tools,
            stream: true
        });
        let response = "";
        let lastChunk;
        const toolCalls = new Map();
        for await (const chunk of responseStream){
            response += chunk.delta;
            ctx.sendEvent(agentStreamEvent.with({
                delta: chunk.delta,
                response: response,
                currentAgentName: this.name,
                raw: chunk.raw
            }));
            const toolCallsInChunk = this.getToolCallFromResponseChunk(chunk);
            if (toolCallsInChunk.length > 0) {
                // Just upsert the tool calls with the latest one if they exist
                toolCallsInChunk.forEach((toolCall)=>{
                    toolCalls.set(toolCall.toolId, toolCall);
                });
            }
        }
        const message = {
            role: "assistant",
            content: response
        };
        if (toolCalls.size > 0) {
            message.options = {
                toolCall: Array.from(toolCalls.values()).map((toolCall)=>({
                        name: toolCall.toolName,
                        input: toolCall.toolKwargs,
                        id: toolCall.toolId
                    }))
            };
        }
        scratchpad.push(message);
        state.scratchpad = scratchpad;
        return {
            response: message,
            toolCalls: Array.from(toolCalls.values()),
            raw: lastChunk?.raw,
            currentAgentName: this.name
        };
    }
    async handleToolCallResults(state, results) {
        const scratchpad = state.scratchpad;
        for (const result of results){
            const content = result.toolOutput.result;
            const rawToolMessage = {
                role: "user",
                content,
                options: {
                    toolResult: {
                        id: result.toolId,
                        result: content,
                        isError: result.toolOutput.isError
                    }
                }
            };
            state.scratchpad.push(rawToolMessage);
        }
        state.scratchpad = scratchpad;
    }
    async finalize(state, output) {
        // Get scratchpad messages
        const scratchpad = state.scratchpad;
        for (const msg of scratchpad){
            state.memory.add(msg);
        }
        // Clear scratchpad after finalization
        state.scratchpad = [];
        return output;
    }
    getToolCallFromResponseChunk(responseChunk) {
        const toolCalls = [];
        const options = responseChunk.options ?? {};
        if (options && "toolCall" in options && Array.isArray(options.toolCall)) {
            toolCalls.push(...options.toolCall.map((call)=>{
                // Convert input to arguments format
                let toolKwargs;
                if (typeof call.input === "string") {
                    try {
                        toolKwargs = JSON.parse(call.input);
                    } catch (e) {
                        toolKwargs = {
                            rawInput: call.input
                        };
                    }
                } else {
                    toolKwargs = call.input;
                }
                return {
                    agentName: this.name,
                    toolName: call.name,
                    toolKwargs: toolKwargs,
                    toolId: call.id
                };
            }));
        }
        const invalidToolCalls = toolCalls.filter((call)=>!this.tools.some((tool)=>tool.metadata.name === call.toolName));
        if (invalidToolCalls.length > 0) {
            const invalidToolNames = invalidToolCalls.map((call)=>call.toolName).join(", ");
            throw new Error(`Tools not found: ${invalidToolNames}`);
        }
        return toolCalls;
    }
    /**
   * Create a FunctionAgent to handle a step of the workflow.
   * @param params.workflowContext - The workflow context.
   * @param params.result - The event to send when the agent is done.
   * @param params.events - Additional events that the agent can emit.
   * @param params.instructions - The user instructions to guide the agent to handle the step.
   * @param params.tools - The tools to use for the agent.
   * @returns A new FunctionAgent instance
   */ static fromWorkflowStep({ workflowContext, results, events, instructions, tools, llm }) {
        if (!workflowContext) {
            throw new Error("workflowContext must be provided");
        }
        if (results.length === 0) {
            throw new Error("results must have at least one event");
        }
        if (!instructions) {
            throw new Error("instructions must be provided");
        }
        // Provided tools
        const allTools = [
            ...tools ?? []
        ];
        // Add tools for result events
        results.forEach((result)=>{
            if (!result.debugLabel) {
                throw new Error("Result event must have a debug label");
            }
            const description = `Use this tool to send the ${result.debugLabel} event as the final result of your task.`;
            allTools.push(createEventEmitterTool(`send_${result.debugLabel}`, result, workflowContext, description));
        });
        // Add tools for additional events
        events?.forEach((event)=>{
            if (!event.debugLabel) {
                throw new Error("Event must have a debug label");
            }
            allTools.push(createEventEmitterTool(`send_${event.debugLabel}`, event, workflowContext, `Use this tool to send the ${event.debugLabel} event to the workflow program.`));
        });
        // Construct the system prompt
        const newSystemPrompt = STEP_HANDLER_SYSTEM_PROMPT_TPL.replace("{instructions}", instructions);
        // Check if llm is provided or default LLM is a tool call LLM
        const llmToUse = llm ?? global.Settings.llm;
        if (!llmToUse.supportToolCall) {
            throw new Error("LLM must support tool calls");
        }
        // Create the function agent
        return new FunctionAgent({
            llm: llmToUse,
            systemPrompt: newSystemPrompt,
            tools: allTools
        });
    }
}
/**
 * Create a tool that sends an event to the workflow.
 * @param name - The name of the tool.
 * @param event - The event to send.
 * @param workflowContext - The workflow context.
 * @param description - The description of the tool.
 */ const createEventEmitterTool = (name, event, workflowContext, description)=>{
    // To ensure the model correctly interprets the event data, including the schema in the tool description is crucial.
    // This is particularly important for special types like literals and enums, which the model might struggle with otherwise.
    // By incorporating the schema into the tool description, we can facilitate the model's understanding of the event data.
    const eventSchemaDescription = zod$1.isZodV3Schema(event.schema) ? event.schema.description : null;
    const toolDescriptionWithSchema = (description ?? eventSchemaDescription ?? "Use this tool to send the event to the workflow.") + `\n\nPlease provide the event data in the following JSON schema: ${JSON.stringify(zod$1.zodToJsonSchema(zod$1.z.object({
        eventData: event.schema
    })))}`;
    return tools.tool({
        name: name,
        description: toolDescriptionWithSchema,
        parameters: zod$1.z.object({
            eventData: event.schema
        }),
        execute: ({ eventData }, getContext)=>{
            if (!getContext) {
                throw new Error("Workflow context is not provided.");
            }
            const context = getContext();
            context.sendEvent(event.with(eventData ?? {}));
            return `Successfully sent a ${name} event!`;
        }
    }).bind(()=>workflowContext);
};

const DEFAULT_HANDOFF_PROMPT = new prompts.PromptTemplate({
    template: `Useful for handing off to another agent.
If you are currently not equipped to handle the user's request, or another agent is better suited to handle the request, please hand off to the appropriate agent.

Currently available agents: 
{agent_info}
`
});
const DEFAULT_HANDOFF_OUTPUT_PROMPT = new prompts.PromptTemplate({
    template: `Agent {to_agent} is now handling the request due to the following reason: {reason}.\nPlease continue with the current request.`
});
const startAgentEvent = workflowCore.workflowEvent({
    debugLabel: "llamaindex-start"
});
const stopAgentEvent = workflowCore.workflowEvent({
    debugLabel: "llamaindex-stop"
});
const toolCallsEvent = workflowCore.workflowEvent();
const toolResultsEvent = workflowCore.workflowEvent();
const agentStepEvent = workflowCore.workflowEvent();
/**
 * Create a multi-agent workflow
 * @param params - Parameters for the AgentWorkflow
 * @returns A new AgentWorkflow instance
 */ const multiAgent = (params)=>{
    return new AgentWorkflow(params);
};
/**
 * Create a simple workflow with a single agent and specified tools
 * @param params - Parameters for the single agent workflow
 * @returns A new AgentWorkflow instance
 */ const agent = (params)=>{
    return AgentWorkflow.fromTools(params);
};
/**
 * AgentWorkflow - An event-driven workflow for executing agents with tools
 *
 * This class provides a simple interface for creating and running agent workflows
 * based on the LlamaIndexTS workflow system. It supports single agent workflows
 * with multiple tools.
 */ class AgentWorkflow {
    constructor({ agents, rootAgent, memory, verbose, logger }){
        this.stateful = state.createStatefulMiddleware((state)=>state);
        this.workflow = this.stateful.withState(workflowCore.createWorkflow());
        this.agents = new Map();
        this.handleInputStep = async (context, event)=>{
            const { state } = context;
            const { userInput, chatHistory } = event.data;
            const memory = state.memory;
            if (chatHistory) {
                chatHistory.forEach((message)=>{
                    memory.add(message);
                });
            }
            if (userInput) {
                const userMessage = {
                    role: "user",
                    content: userInput
                };
                memory.add(userMessage);
            } else if (chatHistory) {
                // If no user message, use the last message from chat history as user_msg_str
                const lastMessage = chatHistory[chatHistory.length - 1];
                if (lastMessage?.role !== "user") {
                    throw new Error("Either provide a user message or a chat history with a user message as the last message");
                }
            } else {
                throw new Error("No user message or chat history provided");
            }
            this.logger.log(`[Agent ${this.rootAgentName}]: Starting agent`);
            return agentInputEvent.with({
                input: await memory.getLLM(this.agents.get(this.rootAgentName)?.llm),
                currentAgentName: this.rootAgentName
            });
        };
        this.setupAgent = async (context, event)=>{
            const currentAgentName = event.data.currentAgentName;
            const agent = this.agents.get(currentAgentName);
            if (!agent) {
                throw new Error(`Agent ${currentAgentName} not found`);
            }
            const llmInput = event.data.input;
            if (agent.systemPrompt) {
                llmInput.unshift({
                    role: "system",
                    content: agent.systemPrompt
                });
            }
            return agentSetupEvent.with({
                input: llmInput,
                currentAgentName: currentAgentName
            });
        };
        this.runAgentStep = async (context, event)=>{
            const { sendEvent } = context;
            const agent = this.agents.get(event.data.currentAgentName);
            if (!agent) {
                throw new Error("No valid agent found");
            }
            const output = await agent.takeStep(context, context.state, event.data.input, agent.tools);
            sendEvent(agentStepEvent.with({
                agentName: agent.name,
                response: output.response,
                toolCalls: output.toolCalls
            }));
            sendEvent(agentOutputEvent.with(output));
        };
        this.parseAgentOutput = async (context, event)=>{
            const { agentName, response, toolCalls } = event.data;
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`parseAgentOutput failed: agent ${agentName} does not exist`);
            }
            // If no tool calls, return final response
            if (!toolCalls || toolCalls.length === 0) {
                this.logger.log(`[Agent ${agentName}]: No tool calls to process, returning final response`);
                const agentOutput = {
                    response,
                    toolCalls: [],
                    raw: response,
                    currentAgentName: agentName
                };
                const content = await agent.finalize(context.state, agentOutput);
                // if responseFormat is set, use the structured tool to parse the response
                let object = undefined;
                if (context.state.responseFormat) {
                    object = await agent.getStructuredOutput(context.state.responseFormat, content.response);
                }
                return stopAgentEvent.with({
                    message: content.response,
                    result: content.response.content,
                    state: context.state,
                    object
                });
            }
            return toolCallsEvent.with({
                agentName,
                toolCalls
            });
        };
        this.executeToolCalls = async (context, event)=>{
            const { sendEvent } = context;
            const { agentName, toolCalls } = event.data;
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`Agent ${agentName} not found`);
            }
            const results = [];
            // Execute each tool call
            for (const toolCall of toolCalls){
                // Send single tool call event, useful for UI
                sendEvent(agentToolCallEvent.with(toolCall));
                const toolResult = {
                    toolName: toolCall.toolName,
                    toolKwargs: toolCall.toolKwargs,
                    toolId: toolCall.toolId,
                    toolOutput: {
                        id: toolCall.toolId,
                        result: "",
                        isError: false
                    },
                    returnDirect: false,
                    raw: {}
                };
                try {
                    const output = await this.callTool(toolCall);
                    toolResult.raw = output;
                    toolResult.toolOutput.result = utils.stringifyJSONToMessageContent(output);
                    toolResult.returnDirect = toolCall.toolName === "handOff";
                } catch (error) {
                    toolResult.toolOutput.isError = true;
                    toolResult.toolOutput.result = `Error: ${error}`;
                }
                results.push(toolResult);
                // Send single tool result event, useful for UI
                sendEvent(agentToolCallResultEvent.with(toolResult));
            }
            return toolResultsEvent.with({
                agentName,
                results
            });
        };
        this.processToolResults = async (context, event)=>{
            const { agentName, results } = event.data;
            // Get agent
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`Agent ${agentName} not found`);
            }
            await agent.handleToolCallResults(context.state, results);
            const directResult = results.find((r)=>r.returnDirect);
            if (directResult) {
                const isHandoff = directResult.toolName === "handOff";
                const raw = directResult.raw;
                const output = typeof raw === "string" ? raw : JSON.stringify(raw);
                const responseMessage = {
                    role: "assistant",
                    content: output
                };
                const agentOutput = {
                    response: responseMessage,
                    toolCalls: [],
                    raw,
                    currentAgentName: agent.name
                };
                await agent.finalize(context.state, agentOutput);
                if (isHandoff) {
                    const nextAgentName = context.state.nextAgentName;
                    this.logger.log(`[Agent ${agentName}]: Handoff to ${nextAgentName}: ${directResult.toolOutput.result}`);
                    if (nextAgentName) {
                        context.state.currentAgentName = nextAgentName;
                        context.state.nextAgentName = null;
                        const messages = await context.state.memory.getLLM(this.agents.get(nextAgentName)?.llm);
                        this.logger.log(`[Agent ${nextAgentName}]: Starting agent`);
                        return agentInputEvent.with({
                            input: messages,
                            currentAgentName: nextAgentName
                        });
                    }
                }
                return stopAgentEvent.with({
                    message: responseMessage,
                    result: output,
                    state: context.state
                });
            }
            // Continue with another agent step
            const messages = await context.state.memory.getLLM(this.agents.get(agent.name)?.llm);
            return agentInputEvent.with({
                input: messages,
                currentAgentName: agent.name
            });
        };
        this.verbose = verbose ?? false;
        if (memory) {
            this.initialMemory = memory;
        }
        // Handle AgentWorkflow cases for agents
        const processedAgents = [];
        if (agents.length > 0) {
            if (agents[0] instanceof AgentWorkflow) {
                // If agents is AgentWorkflow[], extract the BaseWorkflowAgent from each workflow
                const agentWorkflows = agents;
                agentWorkflows.forEach((workflow)=>{
                    const workflowAgents = workflow.getAgents();
                    processedAgents.push(...workflowAgents);
                });
            } else {
                // Otherwise, agents is already BaseWorkflowAgent[]
                processedAgents.push(...agents);
            }
        }
        // Handle AgentWorkflow case for rootAgent and set rootAgentName
        if (rootAgent instanceof AgentWorkflow) {
            // If rootAgent is an AgentWorkflow, check if it has exactly one agent
            const rootAgents = rootAgent.getAgents();
            if (rootAgents.length !== 1) {
                throw new Error(`Root agent must be a single agent, but it is a workflow with ${rootAgents.length} agents`);
            }
            // We know rootAgents[0] exists because we checked length === 1 above
            this.rootAgentName = rootAgents[0].name;
        } else {
            // Otherwise, rootAgent is already a BaseWorkflowAgent
            this.rootAgentName = rootAgent.name;
        }
        // Validate root agent
        if (!processedAgents.some((a)=>a.name === this.rootAgentName)) {
            throw new Error(`Root agent ${this.rootAgentName} not found in agents`);
        }
        this.addAgents(processedAgents);
        this.setupWorkflowSteps();
        // Use the provided logger if exists, else default to consoleLogger if verbose, else emptyLogger
        this.logger = logger ?? (this.verbose ? env.consoleLogger : env.emptyLogger);
    }
    handle(accept, handler) {
        this.workflow.handle(accept, handler);
    }
    createContext() {
        return this.workflow.createContext(this.createInitialState());
    }
    addAgents(agents) {
        const agentNames = new Set(agents.map((a)=>a.name));
        if (agentNames.size !== agents.length) {
            throw new Error("The agent names must be unique!");
        }
        agents.forEach((agent)=>{
            this.agents.set(agent.name, agent);
        });
        if (agents.length > 1) {
            agents.forEach((agent)=>{
                this.validateAgent(agent);
                this.addHandoffTool(agent);
            });
        }
    }
    validateAgent(agent) {
        // Validate that all canHandoffTo agents exist
        const invalidAgents = agent.canHandoffTo.filter((name)=>!this.agents.has(name));
        if (invalidAgents.length > 0) {
            throw new Error(`Agent "${agent.name}" references non-existent agents in canHandoffTo: ${invalidAgents.join(", ")}`);
        }
    }
    addHandoffTool(agent) {
        if (agent.tools.some((t)=>t.metadata.name === "handOff")) {
            return;
        }
        const toHandoffAgents = new Map();
        agent.canHandoffTo.forEach((name)=>{
            toHandoffAgents.set(name, this.agents.get(name));
        });
        const handoffTool = this.createHandoffTool(toHandoffAgents);
        if (agent.canHandoffTo.length > 0 && !agent.tools.some((t)=>t.metadata.name === handoffTool.metadata.name)) {
            agent.tools.push(handoffTool);
        }
    }
    /**
   * Adds a new agent to the workflow
   */ addAgent(agent) {
        this.agents.set(agent.name, agent);
        this.validateAgent(agent);
        this.addHandoffTool(agent);
        return this;
    }
    /**
   * Gets all agents in this workflow
   * @returns Array of agents in this workflow
   */ getAgents() {
        return Array.from(this.agents.values());
    }
    /**
   * Create a simple workflow with a single agent and specified tools
   * @param params - Parameters for the single agent workflow
   * @returns A new AgentWorkflow instance
   */ static fromTools(params) {
        const agent = new FunctionAgent({
            name: params.name,
            description: params.description,
            tools: params.tools,
            llm: params.llm,
            systemPrompt: params.systemPrompt,
            canHandoffTo: params.canHandoffTo
        });
        const workflowParams = {
            agents: [
                agent
            ],
            rootAgent: agent,
            verbose: params.verbose ?? false,
            timeout: params.timeout ?? 60,
            memory: params.memory,
            logger: params.logger
        };
        const workflow = new AgentWorkflow(workflowParams);
        return workflow;
    }
    setupWorkflowSteps() {
        this.workflow.handle([
            startAgentEvent
        ], this.handleInputStep);
        this.workflow.handle([
            agentInputEvent
        ], this.setupAgent);
        this.workflow.handle([
            agentSetupEvent
        ], this.runAgentStep);
        this.workflow.handle([
            agentStepEvent
        ], this.parseAgentOutput);
        this.workflow.handle([
            toolCallsEvent
        ], this.executeToolCalls);
        this.workflow.handle([
            toolResultsEvent
        ], this.processToolResults);
    }
    async callTool(toolCall) {
        const tool = this.agents.get(toolCall.agentName)?.tools.find((t)=>t.metadata.name === toolCall.toolName);
        const toolOutput = await agent$1.callTool(tool, {
            name: toolCall.toolName,
            input: toolCall.toolKwargs,
            id: toolCall.toolId
        }, this.logger);
        if (toolOutput.isError) {
            throw new Error(String(toolOutput.output));
        }
        return toolOutput.output;
    }
    createInitialState() {
        return {
            memory: this.initialMemory ?? memory.createMemory(),
            scratchpad: [],
            currentAgentName: this.rootAgentName,
            agents: Array.from(this.agents.keys()),
            nextAgentName: null
        };
    }
    runStream(userInput, params) {
        if (this.agents.size === 0) {
            throw new Error("No agents added to workflow");
        }
        const state = params?.state ?? this.createInitialState();
        const { sendEvent, stream } = this.workflow.createContext({
            ...state,
            responseFormat: params?.responseFormat
        });
        sendEvent(startAgentEvent.with({
            userInput: userInput,
            chatHistory: params?.chatHistory
        }));
        return stream.until(stopAgentEvent);
    }
    async run(userInput, params) {
        const finalEvent = (await this.runStream(userInput, params).toArray()).at(-1);
        if (!stopAgentEvent.include(finalEvent)) {
            throw new Error(`Agent stopped with unexpected ${finalEvent?.toString() ?? "unknown"} event.`);
        }
        return finalEvent;
    }
    createHandoffTool(agents) {
        const agentInfo = Array.from(agents.values()).reduce((acc, a)=>{
            acc[a.name] = a.description;
            return acc;
        }, {});
        return tools.tool({
            name: "handOff",
            description: DEFAULT_HANDOFF_PROMPT.format({
                agent_info: JSON.stringify(agentInfo)
            }),
            parameters: zod$1.z.object({
                toAgent: zod$1.z.string().describe("The name of the agent to hand off to"),
                reason: zod$1.z.string().describe("The reason for handing off to the agent")
            }),
            execute: ({ toAgent, reason }, contextProvider)=>{
                if (!contextProvider) {
                    throw new Error("Handoff tool internal error: Context was not provided.");
                }
                const context = contextProvider();
                const agents = context.agents;
                if (!agents.includes(toAgent)) {
                    return `Agent ${toAgent} not found. Select a valid agent to hand off to. Valid agents: ${agents.join(", ")}`;
                }
                context.nextAgentName = toAgent;
                return DEFAULT_HANDOFF_OUTPUT_PROMPT.format({
                    to_agent: toAgent,
                    reason: reason
                });
            }
        }).bind(()=>this.stateful.getContext().state);
    }
}

async function handleWorkflowStep(workflow, event, results) {
    const agent = workflow.getAgents()[0];
    if (!agent) {
        throw new Error("No valid agent found");
    }
    const { sendEvent, stream } = workflow.createContext();
    sendEvent(startAgentEvent.with({
        userInput: "Handle with this input data: " + JSON.stringify(event.data)
    }));
    const agentEvents = await stream.until(stopAgentEvent).toArray();
    checkAgentSentResultEvents(agentEvents, results);
}
/**
 * Create a single agent to handle a workflow step
 * @param params - Parameters for the step handler
 * @returns A new AgentWorkflow instance
 */ function createWorkflowForStepHandler(params) {
    if (!params.workflowContext) {
        throw new Error("workflowContext must be provided");
    }
    if (!params.results) {
        throw new Error("results must have at least one event");
    }
    if (!params.instructions) {
        throw new Error("instructions must be provided");
    }
    const agent = FunctionAgent.fromWorkflowStep({
        workflowContext: params.workflowContext,
        results: params.results,
        events: params.events ?? [],
        instructions: params.instructions,
        tools: params.tools,
        llm: params.llm
    });
    return new AgentWorkflow({
        agents: [
            agent
        ],
        rootAgent: agent
    });
}
/**
 * Add an agent handler to the workflow
 * @param params - Parameters for the agent handler
 * @returns A function that handles a workflow step
 */ const agentHandler = (params)=>{
    return async (context, event)=>{
        const workflow = createWorkflowForStepHandler({
            ...params,
            workflowContext: context
        });
        await handleWorkflowStep(workflow, event, params.results);
    };
};
/**
 * Check if the agent already sent at least one result event
 * @param agentEvents - Agent workflow events
 * @param results - The result events that the agent should send
 * @returns True if the agent already sent at least one result event or throw an error if the agent finished without sending a result event
 */ const checkAgentSentResultEvents = (agentEvents, results)=>{
    // We cannot check the result event directly because it's not sent to the agent workflow
    // instead, we check for the tool call event to see if there is a tool call event that match with result events
    const toolCallEvents = agentEvents.filter((event)=>agentToolCallEvent.include(event));
    const resultToolNames = new Set(results.map((r)=>`send_${r.debugLabel}`));
    for (const toolCallEvent of toolCallEvents){
        const toolCall = toolCallEvent.data;
        if (resultToolNames.has(toolCall.toolName)) {
            return true;
        }
    }
    throw new Error("The agent finished without emitting a required result event.");
};

Object.defineProperty(exports, "zodEvent", {
  enumerable: true,
  get: function () { return zod.zodEvent; }
});
exports.AgentWorkflow = AgentWorkflow;
exports.FunctionAgent = FunctionAgent;
exports.agent = agent;
exports.agentHandler = agentHandler;
exports.agentInputEvent = agentInputEvent;
exports.agentOutputEvent = agentOutputEvent;
exports.agentSetupEvent = agentSetupEvent;
exports.agentStepEvent = agentStepEvent;
exports.agentStreamEvent = agentStreamEvent;
exports.agentToolCallEvent = agentToolCallEvent;
exports.agentToolCallResultEvent = agentToolCallResultEvent;
exports.multiAgent = multiAgent;
exports.startAgentEvent = startAgentEvent;
exports.stopAgentEvent = stopAgentEvent;
exports.toolCallsEvent = toolCallsEvent;
exports.toolResultsEvent = toolResultsEvent;
Object.keys(workflowCore).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return workflowCore[k]; }
  });
});
Object.keys(state).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return state[k]; }
  });
});
Object.keys(run).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return run[k]; }
  });
});
