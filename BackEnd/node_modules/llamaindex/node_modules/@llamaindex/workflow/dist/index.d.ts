import * as _llamaindex_workflow_core from '@llamaindex/workflow-core';
import { WorkflowContext, WorkflowEvent, Workflow, Handler, WorkflowStream, WorkflowEventData } from '@llamaindex/workflow-core';
export * from '@llamaindex/workflow-core';
export * from '@llamaindex/workflow-core/middleware/state';
export * from '@llamaindex/workflow-core/stream/run';
import { zodEvent } from '@llamaindex/workflow-core/util/zod';
export { zodEvent } from '@llamaindex/workflow-core/util/zod';
import { ToolResult, ChatMessage, BaseToolWithCall, LLM, MessageContent, ToolCallLLM } from '@llamaindex/core/llms';
import { ZodSchema, ZodInfer } from '@llamaindex/core/zod';
import * as _llamaindex_core_tools from '@llamaindex/core/tools';
import { JSONValue, JSONObject } from '@llamaindex/core/global';
import { Memory } from '@llamaindex/core/memory';
import { Logger } from '@llamaindex/env';

type AgentToolCall = {
    agentName: string;
    toolName: string;
    toolKwargs: Record<string, JSONValue>;
    toolId: string;
};
declare const agentToolCallEvent: _llamaindex_workflow_core.WorkflowEvent<AgentToolCall, string>;
type AgentToolCallResult = {
    toolName: string;
    toolKwargs: Record<string, JSONValue>;
    toolId: string;
    toolOutput: ToolResult;
    returnDirect: boolean;
    raw: JSONValue;
};
declare const agentToolCallResultEvent: _llamaindex_workflow_core.WorkflowEvent<AgentToolCallResult, string>;
type AgentInput = {
    input: ChatMessage[];
    currentAgentName: string;
};
declare const agentInputEvent: _llamaindex_workflow_core.WorkflowEvent<AgentInput, string>;
type AgentSetup = {
    input: ChatMessage[];
    currentAgentName: string;
};
declare const agentSetupEvent: _llamaindex_workflow_core.WorkflowEvent<AgentSetup, string>;
declare const agentStreamEvent: _llamaindex_workflow_core.WorkflowEvent<{
    delta: string;
    response: string;
    currentAgentName: string;
    raw: unknown;
}, string>;
type AgentOutput = {
    response: ChatMessage;
    toolCalls: AgentToolCall[];
    raw: unknown;
    currentAgentName: string;
};
declare const agentOutputEvent: _llamaindex_workflow_core.WorkflowEvent<AgentOutput, string>;

type AgentWorkflowState = {
    memory: Memory;
    scratchpad: ChatMessage[];
    agents: string[];
    currentAgentName: string;
    nextAgentName?: string | null;
    responseFormat?: ZodSchema | undefined;
};
/**
 * Base interface for workflow agents
 */
interface BaseWorkflowAgent {
    readonly name: string;
    readonly systemPrompt: string;
    readonly description: string;
    readonly tools: BaseToolWithCall[];
    readonly llm: LLM;
    readonly canHandoffTo: string[];
    /**
     * Take the final response and convert it to a structured output
     */
    getStructuredOutput(responseFormat: ZodSchema, response: ChatMessage): Promise<JSONObject>;
    /**
     * Take a single step with the agent
     * Using memory directly to get messages instead of requiring them to be passed in
     */
    takeStep(ctx: WorkflowContext, state: AgentWorkflowState, llmInput: ChatMessage[], tools: BaseToolWithCall[]): Promise<AgentOutput>;
    /**
     * Handle results from tool calls
     */
    handleToolCallResults(state: AgentWorkflowState, results: AgentToolCallResult[]): Promise<void>;
    /**
     * Finalize the agent's output
     */
    finalize(state: AgentWorkflowState, output: AgentOutput): Promise<AgentOutput>;
}

type AgentInputData = {
    userInput?: MessageContent | undefined;
    chatHistory?: ChatMessage[] | undefined;
};
declare const startAgentEvent: WorkflowEvent<AgentInputData, "llamaindex-start">;
type AgentResultData<O = JSONObject> = {
    result: MessageContent;
    message: ChatMessage;
    state?: AgentWorkflowState | undefined;
    object?: O | undefined;
};
declare const stopAgentEvent: WorkflowEvent<AgentResultData<JSONObject>, "llamaindex-stop">;
type ToolCalls = {
    agentName: string;
    toolCalls: AgentToolCall[];
};
declare const toolCallsEvent: WorkflowEvent<ToolCalls, string>;
type ToolResults = {
    agentName: string;
    results: AgentToolCallResult[];
};
declare const toolResultsEvent: WorkflowEvent<ToolResults, string>;
type AgentStep = {
    agentName: string;
    response: ChatMessage;
    toolCalls: AgentToolCall[];
};
declare const agentStepEvent: WorkflowEvent<AgentStep, string>;
type SingleAgentParams = FunctionAgentParams & {
    /**
     * Optional predefined memory to use for the workflow.
     * If not provided, a new empty memory will be created.
     */
    memory?: Memory;
    /**
     * Whether to log verbose output
     */
    verbose?: boolean;
    /**
     * Timeout for the workflow in seconds
     */
    timeout?: number;
    /**
     * Attach optional custom logger
     */
    logger?: Logger;
};
type AgentWorkflowParams = {
    /**
     * List of agents to include in the workflow.
     * Need at least one agent.
     * Can also be an array of AgentWorkflow objects, in which case the agents from each workflow will be extracted.
     */
    agents: BaseWorkflowAgent[] | AgentWorkflow[];
    /**
     * The agent to start the workflow with.
     * Must be an agent in the `agents` list.
     * Can also be an AgentWorkflow object, in which case the workflow must have exactly one agent.
     */
    rootAgent: BaseWorkflowAgent | AgentWorkflow;
    /**
     * Optional predefined memory to use for the workflow.
     * If not provided, a new empty memory will be created.
     */
    memory?: Memory | undefined;
    /**
     * Whether to log verbose output
     */
    verbose?: boolean;
    /**
     * Timeout for the workflow in seconds.
     */
    timeout?: number;
    /**
     * Attach optional custom logger
     */
    logger?: Logger | undefined;
};
/**
 * Create a multi-agent workflow
 * @param params - Parameters for the AgentWorkflow
 * @returns A new AgentWorkflow instance
 */
declare const multiAgent: (params: AgentWorkflowParams) => AgentWorkflow;
/**
 * Create a simple workflow with a single agent and specified tools
 * @param params - Parameters for the single agent workflow
 * @returns A new AgentWorkflow instance
 */
declare const agent: (params: SingleAgentParams) => AgentWorkflow;
/**
 * AgentWorkflow - An event-driven workflow for executing agents with tools
 *
 * This class provides a simple interface for creating and running agent workflows
 * based on the LlamaIndexTS workflow system. It supports single agent workflows
 * with multiple tools.
 */
declare class AgentWorkflow implements Workflow {
    private stateful;
    private workflow;
    private agents;
    private verbose;
    private rootAgentName;
    private initialMemory?;
    private logger;
    constructor({ agents, rootAgent, memory, verbose, logger, }: AgentWorkflowParams);
    handle<const AcceptEvents extends WorkflowEvent<unknown>[], Result extends ReturnType<WorkflowEvent<unknown>["with"]> | void>(accept: AcceptEvents, handler: Handler<AcceptEvents, Result>): void;
    createContext(): WorkflowContext;
    private addAgents;
    private validateAgent;
    private addHandoffTool;
    /**
     * Adds a new agent to the workflow
     */
    addAgent(agent: BaseWorkflowAgent): this;
    /**
     * Gets all agents in this workflow
     * @returns Array of agents in this workflow
     */
    getAgents(): BaseWorkflowAgent[];
    /**
     * Create a simple workflow with a single agent and specified tools
     * @param params - Parameters for the single agent workflow
     * @returns A new AgentWorkflow instance
     */
    static fromTools(params: SingleAgentParams): AgentWorkflow;
    private handleInputStep;
    private setupAgent;
    private runAgentStep;
    private parseAgentOutput;
    private executeToolCalls;
    private processToolResults;
    private setupWorkflowSteps;
    private callTool;
    private createInitialState;
    runStream<Z extends ZodSchema>(userInput: MessageContent, params?: {
        chatHistory?: ChatMessage[];
        state?: AgentWorkflowState;
        responseFormat?: Z;
    }): WorkflowStream<WorkflowEventData<AgentResultData<ZodInfer<Z>>>>;
    run<Z extends ZodSchema>(userInput: MessageContent, params?: {
        chatHistory?: ChatMessage[];
        state?: AgentWorkflowState;
        responseFormat?: Z;
    }): Promise<WorkflowEventData<AgentResultData<ZodInfer<Z>>>>;
    createHandoffTool(agents: Map<string, BaseWorkflowAgent>): _llamaindex_core_tools.FunctionTool<{
        toAgent: string;
        reason: string;
    }, JSONValue | Promise<JSONValue>, () => AgentWorkflowState>;
}

type ZodEvent = ReturnType<typeof zodEvent>;
type StepHandlerParams = {
    /**
     * Workflow context
     */
    workflowContext: WorkflowContext;
    /**
     * User instructions to guide the agent to handle the step.
     */
    instructions: string;
    /**
     * Event that this agent will return
     */
    results: ZodEvent[];
    /**
     * List of additional events that the agent can emit
     */
    events?: ZodEvent[];
    /**
     * LLM to use for the agent, required.
     */
    llm?: ToolCallLLM | undefined;
    /**
     * List of tools that the agent can use
     */
    tools?: BaseToolWithCall[] | undefined;
};
type FunctionAgentParams = {
    /**
     * Agent name
     */
    name?: string | undefined;
    /**
     * LLM to use for the agent, required.
     */
    llm?: ToolCallLLM | undefined;
    /**
     * Description of the agent, useful for task assignment.
     * Should provide the capabilities or responsibilities of the agent.
     */
    description?: string | undefined;
    /**
     * List of tools that the agent can use, requires at least one tool.
     */
    tools?: BaseToolWithCall[] | undefined;
    /**
     * List of agents that this agent can delegate tasks to
     * Can be a list of agent names as strings, BaseWorkflowAgent instances, or AgentWorkflow instances
     */
    canHandoffTo?: string[] | BaseWorkflowAgent[] | AgentWorkflow[] | undefined;
    /**
     * Custom system prompt for the agent
     */
    systemPrompt?: string | undefined;
};
type EmitEvent = {
    event: WorkflowEvent<unknown> & {
        schema: ZodEvent["schema"];
    };
    name: string;
};
declare class FunctionAgent implements BaseWorkflowAgent {
    readonly name: string;
    readonly systemPrompt: string;
    readonly description: string;
    readonly llm: ToolCallLLM;
    readonly tools: BaseToolWithCall[];
    readonly canHandoffTo: string[];
    constructor({ name, llm, description, tools, canHandoffTo, systemPrompt, }: FunctionAgentParams);
    getStructuredOutput(responseFormat: ZodSchema, response: ChatMessage): Promise<any>;
    private initHandOffNames;
    takeStep(ctx: WorkflowContext, state: AgentWorkflowState, llmInput: ChatMessage[], tools: BaseToolWithCall[]): Promise<AgentOutput>;
    handleToolCallResults(state: AgentWorkflowState, results: AgentToolCallResult[]): Promise<void>;
    finalize(state: AgentWorkflowState, output: AgentOutput): Promise<AgentOutput>;
    private getToolCallFromResponseChunk;
    /**
     * Create a FunctionAgent to handle a step of the workflow.
     * @param params.workflowContext - The workflow context.
     * @param params.result - The event to send when the agent is done.
     * @param params.events - Additional events that the agent can emit.
     * @param params.instructions - The user instructions to guide the agent to handle the step.
     * @param params.tools - The tools to use for the agent.
     * @returns A new FunctionAgent instance
     */
    static fromWorkflowStep({ workflowContext, results, events, instructions, tools, llm, }: StepHandlerParams): FunctionAgent;
}

/**
 * Add an agent handler to the workflow
 * @param params - Parameters for the agent handler
 * @returns A function that handles a workflow step
 */
declare const agentHandler: (params: Omit<StepHandlerParams, "workflowContext">) => (context: WorkflowContext, event: WorkflowEventData<unknown>) => Promise<void>;

export { AgentWorkflow, FunctionAgent, agent, agentHandler, agentInputEvent, agentOutputEvent, agentSetupEvent, agentStepEvent, agentStreamEvent, agentToolCallEvent, agentToolCallResultEvent, multiAgent, startAgentEvent, stopAgentEvent, toolCallsEvent, toolResultsEvent };
export type { AgentInput, AgentInputData, AgentOutput, AgentResultData, AgentSetup, AgentStep, AgentToolCall, AgentToolCallResult, AgentWorkflowParams, AgentWorkflowState, BaseWorkflowAgent, EmitEvent, FunctionAgentParams, SingleAgentParams, StepHandlerParams, ToolCalls, ToolResults, ZodEvent };
